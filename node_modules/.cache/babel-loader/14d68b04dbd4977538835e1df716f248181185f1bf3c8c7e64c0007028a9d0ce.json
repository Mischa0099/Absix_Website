{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useWebSerial } from './useWebSerial';\nimport { updateConnectionStatus, setMotors, updateMotor, addMotor, removeMotor, updateChartData, addLogEntry, incrementCommandCount, updateUptime, startChallenge, stopChallenge as stopChallengeAction, updateChallengeProgress, updateHardwareStats, setEmergencyStop, selectRobot, selectIsConnected, selectMotors, selectChallengeStatus } from '../store/robotSlice';\nimport { rawToDegrees, degreesToPositionRaw, degreesToVelocityRaw } from '../utils/robotUtils';\nimport { COMMANDS, ROBOT_SPECS, PERFORMANCE } from '../utils/constants';\nimport { now, clamp, throttle, debugLog, errorLog } from '../utils/helpers';\nimport toast from 'react-hot-toast';\nexport const useRobotController = () => {\n  _s();\n  const dispatch = useDispatch();\n  const robotState = useSelector(selectRobot);\n  const isConnected = useSelector(selectIsConnected);\n  const motors = useSelector(selectMotors);\n  const challengeStatus = useSelector(selectChallengeStatus);\n  const {\n    isSupported,\n    connect: connectSerial,\n    disconnect: disconnectSerial,\n    sendCommand,\n    pingMotor: serialPingMotor,\n    emergencyStop: serialEmergencyStop\n  } = useWebSerial();\n  const [connectionStartTime, setConnectionStartTime] = useState(null);\n  const [challengeInterval, setChallengeInterval] = useState(null);\n  const [uptimeInterval, setUptimeInterval] = useState(null);\n  const [monitoringInterval, setMonitoringInterval] = useState(null);\n  const performanceRef = useRef({\n    commandsSent: 0,\n    commandsSuccessful: 0,\n    lastPerformanceUpdate: now()\n  });\n\n  // Connection management\n  useEffect(() => {\n    if (isConnected && !connectionStartTime) {\n      setConnectionStartTime(now());\n      startUptimeCounter();\n      startPeriodicMonitoring();\n\n      // Auto-scan for motors after connection\n      setTimeout(() => {\n        scanMotors();\n      }, 2000);\n    } else if (!isConnected && connectionStartTime) {\n      setConnectionStartTime(null);\n      stopUptimeCounter();\n      stopPeriodicMonitoring();\n      stopChallenge();\n    }\n  }, [isConnected, connectionStartTime]);\n\n  // Uptime counter\n  const startUptimeCounter = useCallback(() => {\n    const interval = setInterval(() => {\n      if (connectionStartTime) {\n        const uptime = now() - connectionStartTime;\n        dispatch(updateUptime(uptime));\n      }\n    }, 1000);\n    setUptimeInterval(interval);\n  }, [connectionStartTime, dispatch]);\n  const stopUptimeCounter = useCallback(() => {\n    if (uptimeInterval) {\n      clearInterval(uptimeInterval);\n      setUptimeInterval(null);\n    }\n  }, [uptimeInterval]);\n\n  // Periodic monitoring\n  const startPeriodicMonitoring = useCallback(() => {\n    const interval = setInterval(async () => {\n      if (!isConnected || motors.length === 0) return;\n      try {\n        // Monitor each connected motor\n        for (const motor of motors) {\n          if (motor.online) {\n            // Get current position and temperature\n            await updateMotorData(motor.id);\n          }\n        }\n\n        // Update performance metrics\n        updatePerformanceMetrics();\n      } catch (error) {\n        debugLog('Monitoring error:', error);\n      }\n    }, robotState.settings.updateRate || 1000);\n    setMonitoringInterval(interval);\n  }, [isConnected, motors, robotState.settings.updateRate]);\n  const stopPeriodicMonitoring = useCallback(() => {\n    if (monitoringInterval) {\n      clearInterval(monitoringInterval);\n      setMonitoringInterval(null);\n    }\n  }, [monitoringInterval]);\n\n  // Update motor data\n  const updateMotorData = useCallback(async motorId => {\n    try {\n      // This would be implemented with actual sensor reading\n      // For now, we'll simulate or use cached values\n\n      const motor = motors.find(m => m.id === motorId);\n      if (!motor) return;\n\n      // Simulate data updates (in real implementation, this would read from hardware)\n      const currentTime = now();\n      const timeDiff = currentTime - motor.lastUpdate;\n      if (timeDiff > 100) {\n        // Update every 100ms\n        const simulatedData = {\n          position: motor.position + (Math.random() - 0.5) * 2,\n          // Small random variation\n          velocity: motor.velocity + (Math.random() - 0.5) * 5,\n          temperature: 25 + Math.random() * 10,\n          current: Math.random() * 0.5\n        };\n        dispatch(updateMotor({\n          motorId,\n          updates: {\n            ...simulatedData,\n            lastUpdate: currentTime\n          }\n        }));\n\n        // Update chart data\n        dispatch(updateChartData({\n          time: currentTime,\n          motorId,\n          position: simulatedData.position,\n          velocity: simulatedData.velocity,\n          temperature: simulatedData.temperature,\n          current: simulatedData.current\n        }));\n      }\n    } catch (error) {\n      errorLog(`Failed to update motor ${motorId} data`, error);\n    }\n  }, [motors, dispatch]);\n\n  // Performance metrics update (throttled)\n  const updatePerformanceMetrics = useCallback(throttle(() => {\n    const now_time = now();\n    const timeDiff = now_time - performanceRef.current.lastPerformanceUpdate;\n    if (timeDiff > 0) {\n      const commandsPerSecond = performanceRef.current.commandsSent / timeDiff * 1000;\n      const successRate = performanceRef.current.commandsSuccessful / performanceRef.current.commandsSent;\n\n      // Reset counters\n      performanceRef.current.commandsSent = 0;\n      performanceRef.current.commandsSuccessful = 0;\n      performanceRef.current.lastPerformanceUpdate = now_time;\n\n      // Dispatch performance update if needed\n      debugLog('Performance metrics:', {\n        commandsPerSecond,\n        successRate\n      });\n    }\n  }, 5000),\n  // Update every 5 seconds\n  []);\n\n  // Connect to robot\n  const connect = useCallback(async () => {\n    try {\n      dispatch(addLogEntry({\n        message: 'Attempting to connect to robot...',\n        type: 'info',\n        timestamp: now()\n      }));\n      const success = await connectSerial();\n      if (success) {\n        dispatch(addLogEntry({\n          message: 'Successfully connected to robot',\n          type: 'info',\n          timestamp: now()\n        }));\n        toast.success('Robot connected!');\n      }\n      return success;\n    } catch (error) {\n      errorLog('Robot connection failed', error);\n      dispatch(addLogEntry({\n        message: `Connection failed: ${error.message}`,\n        type: 'error',\n        timestamp: now()\n      }));\n      toast.error('Connection failed');\n      return false;\n    }\n  }, [connectSerial, dispatch]);\n\n  // Disconnect from robot\n  const disconnect = useCallback(async () => {\n    try {\n      // Stop any running challenge\n      if (challengeStatus.running) {\n        await stopChallenge();\n      }\n      await disconnectSerial();\n      dispatch(addLogEntry({\n        message: 'Disconnected from robot',\n        type: 'info',\n        timestamp: now()\n      }));\n      toast.success('Robot disconnected');\n    } catch (error) {\n      errorLog('Disconnect error', error);\n      toast.error('Disconnect error');\n    }\n  }, [disconnectSerial, challengeStatus.running, dispatch]);\n\n  // Motor scanning\n  const scanMotors = useCallback(async () => {\n    if (!isConnected) {\n      toast.error('Robot not connected');\n      return;\n    }\n    dispatch(addLogEntry({\n      message: 'Scanning for motors (ID 1-10)...',\n      type: 'info',\n      timestamp: now()\n    }));\n    const detectedMotors = [];\n    try {\n      for (let id = 1; id <= 10; id++) {\n        try {\n          const isOnline = await serialPingMotor(id);\n          if (isOnline) {\n            const motor = {\n              id,\n              model: ROBOT_SPECS.MODEL,\n              status: 'online',\n              online: true,\n              torqueEnabled: false,\n              position: ROBOT_SPECS.MAX_POSITION / 2,\n              velocity: 0,\n              goalPosition: ROBOT_SPECS.MAX_POSITION / 2,\n              goalVelocity: 0,\n              temperature: 25,\n              voltage: 7.0,\n              current: 0.0,\n              load: 0,\n              lastUpdate: now(),\n              operatingMode: 3 // Position mode\n            };\n            detectedMotors.push(motor);\n            dispatch(addLogEntry({\n              message: `✅ Motor ${id} detected`,\n              type: 'info',\n              timestamp: now()\n            }));\n          }\n\n          // Small delay between pings\n          await new Promise(resolve => setTimeout(resolve, 200));\n        } catch (error) {\n          debugLog(`Motor ${id} scan failed:`, error);\n        }\n      }\n      dispatch(setMotors(detectedMotors));\n      const message = `Scan complete. Found ${detectedMotors.length} motors.`;\n      dispatch(addLogEntry({\n        message,\n        type: detectedMotors.length > 0 ? 'info' : 'warning',\n        timestamp: now()\n      }));\n      if (detectedMotors.length === 0) {\n        toast.error('No motors detected. Check connections and power.');\n      } else {\n        toast.success(`Found ${detectedMotors.length} motors`);\n      }\n    } catch (error) {\n      errorLog('Motor scan failed', error);\n      dispatch(addLogEntry({\n        message: `Motor scan failed: ${error.message}`,\n        type: 'error',\n        timestamp: now()\n      }));\n      toast.error('Motor scan failed');\n    }\n  }, [isConnected, serialPingMotor, dispatch]);\n\n  // Motor control functions\n  const enableTorque = useCallback(async motorId => {\n    try {\n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.ENABLE_TORQUE}:${motorId}`);\n      performanceRef.current.commandsSuccessful++;\n      dispatch(updateMotor({\n        motorId,\n        updates: {\n          torqueEnabled: true\n        }\n      }));\n      dispatch(addLogEntry({\n        message: `Torque enabled for motor ${motorId}`,\n        type: 'info',\n        timestamp: now()\n      }));\n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to enable torque for motor ${motorId}`, error);\n      toast.error(`Failed to enable motor ${motorId}`);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n  const disableTorque = useCallback(async motorId => {\n    try {\n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.DISABLE_TORQUE}:${motorId}`);\n      performanceRef.current.commandsSuccessful++;\n      dispatch(updateMotor({\n        motorId,\n        updates: {\n          torqueEnabled: false\n        }\n      }));\n      dispatch(addLogEntry({\n        message: `Torque disabled for motor ${motorId}`,\n        type: 'info',\n        timestamp: now()\n      }));\n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to disable torque for motor ${motorId}`, error);\n      toast.error(`Failed to disable motor ${motorId}`);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n  const setMotorPosition = useCallback(async (motorId, degrees) => {\n    try {\n      const positionRaw = degreesToPositionRaw(degrees);\n      const clampedPosition = clamp(positionRaw, 0, ROBOT_SPECS.MAX_POSITION);\n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.SET_POSITION}:${motorId}:${clampedPosition}`);\n      performanceRef.current.commandsSuccessful++;\n      dispatch(updateMotor({\n        motorId,\n        updates: {\n          goalPosition: rawToDegrees(clampedPosition),\n          position: rawToDegrees(clampedPosition) // Immediate update for UI responsiveness\n        }\n      }));\n      dispatch(addLogEntry({\n        message: `Motor ${motorId} position set to ${degrees.toFixed(1)}° (raw: ${clampedPosition})`,\n        type: 'info',\n        timestamp: now()\n      }));\n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to set position for motor ${motorId}`, error);\n      toast.error(`Failed to move motor ${motorId}`);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n  const setMotorVelocity = useCallback(async (motorId, degreesPerSec) => {\n    try {\n      const velocityRaw = degreesToVelocityRaw(degreesPerSec);\n      const clampedVelocity = clamp(velocityRaw, ROBOT_SPECS.MIN_VELOCITY, ROBOT_SPECS.MAX_VELOCITY);\n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.SET_VELOCITY}:${motorId}:${clampedVelocity}`);\n      performanceRef.current.commandsSuccessful++;\n      dispatch(updateMotor({\n        motorId,\n        updates: {\n          goalVelocity: degreesPerSec,\n          velocity: degreesPerSec // Immediate update\n        }\n      }));\n      dispatch(addLogEntry({\n        message: `Motor ${motorId} velocity set to ${degreesPerSec.toFixed(1)}°/s (raw: ${clampedVelocity})`,\n        type: 'info',\n        timestamp: now()\n      }));\n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to set velocity for motor ${motorId}`, error);\n      toast.error(`Failed to set velocity for motor ${motorId}`);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n  const homeMotor = useCallback(async motorId => {\n    const homePosition = 180; // Center position in degrees\n    return await setMotorPosition(motorId, homePosition);\n  }, [setMotorPosition]);\n  const stopMotor = useCallback(async motorId => {\n    return await setMotorVelocity(motorId, 0);\n  }, [setMotorVelocity]);\n  const getMotorPosition = useCallback(async motorId => {\n    try {\n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`);\n      performanceRef.current.commandsSuccessful++;\n      dispatch(addLogEntry({\n        message: `Reading position for motor ${motorId}`,\n        type: 'info',\n        timestamp: now()\n      }));\n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to get position for motor ${motorId}`, error);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n\n  // Global control functions\n  const enableAllTorque = useCallback(async () => {\n    const onlineMotors = motors.filter(m => m.online);\n    let successCount = 0;\n    for (const motor of onlineMotors) {\n      const success = await enableTorque(motor.id);\n      if (success) successCount++;\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    if (successCount === onlineMotors.length) {\n      toast.success('All motors enabled');\n    } else {\n      toast.warning(`${successCount}/${onlineMotors.length} motors enabled`);\n    }\n  }, [motors, enableTorque]);\n  const disableAllTorque = useCallback(async () => {\n    const onlineMotors = motors.filter(m => m.online);\n    let successCount = 0;\n    for (const motor of onlineMotors) {\n      const success = await disableTorque(motor.id);\n      if (success) successCount++;\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    if (successCount === onlineMotors.length) {\n      toast.success('All motors disabled');\n    } else {\n      toast.warning(`${successCount}/${onlineMotors.length} motors disabled`);\n    }\n  }, [motors, disableTorque]);\n  const homeAllMotors = useCallback(async () => {\n    const onlineMotors = motors.filter(m => m.online);\n    dispatch(addLogEntry({\n      message: 'Moving all motors to home position...',\n      type: 'info',\n      timestamp: now()\n    }));\n    let successCount = 0;\n    for (const motor of onlineMotors) {\n      const success = await homeMotor(motor.id);\n      if (success) successCount++;\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    if (successCount === onlineMotors.length) {\n      toast.success('All motors homed');\n    } else {\n      toast.warning(`${successCount}/${onlineMotors.length} motors homed`);\n    }\n  }, [motors, homeMotor, dispatch]);\n  const emergencyStop = useCallback(async () => {\n    try {\n      dispatch(addLogEntry({\n        message: '🛑 EMERGENCY STOP ACTIVATED',\n        type: 'error',\n        timestamp: now()\n      }));\n      dispatch(setEmergencyStop(true));\n\n      // Stop serial communication emergency stop\n      await serialEmergencyStop();\n\n      // Stop any running challenge\n      if (challengeStatus.running) {\n        stopChallenge();\n      }\n      toast.error('Emergency stop activated!');\n    } catch (error) {\n      errorLog('Emergency stop failed', error);\n      toast.error('Emergency stop failed!');\n    }\n  }, [serialEmergencyStop, challengeStatus.running, dispatch]);\n\n  // Challenge execution\n  const startChallengeExecution = useCallback(async challengeParams => {\n    if (!isConnected || challengeStatus.running) {\n      toast.error('Cannot start challenge: Robot not ready');\n      return false;\n    }\n    const requiredMotors = challengeParams.requiredMotors || [1, 2];\n    const availableMotors = motors.filter(m => requiredMotors.includes(m.id) && m.online);\n    if (availableMotors.length < requiredMotors.length) {\n      toast.error(`Challenge requires motors ${requiredMotors.join(', ')} to be connected`);\n      return false;\n    }\n    try {\n      dispatch(startChallenge(challengeParams));\n      dispatch(addLogEntry({\n        message: '🚀 Challenge started successfully',\n        type: 'info',\n        timestamp: now()\n      }));\n      toast.success('Challenge started!');\n      return true;\n    } catch (error) {\n      errorLog('Challenge start failed', error);\n      toast.error('Failed to start challenge');\n      return false;\n    }\n  }, [isConnected, challengeStatus.running, motors, dispatch]);\n  const stopChallenge = useCallback(async () => {\n    if (!challengeStatus.running) return;\n    try {\n      // Stop challenge interval if running\n      if (challengeInterval) {\n        clearInterval(challengeInterval);\n        setChallengeInterval(null);\n      }\n\n      // Stop all motors\n      const onlineMotors = motors.filter(m => m.online);\n      for (const motor of onlineMotors) {\n        await stopMotor(motor.id);\n      }\n      dispatch(stopChallengeAction());\n      dispatch(addLogEntry({\n        message: '🏁 Challenge stopped',\n        type: 'info',\n        timestamp: now()\n      }));\n      toast.success('Challenge stopped');\n    } catch (error) {\n      errorLog('Challenge stop failed', error);\n      toast.error('Error stopping challenge');\n    }\n  }, [challengeStatus.running, challengeInterval, motors, stopMotor, dispatch]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopUptimeCounter();\n      stopPeriodicMonitoring();\n      if (challengeInterval) {\n        clearInterval(challengeInterval);\n      }\n    };\n  }, [stopUptimeCounter, stopPeriodicMonitoring, challengeInterval]);\n  return {\n    // Connection state\n    isSupported,\n    isConnected,\n    connectionStatus: robotState.connectionStatus,\n    // Motor state\n    motors,\n    connectedMotorCount: robotState.connectedMotorCount,\n    // Challenge state\n    challengeRunning: challengeStatus.running,\n    challengeProgress: challengeStatus.progress,\n    // Communication state\n    logs: robotState.logs,\n    commandCount: robotState.commandCount,\n    uptime: robotState.uptime,\n    // Control functions\n    connect,\n    disconnect,\n    scanMotors,\n    // Motor control\n    enableTorque,\n    disableTorque,\n    setMotorPosition,\n    setMotorVelocity,\n    homeMotor,\n    stopMotor,\n    getMotorPosition,\n    // Global control\n    enableAllTorque,\n    disableAllTorque,\n    homeAllMotors,\n    emergencyStop,\n    // Challenge control\n    startChallenge: startChallengeExecution,\n    stopChallenge\n  };\n};\n_s(useRobotController, \"ykY0xYOcG6QtlHktvz29DzXASPM=\", false, function () {\n  return [useDispatch, useSelector, useSelector, useSelector, useSelector, useWebSerial];\n});","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","useDispatch","useSelector","useWebSerial","updateConnectionStatus","setMotors","updateMotor","addMotor","removeMotor","updateChartData","addLogEntry","incrementCommandCount","updateUptime","startChallenge","stopChallenge","stopChallengeAction","updateChallengeProgress","updateHardwareStats","setEmergencyStop","selectRobot","selectIsConnected","selectMotors","selectChallengeStatus","rawToDegrees","degreesToPositionRaw","degreesToVelocityRaw","COMMANDS","ROBOT_SPECS","PERFORMANCE","now","clamp","throttle","debugLog","errorLog","toast","useRobotController","_s","dispatch","robotState","isConnected","motors","challengeStatus","isSupported","connect","connectSerial","disconnect","disconnectSerial","sendCommand","pingMotor","serialPingMotor","emergencyStop","serialEmergencyStop","connectionStartTime","setConnectionStartTime","challengeInterval","setChallengeInterval","uptimeInterval","setUptimeInterval","monitoringInterval","setMonitoringInterval","performanceRef","commandsSent","commandsSuccessful","lastPerformanceUpdate","startUptimeCounter","startPeriodicMonitoring","setTimeout","scanMotors","stopUptimeCounter","stopPeriodicMonitoring","interval","setInterval","uptime","clearInterval","length","motor","online","updateMotorData","id","updatePerformanceMetrics","error","settings","updateRate","motorId","find","m","currentTime","timeDiff","lastUpdate","simulatedData","position","Math","random","velocity","temperature","current","updates","time","now_time","commandsPerSecond","successRate","message","type","timestamp","success","running","detectedMotors","isOnline","model","MODEL","status","torqueEnabled","MAX_POSITION","goalPosition","goalVelocity","voltage","load","operatingMode","push","Promise","resolve","enableTorque","ENABLE_TORQUE","disableTorque","DISABLE_TORQUE","setMotorPosition","degrees","positionRaw","clampedPosition","SET_POSITION","toFixed","setMotorVelocity","degreesPerSec","velocityRaw","clampedVelocity","MIN_VELOCITY","MAX_VELOCITY","SET_VELOCITY","homeMotor","homePosition","stopMotor","getMotorPosition","GET_POSITION","enableAllTorque","onlineMotors","filter","successCount","warning","disableAllTorque","homeAllMotors","startChallengeExecution","challengeParams","requiredMotors","availableMotors","includes","join","connectionStatus","connectedMotorCount","challengeRunning","challengeProgress","progress","logs","commandCount"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/hooks/useRobotController.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useWebSerial } from './useWebSerial';\nimport {\n  updateConnectionStatus,\n  setMotors,\n  updateMotor,\n  addMotor,\n  removeMotor,\n  updateChartData,\n  addLogEntry,\n  incrementCommandCount,\n  updateUptime,\n  startChallenge,\n  stopChallenge as stopChallengeAction,\n  updateChallengeProgress,\n  updateHardwareStats,\n  setEmergencyStop,\n  selectRobot,\n  selectIsConnected,\n  selectMotors,\n  selectChallengeStatus,\n} from '../store/robotSlice';\nimport { \n  rawToDegrees, \n  degreesToPositionRaw, \n  degreesToVelocityRaw \n} from '../utils/robotUtils';\nimport { COMMANDS, ROBOT_SPECS, PERFORMANCE } from '../utils/constants';\nimport { now, clamp, throttle, debugLog, errorLog } from '../utils/helpers';\nimport toast from 'react-hot-toast';\n\nexport const useRobotController = () => {\n  const dispatch = useDispatch();\n  const robotState = useSelector(selectRobot);\n  const isConnected = useSelector(selectIsConnected);\n  const motors = useSelector(selectMotors);\n  const challengeStatus = useSelector(selectChallengeStatus);\n  \n  const { \n    isSupported, \n    connect: connectSerial, \n    disconnect: disconnectSerial, \n    sendCommand, \n    pingMotor: serialPingMotor,\n    emergencyStop: serialEmergencyStop \n  } = useWebSerial();\n  \n  const [connectionStartTime, setConnectionStartTime] = useState(null);\n  const [challengeInterval, setChallengeInterval] = useState(null);\n  const [uptimeInterval, setUptimeInterval] = useState(null);\n  const [monitoringInterval, setMonitoringInterval] = useState(null);\n  \n  const performanceRef = useRef({\n    commandsSent: 0,\n    commandsSuccessful: 0,\n    lastPerformanceUpdate: now(),\n  });\n\n  // Connection management\n  useEffect(() => {\n    if (isConnected && !connectionStartTime) {\n      setConnectionStartTime(now());\n      startUptimeCounter();\n      startPeriodicMonitoring();\n      \n      // Auto-scan for motors after connection\n      setTimeout(() => {\n        scanMotors();\n      }, 2000);\n      \n    } else if (!isConnected && connectionStartTime) {\n      setConnectionStartTime(null);\n      stopUptimeCounter();\n      stopPeriodicMonitoring();\n      stopChallenge();\n    }\n  }, [isConnected, connectionStartTime]);\n\n  // Uptime counter\n  const startUptimeCounter = useCallback(() => {\n    const interval = setInterval(() => {\n      if (connectionStartTime) {\n        const uptime = now() - connectionStartTime;\n        dispatch(updateUptime(uptime));\n      }\n    }, 1000);\n    setUptimeInterval(interval);\n  }, [connectionStartTime, dispatch]);\n\n  const stopUptimeCounter = useCallback(() => {\n    if (uptimeInterval) {\n      clearInterval(uptimeInterval);\n      setUptimeInterval(null);\n    }\n  }, [uptimeInterval]);\n\n  // Periodic monitoring\n  const startPeriodicMonitoring = useCallback(() => {\n    const interval = setInterval(async () => {\n      if (!isConnected || motors.length === 0) return;\n\n      try {\n        // Monitor each connected motor\n        for (const motor of motors) {\n          if (motor.online) {\n            // Get current position and temperature\n            await updateMotorData(motor.id);\n          }\n        }\n        \n        // Update performance metrics\n        updatePerformanceMetrics();\n        \n      } catch (error) {\n        debugLog('Monitoring error:', error);\n      }\n    }, robotState.settings.updateRate || 1000);\n    \n    setMonitoringInterval(interval);\n  }, [isConnected, motors, robotState.settings.updateRate]);\n\n  const stopPeriodicMonitoring = useCallback(() => {\n    if (monitoringInterval) {\n      clearInterval(monitoringInterval);\n      setMonitoringInterval(null);\n    }\n  }, [monitoringInterval]);\n\n  // Update motor data\n  const updateMotorData = useCallback(async (motorId) => {\n    try {\n      // This would be implemented with actual sensor reading\n      // For now, we'll simulate or use cached values\n      \n      const motor = motors.find(m => m.id === motorId);\n      if (!motor) return;\n\n      // Simulate data updates (in real implementation, this would read from hardware)\n      const currentTime = now();\n      const timeDiff = currentTime - motor.lastUpdate;\n      \n      if (timeDiff > 100) { // Update every 100ms\n        const simulatedData = {\n          position: motor.position + (Math.random() - 0.5) * 2, // Small random variation\n          velocity: motor.velocity + (Math.random() - 0.5) * 5,\n          temperature: 25 + Math.random() * 10,\n          current: Math.random() * 0.5,\n        };\n        \n        dispatch(updateMotor({\n          motorId,\n          updates: {\n            ...simulatedData,\n            lastUpdate: currentTime,\n          },\n        }));\n        \n        // Update chart data\n        dispatch(updateChartData({\n          time: currentTime,\n          motorId,\n          position: simulatedData.position,\n          velocity: simulatedData.velocity,\n          temperature: simulatedData.temperature,\n          current: simulatedData.current,\n        }));\n      }\n      \n    } catch (error) {\n      errorLog(`Failed to update motor ${motorId} data`, error);\n    }\n  }, [motors, dispatch]);\n\n  // Performance metrics update (throttled)\n  const updatePerformanceMetrics = useCallback(\n    throttle(() => {\n      const now_time = now();\n      const timeDiff = now_time - performanceRef.current.lastPerformanceUpdate;\n      \n      if (timeDiff > 0) {\n        const commandsPerSecond = (performanceRef.current.commandsSent / timeDiff) * 1000;\n        const successRate = performanceRef.current.commandsSuccessful / performanceRef.current.commandsSent;\n        \n        // Reset counters\n        performanceRef.current.commandsSent = 0;\n        performanceRef.current.commandsSuccessful = 0;\n        performanceRef.current.lastPerformanceUpdate = now_time;\n        \n        // Dispatch performance update if needed\n        debugLog('Performance metrics:', { commandsPerSecond, successRate });\n      }\n    }, 5000), // Update every 5 seconds\n    []\n  );\n\n  // Connect to robot\n  const connect = useCallback(async () => {\n    try {\n      dispatch(addLogEntry({\n        message: 'Attempting to connect to robot...',\n        type: 'info',\n        timestamp: now(),\n      }));\n      \n      const success = await connectSerial();\n      \n      if (success) {\n        dispatch(addLogEntry({\n          message: 'Successfully connected to robot',\n          type: 'info',\n          timestamp: now(),\n        }));\n        toast.success('Robot connected!');\n      }\n      \n      return success;\n    } catch (error) {\n      errorLog('Robot connection failed', error);\n      dispatch(addLogEntry({\n        message: `Connection failed: ${error.message}`,\n        type: 'error',\n        timestamp: now(),\n      }));\n      toast.error('Connection failed');\n      return false;\n    }\n  }, [connectSerial, dispatch]);\n\n  // Disconnect from robot\n  const disconnect = useCallback(async () => {\n    try {\n      // Stop any running challenge\n      if (challengeStatus.running) {\n        await stopChallenge();\n      }\n      \n      await disconnectSerial();\n      \n      dispatch(addLogEntry({\n        message: 'Disconnected from robot',\n        type: 'info',\n        timestamp: now(),\n      }));\n      \n      toast.success('Robot disconnected');\n    } catch (error) {\n      errorLog('Disconnect error', error);\n      toast.error('Disconnect error');\n    }\n  }, [disconnectSerial, challengeStatus.running, dispatch]);\n\n  // Motor scanning\n  const scanMotors = useCallback(async () => {\n    if (!isConnected) {\n      toast.error('Robot not connected');\n      return;\n    }\n\n    dispatch(addLogEntry({\n      message: 'Scanning for motors (ID 1-10)...',\n      type: 'info',\n      timestamp: now(),\n    }));\n\n    const detectedMotors = [];\n\n    try {\n      for (let id = 1; id <= 10; id++) {\n        try {\n          const isOnline = await serialPingMotor(id);\n          \n          if (isOnline) {\n            const motor = {\n              id,\n              model: ROBOT_SPECS.MODEL,\n              status: 'online',\n              online: true,\n              torqueEnabled: false,\n              position: ROBOT_SPECS.MAX_POSITION / 2,\n              velocity: 0,\n              goalPosition: ROBOT_SPECS.MAX_POSITION / 2,\n              goalVelocity: 0,\n              temperature: 25,\n              voltage: 7.0,\n              current: 0.0,\n              load: 0,\n              lastUpdate: now(),\n              operatingMode: 3, // Position mode\n            };\n            \n            detectedMotors.push(motor);\n            \n            dispatch(addLogEntry({\n              message: `✅ Motor ${id} detected`,\n              type: 'info',\n              timestamp: now(),\n            }));\n          }\n          \n          // Small delay between pings\n          await new Promise(resolve => setTimeout(resolve, 200));\n          \n        } catch (error) {\n          debugLog(`Motor ${id} scan failed:`, error);\n        }\n      }\n\n      dispatch(setMotors(detectedMotors));\n      \n      const message = `Scan complete. Found ${detectedMotors.length} motors.`;\n      dispatch(addLogEntry({\n        message,\n        type: detectedMotors.length > 0 ? 'info' : 'warning',\n        timestamp: now(),\n      }));\n      \n      if (detectedMotors.length === 0) {\n        toast.error('No motors detected. Check connections and power.');\n      } else {\n        toast.success(`Found ${detectedMotors.length} motors`);\n      }\n      \n    } catch (error) {\n      errorLog('Motor scan failed', error);\n      dispatch(addLogEntry({\n        message: `Motor scan failed: ${error.message}`,\n        type: 'error',\n        timestamp: now(),\n      }));\n      toast.error('Motor scan failed');\n    }\n  }, [isConnected, serialPingMotor, dispatch]);\n\n  // Motor control functions\n  const enableTorque = useCallback(async (motorId) => {\n    try {\n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.ENABLE_TORQUE}:${motorId}`);\n      performanceRef.current.commandsSuccessful++;\n      \n      dispatch(updateMotor({\n        motorId,\n        updates: { torqueEnabled: true }\n      }));\n      \n      dispatch(addLogEntry({\n        message: `Torque enabled for motor ${motorId}`,\n        type: 'info',\n        timestamp: now(),\n      }));\n      \n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to enable torque for motor ${motorId}`, error);\n      toast.error(`Failed to enable motor ${motorId}`);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n\n  const disableTorque = useCallback(async (motorId) => {\n    try {\n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.DISABLE_TORQUE}:${motorId}`);\n      performanceRef.current.commandsSuccessful++;\n      \n      dispatch(updateMotor({\n        motorId,\n        updates: { torqueEnabled: false }\n      }));\n      \n      dispatch(addLogEntry({\n        message: `Torque disabled for motor ${motorId}`,\n        type: 'info',\n        timestamp: now(),\n      }));\n      \n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to disable torque for motor ${motorId}`, error);\n      toast.error(`Failed to disable motor ${motorId}`);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n\n  const setMotorPosition = useCallback(async (motorId, degrees) => {\n    try {\n      const positionRaw = degreesToPositionRaw(degrees);\n      const clampedPosition = clamp(positionRaw, 0, ROBOT_SPECS.MAX_POSITION);\n      \n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.SET_POSITION}:${motorId}:${clampedPosition}`);\n      performanceRef.current.commandsSuccessful++;\n      \n      dispatch(updateMotor({\n        motorId,\n        updates: { \n          goalPosition: rawToDegrees(clampedPosition),\n          position: rawToDegrees(clampedPosition) // Immediate update for UI responsiveness\n        }\n      }));\n      \n      dispatch(addLogEntry({\n        message: `Motor ${motorId} position set to ${degrees.toFixed(1)}° (raw: ${clampedPosition})`,\n        type: 'info',\n        timestamp: now(),\n      }));\n      \n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to set position for motor ${motorId}`, error);\n      toast.error(`Failed to move motor ${motorId}`);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n\n  const setMotorVelocity = useCallback(async (motorId, degreesPerSec) => {\n    try {\n      const velocityRaw = degreesToVelocityRaw(degreesPerSec);\n      const clampedVelocity = clamp(velocityRaw, ROBOT_SPECS.MIN_VELOCITY, ROBOT_SPECS.MAX_VELOCITY);\n      \n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.SET_VELOCITY}:${motorId}:${clampedVelocity}`);\n      performanceRef.current.commandsSuccessful++;\n      \n      dispatch(updateMotor({\n        motorId,\n        updates: { \n          goalVelocity: degreesPerSec,\n          velocity: degreesPerSec // Immediate update\n        }\n      }));\n      \n      dispatch(addLogEntry({\n        message: `Motor ${motorId} velocity set to ${degreesPerSec.toFixed(1)}°/s (raw: ${clampedVelocity})`,\n        type: 'info',\n        timestamp: now(),\n      }));\n      \n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to set velocity for motor ${motorId}`, error);\n      toast.error(`Failed to set velocity for motor ${motorId}`);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n\n  const homeMotor = useCallback(async (motorId) => {\n    const homePosition = 180; // Center position in degrees\n    return await setMotorPosition(motorId, homePosition);\n  }, [setMotorPosition]);\n\n  const stopMotor = useCallback(async (motorId) => {\n    return await setMotorVelocity(motorId, 0);\n  }, [setMotorVelocity]);\n\n  const getMotorPosition = useCallback(async (motorId) => {\n    try {\n      performanceRef.current.commandsSent++;\n      await sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`);\n      performanceRef.current.commandsSuccessful++;\n      \n      dispatch(addLogEntry({\n        message: `Reading position for motor ${motorId}`,\n        type: 'info',\n        timestamp: now(),\n      }));\n      \n      dispatch(incrementCommandCount());\n      return true;\n    } catch (error) {\n      errorLog(`Failed to get position for motor ${motorId}`, error);\n      return false;\n    }\n  }, [sendCommand, dispatch]);\n\n  // Global control functions\n  const enableAllTorque = useCallback(async () => {\n    const onlineMotors = motors.filter(m => m.online);\n    let successCount = 0;\n    \n    for (const motor of onlineMotors) {\n      const success = await enableTorque(motor.id);\n      if (success) successCount++;\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    \n    if (successCount === onlineMotors.length) {\n      toast.success('All motors enabled');\n    } else {\n      toast.warning(`${successCount}/${onlineMotors.length} motors enabled`);\n    }\n  }, [motors, enableTorque]);\n\n  const disableAllTorque = useCallback(async () => {\n    const onlineMotors = motors.filter(m => m.online);\n    let successCount = 0;\n    \n    for (const motor of onlineMotors) {\n      const success = await disableTorque(motor.id);\n      if (success) successCount++;\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    \n    if (successCount === onlineMotors.length) {\n      toast.success('All motors disabled');\n    } else {\n      toast.warning(`${successCount}/${onlineMotors.length} motors disabled`);\n    }\n  }, [motors, disableTorque]);\n\n  const homeAllMotors = useCallback(async () => {\n    const onlineMotors = motors.filter(m => m.online);\n    \n    dispatch(addLogEntry({\n      message: 'Moving all motors to home position...',\n      type: 'info',\n      timestamp: now(),\n    }));\n    \n    let successCount = 0;\n    \n    for (const motor of onlineMotors) {\n      const success = await homeMotor(motor.id);\n      if (success) successCount++;\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    \n    if (successCount === onlineMotors.length) {\n      toast.success('All motors homed');\n    } else {\n      toast.warning(`${successCount}/${onlineMotors.length} motors homed`);\n    }\n  }, [motors, homeMotor, dispatch]);\n\n  const emergencyStop = useCallback(async () => {\n    try {\n      dispatch(addLogEntry({\n        message: '🛑 EMERGENCY STOP ACTIVATED',\n        type: 'error',\n        timestamp: now(),\n      }));\n      \n      dispatch(setEmergencyStop(true));\n      \n      // Stop serial communication emergency stop\n      await serialEmergencyStop();\n      \n      // Stop any running challenge\n      if (challengeStatus.running) {\n        stopChallenge();\n      }\n      \n      toast.error('Emergency stop activated!');\n      \n    } catch (error) {\n      errorLog('Emergency stop failed', error);\n      toast.error('Emergency stop failed!');\n    }\n  }, [serialEmergencyStop, challengeStatus.running, dispatch]);\n\n  // Challenge execution\n  const startChallengeExecution = useCallback(async (challengeParams) => {\n    if (!isConnected || challengeStatus.running) {\n      toast.error('Cannot start challenge: Robot not ready');\n      return false;\n    }\n\n    const requiredMotors = challengeParams.requiredMotors || [1, 2];\n    const availableMotors = motors.filter(m => \n      requiredMotors.includes(m.id) && m.online\n    );\n\n    if (availableMotors.length < requiredMotors.length) {\n      toast.error(`Challenge requires motors ${requiredMotors.join(', ')} to be connected`);\n      return false;\n    }\n\n    try {\n      dispatch(startChallenge(challengeParams));\n      \n      dispatch(addLogEntry({\n        message: '🚀 Challenge started successfully',\n        type: 'info',\n        timestamp: now(),\n      }));\n      \n      toast.success('Challenge started!');\n      return true;\n      \n    } catch (error) {\n      errorLog('Challenge start failed', error);\n      toast.error('Failed to start challenge');\n      return false;\n    }\n  }, [isConnected, challengeStatus.running, motors, dispatch]);\n\n  const stopChallenge = useCallback(async () => {\n    if (!challengeStatus.running) return;\n\n    try {\n      // Stop challenge interval if running\n      if (challengeInterval) {\n        clearInterval(challengeInterval);\n        setChallengeInterval(null);\n      }\n\n      // Stop all motors\n      const onlineMotors = motors.filter(m => m.online);\n      for (const motor of onlineMotors) {\n        await stopMotor(motor.id);\n      }\n      \n      dispatch(stopChallengeAction());\n      \n      dispatch(addLogEntry({\n        message: '🏁 Challenge stopped',\n        type: 'info',\n        timestamp: now(),\n      }));\n      \n      toast.success('Challenge stopped');\n      \n    } catch (error) {\n      errorLog('Challenge stop failed', error);\n      toast.error('Error stopping challenge');\n    }\n  }, [challengeStatus.running, challengeInterval, motors, stopMotor, dispatch]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopUptimeCounter();\n      stopPeriodicMonitoring();\n      if (challengeInterval) {\n        clearInterval(challengeInterval);\n      }\n    };\n  }, [stopUptimeCounter, stopPeriodicMonitoring, challengeInterval]);\n\n  return {\n    // Connection state\n    isSupported,\n    isConnected,\n    connectionStatus: robotState.connectionStatus,\n    \n    // Motor state\n    motors,\n    connectedMotorCount: robotState.connectedMotorCount,\n    \n    // Challenge state\n    challengeRunning: challengeStatus.running,\n    challengeProgress: challengeStatus.progress,\n    \n    // Communication state\n    logs: robotState.logs,\n    commandCount: robotState.commandCount,\n    uptime: robotState.uptime,\n    \n    // Control functions\n    connect,\n    disconnect,\n    scanMotors,\n    \n    // Motor control\n    enableTorque,\n    disableTorque,\n    setMotorPosition,\n    setMotorVelocity,\n    homeMotor,\n    stopMotor,\n    getMotorPosition,\n    \n    // Global control\n    enableAllTorque,\n    disableAllTorque,\n    homeAllMotors,\n    emergencyStop,\n    \n    // Challenge control\n    startChallenge: startChallengeExecution,\n    stopChallenge,\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}