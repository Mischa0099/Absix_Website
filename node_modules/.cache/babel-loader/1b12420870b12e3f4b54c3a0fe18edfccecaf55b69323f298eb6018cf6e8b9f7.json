{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { updateRobotState, setConnectionStatus } from '../store/robotSlice';\nimport { useWebSerial } from './useWebSerial';\n\n// Robot controller hook that uses WebSerial for communication\nexport const useRobotController = () => {\n  _s();\n  const dispatch = useDispatch();\n  const {\n    connected,\n    connectionStatus\n  } = useSelector(state => state.robot);\n  const [currentAngles, setCurrentAngles] = useState([0, 0, 0]);\n  const [isSimulationMode, setIsSimulationMode] = useState(true);\n\n  // Use the full WebSerial implementation\n  const {\n    isSupported,\n    isConnected: serialConnected,\n    connect: connectSerial,\n    disconnect: disconnectSerial,\n    sendCommand,\n    pingMotor,\n    getMotorPosition,\n    emergencyStop: serialEmergencyStop\n  } = useWebSerial();\n\n  // Connection status - use serial connection if available, otherwise simulation\n  const isConnected = serialConnected || false;\n\n  // Initialize connection attempt\n  useEffect(() => {\n    const initializeConnection = async () => {\n      if (isSupported) {\n        try {\n          dispatch(setConnectionStatus('connecting'));\n          console.log('Attempting to connect to robot hardware...');\n\n          // Try to connect (this will show browser serial port dialog)\n          // await connectSerial();\n\n          // For now, default to simulation mode\n          dispatch(setConnectionStatus('disconnected'));\n          setIsSimulationMode(true);\n          console.log('Robot controller initialized in simulation mode');\n        } catch (error) {\n          console.error('Failed to connect to robot:', error);\n          dispatch(setConnectionStatus('error'));\n          setIsSimulationMode(true);\n        }\n      } else {\n        console.log('WebSerial not supported, using simulation mode');\n        dispatch(setConnectionStatus('disconnected'));\n        setIsSimulationMode(true);\n      }\n    };\n    initializeConnection();\n  }, [dispatch, isSupported, connectSerial]);\n\n  // Manual connect function for user-initiated connection\n  const connectToRobot = useCallback(async () => {\n    if (!isSupported) {\n      throw new Error('WebSerial not supported in this browser');\n    }\n    try {\n      await connectSerial();\n      setIsSimulationMode(false);\n      return true;\n    } catch (error) {\n      console.error('Failed to connect to robot:', error);\n      setIsSimulationMode(true);\n      throw error;\n    }\n  }, [isSupported, connectSerial]);\n\n  // Disconnect function\n  const disconnectFromRobot = useCallback(async () => {\n    try {\n      await disconnectSerial();\n      setIsSimulationMode(true);\n    } catch (error) {\n      console.error('Error disconnecting:', error);\n      throw error;\n    }\n  }, [disconnectSerial]);\n\n  // Robot control functions\n  const disableTorque = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // Send disable torque command for all motors\n        await sendCommand('DISABLE:1');\n        await sendCommand('DISABLE:2');\n        await sendCommand('DISABLE:3');\n        console.log('Torque disabled for all motors');\n      } else {\n        console.log('Disabling torque (simulation)');\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error disabling torque:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n  const enableTorque = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // Send enable torque command for all motors\n        await sendCommand('ENABLE:1');\n        await sendCommand('ENABLE:2');\n        await sendCommand('ENABLE:3');\n        console.log('Torque enabled for all motors');\n      } else {\n        console.log('Enabling torque (simulation)');\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error enabling torque:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n  const getCurrentJointAngles = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // Get positions from all motors\n        const positions = await Promise.all([getMotorPosition(1), getMotorPosition(2), getMotorPosition(3)]);\n\n        // Convert raw positions to angles in radians\n        const angles = positions.map(pos => {\n          if (pos === null) return 0;\n          // Convert raw position (0-4095) to degrees, then to radians\n          const degrees = (pos - 2048) / 2048 * 180; // Assuming center is 2048\n          return degrees * Math.PI / 180;\n        });\n        setCurrentAngles(angles.map(rad => rad * 180 / Math.PI)); // Store in degrees\n        return angles;\n      } else {\n        // Simulation mode - return mock angles with some variation\n        const angles = currentAngles.map(angle => angle + (Math.random() - 0.5) * 10 // Â±5 degree variation\n        );\n        setCurrentAngles(angles);\n        return angles.map(angle => angle * Math.PI / 180); // Convert to radians\n      }\n    } catch (error) {\n      console.error('Error getting joint angles:', error);\n      return [0, 0, 0];\n    }\n  }, [serialConnected, getMotorPosition, currentAngles]);\n  const getRelativeJointAngles = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // For relative angles, we need to calculate the difference between adjacent joints\n        const absoluteAngles = await getCurrentJointAngles();\n\n        // Convert absolute angles to relative angles\n        const relativeAngles = [absoluteAngles[0],\n        // First joint is relative to base\n        absoluteAngles[1] - absoluteAngles[0],\n        // Second relative to first\n        absoluteAngles[2] - absoluteAngles[1] // Third relative to second\n        ];\n        return relativeAngles;\n      } else {\n        // Simulation mode - return mock relative angles\n        return currentAngles.map(angle => angle * Math.PI / 180);\n      }\n    } catch (error) {\n      console.error('Error getting relative joint angles:', error);\n      return [0, 0, 0];\n    }\n  }, [serialConnected, getCurrentJointAngles, currentAngles]);\n  const moveToPosition = useCallback(async angles => {\n    try {\n      if (serialConnected) {\n        // Convert angles to raw positions and send commands\n        const rawPositions = angles.map(angle => {\n          const degrees = angle * 180 / Math.PI; // Convert to degrees\n          return Math.round(2048 + degrees / 180 * 2048); // Convert to raw position\n        });\n        await Promise.all([sendCommand(`SET_POS:1:${rawPositions[0]}`), sendCommand(`SET_POS:2:${rawPositions[1]}`), sendCommand(`SET_POS:3:${rawPositions[2]}`)]);\n        console.log('Moved to position:', angles);\n      } else {\n        // Simulation mode\n        console.log('Moving to position (simulation):', angles);\n        setCurrentAngles(angles.map(rad => rad * 180 / Math.PI));\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error moving to position:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n  const setVelocity = useCallback(async (motorId, velocity) => {\n    try {\n      if (serialConnected) {\n        await sendCommand(`SET_VEL:${motorId}:${velocity}`);\n        console.log(`Set velocity for motor ${motorId}: ${velocity}`);\n      } else {\n        console.log(`Setting velocity for motor ${motorId}: ${velocity} (simulation)`);\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error setting velocity:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n  const emergencyStop = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        await serialEmergencyStop();\n      } else {\n        console.log('Emergency stop activated (simulation)');\n        setCurrentAngles([0, 0, 0]); // Reset to safe position\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error during emergency stop:', error);\n      throw error;\n    }\n  }, [serialConnected, serialEmergencyStop]);\n  const calibrate = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // Send calibration commands\n        await sendCommand('CALIBRATE');\n        console.log('Robot calibration started');\n      } else {\n        console.log('Calibrating robot (simulation)');\n        setCurrentAngles([0, 0, 0]); // Reset to home position\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error during calibration:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n  const startChallenge = useCallback(async challengeId => {\n    try {\n      console.log(`Starting challenge ${challengeId}${serialConnected ? '' : ' (simulation)'}`);\n      dispatch(updateRobotState({\n        status: 'challenge_active',\n        currentChallenge: challengeId\n      }));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error starting challenge:', error);\n      throw error;\n    }\n  }, [serialConnected, dispatch]);\n  const stopChallenge = useCallback(async () => {\n    try {\n      console.log(`Stopping challenge${serialConnected ? '' : ' (simulation)'}`);\n      dispatch(updateRobotState({\n        status: 'idle',\n        currentChallenge: null\n      }));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error stopping challenge:', error);\n      throw error;\n    }\n  }, [serialConnected, dispatch]);\n  return {\n    // Connection status\n    isConnected: serialConnected,\n    connectionStatus,\n    isSimulationMode,\n    isSupported,\n    // Current state\n    currentAngles,\n    // Connection management\n    connectToRobot,\n    disconnectFromRobot,\n    // Control functions\n    disableTorque,\n    enableTorque,\n    getCurrentJointAngles,\n    getRelativeJointAngles,\n    moveToPosition,\n    setVelocity,\n    emergencyStop,\n    calibrate,\n    // Challenge functions\n    startChallenge,\n    stopChallenge,\n    // Hardware functions\n    pingMotor,\n    getMotorPosition,\n    // Robot specs for compatibility\n    robotSpecs: {\n      linkLengths: [0.10, 0.07, 0.05],\n      // meters\n      jointLimits: [{\n        min: -180,\n        max: 180\n      }, {\n        min: -90,\n        max: 90\n      }, {\n        min: -90,\n        max: 90\n      }],\n      maxVelocity: 50,\n      // degrees/second\n      precision: 0.1 // degrees\n    }\n  };\n};\n_s(useRobotController, \"bBvO6+4qV2AueFJXCcl2ZjvFsvw=\", false, function () {\n  return [useDispatch, useSelector, useWebSerial];\n});\nexport default useRobotController;","map":{"version":3,"names":["useState","useEffect","useCallback","useDispatch","useSelector","updateRobotState","setConnectionStatus","useWebSerial","useRobotController","_s","dispatch","connected","connectionStatus","state","robot","currentAngles","setCurrentAngles","isSimulationMode","setIsSimulationMode","isSupported","isConnected","serialConnected","connect","connectSerial","disconnect","disconnectSerial","sendCommand","pingMotor","getMotorPosition","emergencyStop","serialEmergencyStop","initializeConnection","console","log","error","connectToRobot","Error","disconnectFromRobot","disableTorque","Promise","resolve","enableTorque","getCurrentJointAngles","positions","all","angles","map","pos","degrees","Math","PI","rad","angle","random","getRelativeJointAngles","absoluteAngles","relativeAngles","moveToPosition","rawPositions","round","setVelocity","motorId","velocity","calibrate","startChallenge","challengeId","status","currentChallenge","stopChallenge","robotSpecs","linkLengths","jointLimits","min","max","maxVelocity","precision"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/hooks/useWebSerial.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { updateRobotState, setConnectionStatus } from '../store/robotSlice';\nimport { useWebSerial } from './useWebSerial';\n\n// Robot controller hook that uses WebSerial for communication\nexport const useRobotController = () => {\n  const dispatch = useDispatch();\n  const { connected, connectionStatus } = useSelector(state => state.robot);\n  \n  const [currentAngles, setCurrentAngles] = useState([0, 0, 0]);\n  const [isSimulationMode, setIsSimulationMode] = useState(true);\n\n  // Use the full WebSerial implementation\n  const {\n    isSupported,\n    isConnected: serialConnected,\n    connect: connectSerial,\n    disconnect: disconnectSerial,\n    sendCommand,\n    pingMotor,\n    getMotorPosition,\n    emergencyStop: serialEmergencyStop\n  } = useWebSerial();\n\n  // Connection status - use serial connection if available, otherwise simulation\n  const isConnected = serialConnected || false;\n\n  // Initialize connection attempt\n  useEffect(() => {\n    const initializeConnection = async () => {\n      if (isSupported) {\n        try {\n          dispatch(setConnectionStatus('connecting'));\n          console.log('Attempting to connect to robot hardware...');\n          \n          // Try to connect (this will show browser serial port dialog)\n          // await connectSerial();\n          \n          // For now, default to simulation mode\n          dispatch(setConnectionStatus('disconnected'));\n          setIsSimulationMode(true);\n          console.log('Robot controller initialized in simulation mode');\n          \n        } catch (error) {\n          console.error('Failed to connect to robot:', error);\n          dispatch(setConnectionStatus('error'));\n          setIsSimulationMode(true);\n        }\n      } else {\n        console.log('WebSerial not supported, using simulation mode');\n        dispatch(setConnectionStatus('disconnected'));\n        setIsSimulationMode(true);\n      }\n    };\n\n    initializeConnection();\n  }, [dispatch, isSupported, connectSerial]);\n\n  // Manual connect function for user-initiated connection\n  const connectToRobot = useCallback(async () => {\n    if (!isSupported) {\n      throw new Error('WebSerial not supported in this browser');\n    }\n\n    try {\n      await connectSerial();\n      setIsSimulationMode(false);\n      return true;\n    } catch (error) {\n      console.error('Failed to connect to robot:', error);\n      setIsSimulationMode(true);\n      throw error;\n    }\n  }, [isSupported, connectSerial]);\n\n  // Disconnect function\n  const disconnectFromRobot = useCallback(async () => {\n    try {\n      await disconnectSerial();\n      setIsSimulationMode(true);\n    } catch (error) {\n      console.error('Error disconnecting:', error);\n      throw error;\n    }\n  }, [disconnectSerial]);\n\n  // Robot control functions\n  const disableTorque = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // Send disable torque command for all motors\n        await sendCommand('DISABLE:1');\n        await sendCommand('DISABLE:2');\n        await sendCommand('DISABLE:3');\n        console.log('Torque disabled for all motors');\n      } else {\n        console.log('Disabling torque (simulation)');\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error disabling torque:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n\n  const enableTorque = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // Send enable torque command for all motors\n        await sendCommand('ENABLE:1');\n        await sendCommand('ENABLE:2');\n        await sendCommand('ENABLE:3');\n        console.log('Torque enabled for all motors');\n      } else {\n        console.log('Enabling torque (simulation)');\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error enabling torque:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n\n  const getCurrentJointAngles = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // Get positions from all motors\n        const positions = await Promise.all([\n          getMotorPosition(1),\n          getMotorPosition(2),\n          getMotorPosition(3)\n        ]);\n        \n        // Convert raw positions to angles in radians\n        const angles = positions.map(pos => {\n          if (pos === null) return 0;\n          // Convert raw position (0-4095) to degrees, then to radians\n          const degrees = ((pos - 2048) / 2048) * 180; // Assuming center is 2048\n          return degrees * Math.PI / 180;\n        });\n        \n        setCurrentAngles(angles.map(rad => rad * 180 / Math.PI)); // Store in degrees\n        return angles;\n      } else {\n        // Simulation mode - return mock angles with some variation\n        const angles = currentAngles.map(angle => \n          angle + (Math.random() - 0.5) * 10 // Â±5 degree variation\n        );\n        setCurrentAngles(angles);\n        return angles.map(angle => angle * Math.PI / 180); // Convert to radians\n      }\n    } catch (error) {\n      console.error('Error getting joint angles:', error);\n      return [0, 0, 0];\n    }\n  }, [serialConnected, getMotorPosition, currentAngles]);\n\n  const getRelativeJointAngles = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // For relative angles, we need to calculate the difference between adjacent joints\n        const absoluteAngles = await getCurrentJointAngles();\n        \n        // Convert absolute angles to relative angles\n        const relativeAngles = [\n          absoluteAngles[0], // First joint is relative to base\n          absoluteAngles[1] - absoluteAngles[0], // Second relative to first\n          absoluteAngles[2] - absoluteAngles[1]  // Third relative to second\n        ];\n        \n        return relativeAngles;\n      } else {\n        // Simulation mode - return mock relative angles\n        return currentAngles.map(angle => angle * Math.PI / 180);\n      }\n    } catch (error) {\n      console.error('Error getting relative joint angles:', error);\n      return [0, 0, 0];\n    }\n  }, [serialConnected, getCurrentJointAngles, currentAngles]);\n\n  const moveToPosition = useCallback(async (angles) => {\n    try {\n      if (serialConnected) {\n        // Convert angles to raw positions and send commands\n        const rawPositions = angles.map(angle => {\n          const degrees = angle * 180 / Math.PI; // Convert to degrees\n          return Math.round(2048 + (degrees / 180) * 2048); // Convert to raw position\n        });\n        \n        await Promise.all([\n          sendCommand(`SET_POS:1:${rawPositions[0]}`),\n          sendCommand(`SET_POS:2:${rawPositions[1]}`),\n          sendCommand(`SET_POS:3:${rawPositions[2]}`)\n        ]);\n        \n        console.log('Moved to position:', angles);\n      } else {\n        // Simulation mode\n        console.log('Moving to position (simulation):', angles);\n        setCurrentAngles(angles.map(rad => rad * 180 / Math.PI));\n      }\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error moving to position:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n\n  const setVelocity = useCallback(async (motorId, velocity) => {\n    try {\n      if (serialConnected) {\n        await sendCommand(`SET_VEL:${motorId}:${velocity}`);\n        console.log(`Set velocity for motor ${motorId}: ${velocity}`);\n      } else {\n        console.log(`Setting velocity for motor ${motorId}: ${velocity} (simulation)`);\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error setting velocity:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n\n  const emergencyStop = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        await serialEmergencyStop();\n      } else {\n        console.log('Emergency stop activated (simulation)');\n        setCurrentAngles([0, 0, 0]); // Reset to safe position\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error during emergency stop:', error);\n      throw error;\n    }\n  }, [serialConnected, serialEmergencyStop]);\n\n  const calibrate = useCallback(async () => {\n    try {\n      if (serialConnected) {\n        // Send calibration commands\n        await sendCommand('CALIBRATE');\n        console.log('Robot calibration started');\n      } else {\n        console.log('Calibrating robot (simulation)');\n        setCurrentAngles([0, 0, 0]); // Reset to home position\n      }\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error during calibration:', error);\n      throw error;\n    }\n  }, [serialConnected, sendCommand]);\n\n  const startChallenge = useCallback(async (challengeId) => {\n    try {\n      console.log(`Starting challenge ${challengeId}${serialConnected ? '' : ' (simulation)'}`);\n      dispatch(updateRobotState({ \n        status: 'challenge_active',\n        currentChallenge: challengeId \n      }));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error starting challenge:', error);\n      throw error;\n    }\n  }, [serialConnected, dispatch]);\n\n  const stopChallenge = useCallback(async () => {\n    try {\n      console.log(`Stopping challenge${serialConnected ? '' : ' (simulation)'}`);\n      dispatch(updateRobotState({ \n        status: 'idle',\n        currentChallenge: null \n      }));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error stopping challenge:', error);\n      throw error;\n    }\n  }, [serialConnected, dispatch]);\n\n  return {\n    // Connection status\n    isConnected: serialConnected,\n    connectionStatus,\n    isSimulationMode,\n    isSupported,\n    \n    // Current state\n    currentAngles,\n    \n    // Connection management\n    connectToRobot,\n    disconnectFromRobot,\n    \n    // Control functions\n    disableTorque,\n    enableTorque,\n    getCurrentJointAngles,\n    getRelativeJointAngles,\n    moveToPosition,\n    setVelocity,\n    emergencyStop,\n    calibrate,\n    \n    // Challenge functions\n    startChallenge,\n    stopChallenge,\n    \n    // Hardware functions\n    pingMotor,\n    getMotorPosition,\n    \n    // Robot specs for compatibility\n    robotSpecs: {\n      linkLengths: [0.10, 0.07, 0.05], // meters\n      jointLimits: [\n        { min: -180, max: 180 },\n        { min: -90, max: 90 },\n        { min: -90, max: 90 }\n      ],\n      maxVelocity: 50, // degrees/second\n      precision: 0.1 // degrees\n    }\n  };\n};\n\nexport default useRobotController;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}