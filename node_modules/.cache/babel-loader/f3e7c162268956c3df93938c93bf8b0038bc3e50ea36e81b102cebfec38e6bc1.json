{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\nimport toast from 'react-hot-toast';\nimport { setConnectionStatus, setRobotError, clearRobotError, updateRobotState } from '../store/robotSlice';\n\n// Constants for serial configuration\nconst SERIAL_CONFIG = {\n  BAUDRATE: 115200,\n  DATA_BITS: 8,\n  STOP_BITS: 1,\n  PARITY: 'none',\n  FLOW_CONTROL: 'none',\n  COMMAND_DELAY: 50,\n  TIMEOUT: 5000\n};\nconst COMMANDS = {\n  PING: 'PING',\n  GET_POSITION: 'GET_POS',\n  SET_POSITION: 'SET_POS',\n  GET_VELOCITY: 'GET_VEL',\n  SET_VELOCITY: 'SET_VEL',\n  EMERGENCY_STOP: 'ESTOP',\n  ENABLE_TORQUE: 'ENABLE',\n  DISABLE_TORQUE: 'DISABLE'\n};\nexport const useWebSocket = () => {\n  _s();\n  const [port, setPort] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isReading, setIsReading] = useState(false);\n  const readerRef = useRef(null);\n  const writerRef = useRef(null);\n  const dataBufferRef = useRef('');\n  const commandQueueRef = useRef([]);\n  const processingCommandRef = useRef(false);\n  const dispatch = useDispatch();\n\n  // Check WebSerial support\n  const isSupported = 'serial' in navigator;\n\n  // Helper functions\n  const now = () => Date.now();\n  const debugLog = (message, data) => console.log(`[DEBUG] ${message}`, data);\n  const errorLog = (message, error) => console.error(`[ERROR] ${message}`, error);\n\n  // Log function\n  const log = useCallback((message, type = 'info') => {\n    console.log(`[${type.toUpperCase()}] ${message}`);\n  }, []);\n\n  // Process command queue\n  const processCommandQueue = useCallback(async () => {\n    if (processingCommandRef.current || commandQueueRef.current.length === 0) {\n      return;\n    }\n    processingCommandRef.current = true;\n    while (commandQueueRef.current.length > 0) {\n      const {\n        command,\n        resolve,\n        reject\n      } = commandQueueRef.current.shift();\n      try {\n        if (!writerRef.current || !isConnected) {\n          throw new Error('Serial port not available');\n        }\n        const commandWithTerminator = command.endsWith(';') ? command : command + ';';\n        log(`→ ${commandWithTerminator}`, 'command');\n        const encoder = new TextEncoder();\n        await writerRef.current.write(encoder.encode(commandWithTerminator));\n\n        // Small delay between commands\n        await new Promise(resolve => setTimeout(resolve, SERIAL_CONFIG.COMMAND_DELAY));\n        resolve(true);\n      } catch (error) {\n        errorLog(`Command failed: ${command}`, error);\n        log(`Command error: ${error.message}`, 'error');\n        reject(error);\n      }\n    }\n    processingCommandRef.current = false;\n  }, [isConnected, log]);\n\n  // Connect to serial port\n  const connect = useCallback(async () => {\n    if (!isSupported) {\n      const message = 'WebSerial API not supported in this browser';\n      toast.error(message);\n      dispatch(setRobotError(message));\n      return false;\n    }\n    try {\n      dispatch(setConnectionStatus('connecting'));\n      dispatch(clearRobotError());\n      log('Requesting serial port...', 'info');\n      const selectedPort = await navigator.serial.requestPort();\n      await selectedPort.open({\n        baudRate: SERIAL_CONFIG.BAUDRATE,\n        dataBits: SERIAL_CONFIG.DATA_BITS,\n        stopBits: SERIAL_CONFIG.STOP_BITS,\n        parity: SERIAL_CONFIG.PARITY,\n        flowControl: SERIAL_CONFIG.FLOW_CONTROL\n      });\n      setPort(selectedPort);\n      const reader = selectedPort.readable.getReader();\n      const writer = selectedPort.writable.getWriter();\n      readerRef.current = reader;\n      writerRef.current = writer;\n      setIsConnected(true);\n      dispatch(setConnectionStatus('connected'));\n      log('Connected to ESP32 successfully', 'info');\n      toast.success('Connected to ESP32');\n\n      // Start reading data\n      startReading();\n      return true;\n    } catch (error) {\n      errorLog('Connection failed', error);\n      log(`Connection failed: ${error.message}`, 'error');\n      dispatch(setConnectionStatus('disconnected'));\n      dispatch(setRobotError(error.message));\n      toast.error('Connection failed');\n      return false;\n    }\n  }, [isSupported, dispatch, log]);\n\n  // Disconnect from serial port\n  const disconnect = useCallback(async () => {\n    try {\n      setIsReading(false);\n\n      // Clear command queue\n      commandQueueRef.current = [];\n      processingCommandRef.current = false;\n      if (readerRef.current) {\n        await readerRef.current.cancel();\n        await readerRef.current.releaseLock();\n        readerRef.current = null;\n      }\n      if (writerRef.current) {\n        await writerRef.current.releaseLock();\n        writerRef.current = null;\n      }\n      if (port) {\n        await port.close();\n        setPort(null);\n      }\n      setIsConnected(false);\n      dispatch(setConnectionStatus('disconnected'));\n      dispatch(clearRobotError());\n      log('Disconnected from ESP32', 'info');\n      toast.success('Disconnected');\n    } catch (error) {\n      errorLog('Disconnection error', error);\n      log(`Disconnection error: ${error.message}`, 'error');\n      toast.error('Disconnection error');\n    }\n  }, [port, dispatch, log]);\n\n  // Start reading serial data\n  const startReading = useCallback(async () => {\n    if (!readerRef.current || isReading) return;\n    setIsReading(true);\n    try {\n      while (isConnected && readerRef.current) {\n        const {\n          value,\n          done\n        } = await readerRef.current.read();\n        if (done) break;\n        const text = new TextDecoder().decode(value);\n        handleSerialData(text);\n      }\n    } catch (error) {\n      if (isConnected) {\n        errorLog('Read error', error);\n        log(`Read error: ${error.message}`, 'error');\n      }\n    } finally {\n      setIsReading(false);\n    }\n  }, [isConnected, isReading, log]);\n\n  // Handle incoming serial data\n  const handleSerialData = useCallback(text => {\n    dataBufferRef.current += text;\n    const lines = dataBufferRef.current.split('\\n');\n    dataBufferRef.current = lines.pop() || '';\n    for (let line of lines) {\n      line = line.trim();\n      if (line) {\n        log(`← ${line}`, 'response');\n        processSerialResponse(line);\n      }\n    }\n  }, [log]);\n\n  // Process serial responses\n  const processSerialResponse = useCallback(response => {\n    try {\n      if (response === 'PING_OK') {\n        window.dispatchEvent(new CustomEvent('pingResponse', {\n          detail: {\n            success: true\n          }\n        }));\n      } else if (response === 'PING_FAIL') {\n        window.dispatchEvent(new CustomEvent('pingResponse', {\n          detail: {\n            success: false\n          }\n        }));\n      } else if (response === 'OK') {\n        log('Command executed successfully', 'info');\n      } else if (response.startsWith('POS:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const position = parseInt(parts[2]);\n          dispatch(updateRobotState({\n            jointAngles: {\n              [motorId]: position\n            }\n          }));\n          window.dispatchEvent(new CustomEvent('positionUpdate', {\n            detail: {\n              motorId,\n              position\n            }\n          }));\n        }\n      } else if (response.startsWith('VEL:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const velocity = parseInt(parts[2]);\n          window.dispatchEvent(new CustomEvent('velocityUpdate', {\n            detail: {\n              motorId,\n              velocity\n            }\n          }));\n        }\n      } else if (response.startsWith('TEMP:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const temperature = parseInt(parts[2]);\n          window.dispatchEvent(new CustomEvent('temperatureUpdate', {\n            detail: {\n              motorId,\n              temperature\n            }\n          }));\n        }\n      } else if (response.startsWith('ERROR:')) {\n        const errorMsg = response.substring(6);\n        log(`Hardware error: ${errorMsg}`, 'error');\n        toast.error(`Hardware error: ${errorMsg}`);\n        dispatch(setRobotError(errorMsg));\n      } else if (response === 'ESP32_DYNAMIXEL_CONTROLLER_READY') {\n        log('ESP32 controller ready!', 'info');\n        toast.success('ESP32 ready!');\n        window.dispatchEvent(new CustomEvent('controllerReady'));\n      } else if (response.includes('Motor ID')) {\n        log(response, 'info');\n        const match = response.match(/Motor ID (\\d+):/);\n        if (match && response.includes('Connected')) {\n          const motorId = parseInt(match[1]);\n          window.dispatchEvent(new CustomEvent('motorDetected', {\n            detail: {\n              motorId\n            }\n          }));\n        }\n      } else {\n        debugLog('Unknown response:', response);\n      }\n    } catch (error) {\n      errorLog('Error processing serial response', error);\n    }\n  }, [log, dispatch]);\n\n  // Send command to serial port\n  const sendCommand = useCallback(async command => {\n    if (!isConnected) {\n      const error = new Error('Not connected to send command');\n      log(error.message, 'error');\n      throw error;\n    }\n    return new Promise((resolve, reject) => {\n      commandQueueRef.current.push({\n        command,\n        resolve,\n        reject\n      });\n      processCommandQueue();\n    });\n  }, [isConnected, log, processCommandQueue]);\n\n  // Ping a motor\n  const pingMotor = useCallback(async motorId => {\n    if (!isConnected) return false;\n    return new Promise(resolve => {\n      const timeout = setTimeout(() => {\n        resolve(false);\n      }, SERIAL_CONFIG.TIMEOUT);\n      const handlePingResponse = event => {\n        clearTimeout(timeout);\n        window.removeEventListener('pingResponse', handlePingResponse);\n        resolve(event.detail.success);\n      };\n      window.addEventListener('pingResponse', handlePingResponse);\n      sendCommand(`${COMMANDS.PING}:${motorId}`).catch(() => {\n        clearTimeout(timeout);\n        window.removeEventListener('pingResponse', handlePingResponse);\n        resolve(false);\n      });\n    });\n  }, [isConnected, sendCommand]);\n\n  // Get motor position\n  const getMotorPosition = useCallback(async motorId => {\n    if (!isConnected) return null;\n    return new Promise(resolve => {\n      const timeout = setTimeout(() => {\n        resolve(null);\n      }, SERIAL_CONFIG.TIMEOUT);\n      const handlePositionUpdate = event => {\n        if (event.detail.motorId === motorId) {\n          clearTimeout(timeout);\n          window.removeEventListener('positionUpdate', handlePositionUpdate);\n          resolve(event.detail.position);\n        }\n      };\n      window.addEventListener('positionUpdate', handlePositionUpdate);\n      sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`).catch(() => {\n        clearTimeout(timeout);\n        window.removeEventListener('positionUpdate', handlePositionUpdate);\n        resolve(null);\n      });\n    });\n  }, [isConnected, sendCommand]);\n\n  // Emergency stop all motors\n  const emergencyStop = useCallback(async () => {\n    if (!isConnected) return;\n    try {\n      await sendCommand(COMMANDS.EMERGENCY_STOP);\n      log('Emergency stop executed', 'warning');\n      toast.error('Emergency stop activated!');\n    } catch (error) {\n      errorLog('Emergency stop failed', error);\n    }\n  }, [isConnected, sendCommand, log]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (isConnected) {\n        disconnect();\n      }\n    };\n  }, [isConnected, disconnect]);\n\n  // Auto-reconnect functionality\n  const autoReconnect = useCallback(async () => {\n    if (!isConnected && port) {\n      log('Attempting auto-reconnect...', 'info');\n      try {\n        await connect();\n      } catch (error) {\n        errorLog('Auto-reconnect failed', error);\n      }\n    }\n  }, [isConnected, port, connect, log]);\n  return {\n    // State\n    isSupported,\n    isConnected,\n    isReading,\n    port,\n    // Actions\n    connect,\n    disconnect,\n    sendCommand,\n    // Utilities\n    pingMotor,\n    getMotorPosition,\n    emergencyStop,\n    autoReconnect\n  };\n};\n_s(useWebSocket, \"PA25OOUg+wtEWBDxtvtOwVMYacc=\", false, function () {\n  return [useDispatch];\n});","map":{"version":3,"names":["useState","useCallback","useRef","useEffect","useDispatch","toast","setConnectionStatus","setRobotError","clearRobotError","updateRobotState","SERIAL_CONFIG","BAUDRATE","DATA_BITS","STOP_BITS","PARITY","FLOW_CONTROL","COMMAND_DELAY","TIMEOUT","COMMANDS","PING","GET_POSITION","SET_POSITION","GET_VELOCITY","SET_VELOCITY","EMERGENCY_STOP","ENABLE_TORQUE","DISABLE_TORQUE","useWebSocket","_s","port","setPort","isConnected","setIsConnected","isReading","setIsReading","readerRef","writerRef","dataBufferRef","commandQueueRef","processingCommandRef","dispatch","isSupported","navigator","now","Date","debugLog","message","data","console","log","errorLog","error","type","toUpperCase","processCommandQueue","current","length","command","resolve","reject","shift","Error","commandWithTerminator","endsWith","encoder","TextEncoder","write","encode","Promise","setTimeout","connect","selectedPort","serial","requestPort","open","baudRate","dataBits","stopBits","parity","flowControl","reader","readable","getReader","writer","writable","getWriter","success","startReading","disconnect","cancel","releaseLock","close","value","done","read","text","TextDecoder","decode","handleSerialData","lines","split","pop","line","trim","processSerialResponse","response","window","dispatchEvent","CustomEvent","detail","startsWith","parts","motorId","parseInt","position","jointAngles","velocity","temperature","errorMsg","substring","includes","match","sendCommand","push","pingMotor","timeout","handlePingResponse","event","clearTimeout","removeEventListener","addEventListener","catch","getMotorPosition","handlePositionUpdate","emergencyStop","autoReconnect"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\nimport toast from 'react-hot-toast';\nimport { \n  setConnectionStatus, \n  setRobotError,\n  clearRobotError,\n  updateRobotState \n} from '../store/robotSlice';\n\n// Constants for serial configuration\nconst SERIAL_CONFIG = {\n  BAUDRATE: 115200,\n  DATA_BITS: 8,\n  STOP_BITS: 1,\n  PARITY: 'none',\n  FLOW_CONTROL: 'none',\n  COMMAND_DELAY: 50,\n  TIMEOUT: 5000,\n};\n\nconst COMMANDS = {\n  PING: 'PING',\n  GET_POSITION: 'GET_POS',\n  SET_POSITION: 'SET_POS',\n  GET_VELOCITY: 'GET_VEL',\n  SET_VELOCITY: 'SET_VEL',\n  EMERGENCY_STOP: 'ESTOP',\n  ENABLE_TORQUE: 'ENABLE',\n  DISABLE_TORQUE: 'DISABLE',\n};\n\nexport const useWebSocket = () => {\n  const [port, setPort] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isReading, setIsReading] = useState(false);\n  \n  const readerRef = useRef(null);\n  const writerRef = useRef(null);\n  const dataBufferRef = useRef('');\n  const commandQueueRef = useRef([]);\n  const processingCommandRef = useRef(false);\n  \n  const dispatch = useDispatch();\n\n  // Check WebSerial support\n  const isSupported = 'serial' in navigator;\n\n  // Helper functions\n  const now = () => Date.now();\n  const debugLog = (message, data) => console.log(`[DEBUG] ${message}`, data);\n  const errorLog = (message, error) => console.error(`[ERROR] ${message}`, error);\n\n  // Log function\n  const log = useCallback((message, type = 'info') => {\n    console.log(`[${type.toUpperCase()}] ${message}`);\n  }, []);\n\n  // Process command queue\n  const processCommandQueue = useCallback(async () => {\n    if (processingCommandRef.current || commandQueueRef.current.length === 0) {\n      return;\n    }\n\n    processingCommandRef.current = true;\n\n    while (commandQueueRef.current.length > 0) {\n      const { command, resolve, reject } = commandQueueRef.current.shift();\n      \n      try {\n        if (!writerRef.current || !isConnected) {\n          throw new Error('Serial port not available');\n        }\n\n        const commandWithTerminator = command.endsWith(';') ? command : command + ';';\n        log(`→ ${commandWithTerminator}`, 'command');\n        \n        const encoder = new TextEncoder();\n        await writerRef.current.write(encoder.encode(commandWithTerminator));\n        \n        // Small delay between commands\n        await new Promise(resolve => setTimeout(resolve, SERIAL_CONFIG.COMMAND_DELAY));\n        \n        resolve(true);\n      } catch (error) {\n        errorLog(`Command failed: ${command}`, error);\n        log(`Command error: ${error.message}`, 'error');\n        reject(error);\n      }\n    }\n\n    processingCommandRef.current = false;\n  }, [isConnected, log]);\n\n  // Connect to serial port\n  const connect = useCallback(async () => {\n    if (!isSupported) {\n      const message = 'WebSerial API not supported in this browser';\n      toast.error(message);\n      dispatch(setRobotError(message));\n      return false;\n    }\n\n    try {\n      dispatch(setConnectionStatus('connecting'));\n      dispatch(clearRobotError());\n      log('Requesting serial port...', 'info');\n\n      const selectedPort = await navigator.serial.requestPort();\n      \n      await selectedPort.open({\n        baudRate: SERIAL_CONFIG.BAUDRATE,\n        dataBits: SERIAL_CONFIG.DATA_BITS,\n        stopBits: SERIAL_CONFIG.STOP_BITS,\n        parity: SERIAL_CONFIG.PARITY,\n        flowControl: SERIAL_CONFIG.FLOW_CONTROL,\n      });\n\n      setPort(selectedPort);\n      \n      const reader = selectedPort.readable.getReader();\n      const writer = selectedPort.writable.getWriter();\n      \n      readerRef.current = reader;\n      writerRef.current = writer;\n      \n      setIsConnected(true);\n      dispatch(setConnectionStatus('connected'));\n      \n      log('Connected to ESP32 successfully', 'info');\n      toast.success('Connected to ESP32');\n\n      // Start reading data\n      startReading();\n      \n      return true;\n    } catch (error) {\n      errorLog('Connection failed', error);\n      log(`Connection failed: ${error.message}`, 'error');\n      dispatch(setConnectionStatus('disconnected'));\n      dispatch(setRobotError(error.message));\n      toast.error('Connection failed');\n      return false;\n    }\n  }, [isSupported, dispatch, log]);\n\n  // Disconnect from serial port\n  const disconnect = useCallback(async () => {\n    try {\n      setIsReading(false);\n      \n      // Clear command queue\n      commandQueueRef.current = [];\n      processingCommandRef.current = false;\n      \n      if (readerRef.current) {\n        await readerRef.current.cancel();\n        await readerRef.current.releaseLock();\n        readerRef.current = null;\n      }\n      \n      if (writerRef.current) {\n        await writerRef.current.releaseLock();\n        writerRef.current = null;\n      }\n      \n      if (port) {\n        await port.close();\n        setPort(null);\n      }\n      \n      setIsConnected(false);\n      dispatch(setConnectionStatus('disconnected'));\n      dispatch(clearRobotError());\n      \n      log('Disconnected from ESP32', 'info');\n      toast.success('Disconnected');\n      \n    } catch (error) {\n      errorLog('Disconnection error', error);\n      log(`Disconnection error: ${error.message}`, 'error');\n      toast.error('Disconnection error');\n    }\n  }, [port, dispatch, log]);\n\n  // Start reading serial data\n  const startReading = useCallback(async () => {\n    if (!readerRef.current || isReading) return;\n    \n    setIsReading(true);\n    \n    try {\n      while (isConnected && readerRef.current) {\n        const { value, done } = await readerRef.current.read();\n        if (done) break;\n        \n        const text = new TextDecoder().decode(value);\n        handleSerialData(text);\n      }\n    } catch (error) {\n      if (isConnected) {\n        errorLog('Read error', error);\n        log(`Read error: ${error.message}`, 'error');\n      }\n    } finally {\n      setIsReading(false);\n    }\n  }, [isConnected, isReading, log]);\n\n  // Handle incoming serial data\n  const handleSerialData = useCallback((text) => {\n    dataBufferRef.current += text;\n    const lines = dataBufferRef.current.split('\\n');\n    dataBufferRef.current = lines.pop() || '';\n    \n    for (let line of lines) {\n      line = line.trim();\n      if (line) {\n        log(`← ${line}`, 'response');\n        processSerialResponse(line);\n      }\n    }\n  }, [log]);\n\n  // Process serial responses\n  const processSerialResponse = useCallback((response) => {\n    try {\n      if (response === 'PING_OK') {\n        window.dispatchEvent(new CustomEvent('pingResponse', { \n          detail: { success: true } \n        }));\n      } else if (response === 'PING_FAIL') {\n        window.dispatchEvent(new CustomEvent('pingResponse', { \n          detail: { success: false } \n        }));\n      } else if (response === 'OK') {\n        log('Command executed successfully', 'info');\n      } else if (response.startsWith('POS:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const position = parseInt(parts[2]);\n          dispatch(updateRobotState({\n            jointAngles: { [motorId]: position }\n          }));\n          window.dispatchEvent(new CustomEvent('positionUpdate', { \n            detail: { motorId, position } \n          }));\n        }\n      } else if (response.startsWith('VEL:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const velocity = parseInt(parts[2]);\n          window.dispatchEvent(new CustomEvent('velocityUpdate', { \n            detail: { motorId, velocity } \n          }));\n        }\n      } else if (response.startsWith('TEMP:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const temperature = parseInt(parts[2]);\n          window.dispatchEvent(new CustomEvent('temperatureUpdate', { \n            detail: { motorId, temperature } \n          }));\n        }\n      } else if (response.startsWith('ERROR:')) {\n        const errorMsg = response.substring(6);\n        log(`Hardware error: ${errorMsg}`, 'error');\n        toast.error(`Hardware error: ${errorMsg}`);\n        dispatch(setRobotError(errorMsg));\n      } else if (response === 'ESP32_DYNAMIXEL_CONTROLLER_READY') {\n        log('ESP32 controller ready!', 'info');\n        toast.success('ESP32 ready!');\n        window.dispatchEvent(new CustomEvent('controllerReady'));\n      } else if (response.includes('Motor ID')) {\n        log(response, 'info');\n        const match = response.match(/Motor ID (\\d+):/);\n        if (match && response.includes('Connected')) {\n          const motorId = parseInt(match[1]);\n          window.dispatchEvent(new CustomEvent('motorDetected', { \n            detail: { motorId } \n          }));\n        }\n      } else {\n        debugLog('Unknown response:', response);\n      }\n    } catch (error) {\n      errorLog('Error processing serial response', error);\n    }\n  }, [log, dispatch]);\n\n  // Send command to serial port\n  const sendCommand = useCallback(async (command) => {\n    if (!isConnected) {\n      const error = new Error('Not connected to send command');\n      log(error.message, 'error');\n      throw error;\n    }\n\n    return new Promise((resolve, reject) => {\n      commandQueueRef.current.push({ command, resolve, reject });\n      processCommandQueue();\n    });\n  }, [isConnected, log, processCommandQueue]);\n\n  // Ping a motor\n  const pingMotor = useCallback(async (motorId) => {\n    if (!isConnected) return false;\n\n    return new Promise((resolve) => {\n      const timeout = setTimeout(() => {\n        resolve(false);\n      }, SERIAL_CONFIG.TIMEOUT);\n      \n      const handlePingResponse = (event) => {\n        clearTimeout(timeout);\n        window.removeEventListener('pingResponse', handlePingResponse);\n        resolve(event.detail.success);\n      };\n      \n      window.addEventListener('pingResponse', handlePingResponse);\n      \n      sendCommand(`${COMMANDS.PING}:${motorId}`).catch(() => {\n        clearTimeout(timeout);\n        window.removeEventListener('pingResponse', handlePingResponse);\n        resolve(false);\n      });\n    });\n  }, [isConnected, sendCommand]);\n\n  // Get motor position\n  const getMotorPosition = useCallback(async (motorId) => {\n    if (!isConnected) return null;\n\n    return new Promise((resolve) => {\n      const timeout = setTimeout(() => {\n        resolve(null);\n      }, SERIAL_CONFIG.TIMEOUT);\n      \n      const handlePositionUpdate = (event) => {\n        if (event.detail.motorId === motorId) {\n          clearTimeout(timeout);\n          window.removeEventListener('positionUpdate', handlePositionUpdate);\n          resolve(event.detail.position);\n        }\n      };\n      \n      window.addEventListener('positionUpdate', handlePositionUpdate);\n      \n      sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`).catch(() => {\n        clearTimeout(timeout);\n        window.removeEventListener('positionUpdate', handlePositionUpdate);\n        resolve(null);\n      });\n    });\n  }, [isConnected, sendCommand]);\n\n  // Emergency stop all motors\n  const emergencyStop = useCallback(async () => {\n    if (!isConnected) return;\n\n    try {\n      await sendCommand(COMMANDS.EMERGENCY_STOP);\n      log('Emergency stop executed', 'warning');\n      toast.error('Emergency stop activated!');\n    } catch (error) {\n      errorLog('Emergency stop failed', error);\n    }\n  }, [isConnected, sendCommand, log]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (isConnected) {\n        disconnect();\n      }\n    };\n  }, [isConnected, disconnect]);\n\n  // Auto-reconnect functionality\n  const autoReconnect = useCallback(async () => {\n    if (!isConnected && port) {\n      log('Attempting auto-reconnect...', 'info');\n      try {\n        await connect();\n      } catch (error) {\n        errorLog('Auto-reconnect failed', error);\n      }\n    }\n  }, [isConnected, port, connect, log]);\n\n  return {\n    // State\n    isSupported,\n    isConnected,\n    isReading,\n    port,\n    \n    // Actions\n    connect,\n    disconnect,\n    sendCommand,\n    \n    // Utilities\n    pingMotor,\n    getMotorPosition,\n    emergencyStop,\n    autoReconnect,\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}