{"ast":null,"code":"// // // Existing functions (keep these if they exist)\n// // export const calculateAccuracy = (targetAngles, currentAngles, tolerance = 10) => {\n// //   const differences = targetAngles.map((target, i) => \n// //     Math.abs(target - currentAngles[i])\n// //   );\n// //   const maxDifference = Math.max(...differences);\n// //   return Math.max(0, 100 - (maxDifference / tolerance * 100));\n// // };\n\n// // export const calculateProgress = (completed, total) => {\n// //   return total > 0 ? (completed / total) * 100 : 0;\n// // };\n\n// // export const clampAngle = (angle, min = -180, max = 180) => {\n// //   return Math.max(min, Math.min(max, angle));\n// // };\n\n// // export const debounce = (func, wait) => {\n// //   let timeout;\n// //   return function executedFunction(...args) {\n// //     const later = () => {\n// //       clearTimeout(timeout);\n// //       func(...args);\n// //     };\n// //     clearTimeout(timeout);\n// //     timeout = setTimeout(later, wait);\n// //   };\n// // };\n\n// // export const throttle = (func, limit) => {\n// //   let inThrottle;\n// //   return function(...args) {\n// //     if (!inThrottle) {\n// //       func.apply(this, args);\n// //       inThrottle = true;\n// //       setTimeout(() => inThrottle = false, limit);\n// //     }\n// //   };\n// // };\n\n// // export const degreesToRadians = (degrees) => {\n// //   return degrees * Math.PI / 180;\n// // };\n\n// // export const radiansToDegrees = (radians) => {\n// //   return radians * 180 / Math.PI;\n// // };\n\n// // export const formatDate = (timestamp) => {\n// //   return new Date(timestamp).toLocaleString();\n// // };\n\n// // export const formatDuration = (seconds) => {\n// //   const hours = Math.floor(seconds / 3600);\n// //   const minutes = Math.floor((seconds % 3600) / 60);\n// //   const secs = Math.floor(seconds % 60);\n\n// //   if (hours > 0) {\n// //     return `${hours}h ${minutes}m ${secs}s`;\n// //   } else if (minutes > 0) {\n// //     return `${minutes}m ${secs}s`;\n// //   } else {\n// //     return `${secs}s`;\n// //   }\n// // };\n\n// // export const generateRandomAngles = (jointLimits) => {\n// //   return jointLimits.map(limit => {\n// //     const range = limit.max - limit.min;\n// //     return limit.min + Math.random() * range;\n// //   });\n// // };\n\n// // export const getDifficultyColor = (difficulty) => {\n// //   switch (difficulty?.toLowerCase()) {\n// //     case 'beginner':\n// //       return '#4CAF50'; // Green\n// //     case 'intermediate':\n// //       return '#FF9800'; // Orange\n// //     case 'advanced':\n// //       return '#F44336'; // Red\n// //     default:\n// //       return '#2196F3'; // Blue\n// //   }\n// // };\n\n// // export const getRank = (score) => {\n// //   if (score >= 90) return { rank: 'Master', color: '#FFD700' };\n// //   if (score >= 80) return { rank: 'Expert', color: '#C0C0C0' };\n// //   if (score >= 70) return { rank: 'Advanced', color: '#CD7F32' };\n// //   if (score >= 60) return { rank: 'Intermediate', color: '#4CAF50' };\n// //   return { rank: 'Beginner', color: '#2196F3' };\n// // };\n\n// // export const getScoreColor = (score) => {\n// //   if (score >= 90) return '#4CAF50'; // Green\n// //   if (score >= 80) return '#8BC34A'; // Light green\n// //   if (score >= 70) return '#CDDC39'; // Yellow-green\n// //   if (score >= 60) return '#FFEB3B'; // Yellow\n// //   if (score >= 50) return '#FF9800'; // Orange\n// //   return '#F44336'; // Red\n// // };\n\n// // // Missing functions that useRobotController expects\n// // export const now = () => Date.now();\n\n// // export const debugLog = (message, ...args) => {\n// //   if (process.env.NODE_ENV === 'development') {\n// //     console.log(`[DEBUG] ${message}`, ...args);\n// //   }\n// // };\n\n// // export const errorLog = (message, error) => {\n// //   console.error(`[ERROR] ${message}`, error);\n// // };\n\n// // export const clamp = (value, min, max) => {\n// //   return Math.max(min, Math.min(max, value));\n// // };\n\n// // // Robot utility functions\n// // export const degreesToPositionRaw = (degrees, motorSpecs) => {\n// //   // Convert degrees to raw motor position\n// //   // This is a simplified conversion - adjust based on your motor specs\n// //   const range = motorSpecs?.positionRange || 4096;\n// //   const normalized = (degrees + 180) / 360; // Normalize to 0-1\n// //   return Math.round(normalized * range);\n// // };\n\n// // export const rawToDegrees = (rawPosition, motorSpecs) => {\n// //   // Convert raw motor position to degrees\n// //   const range = motorSpecs?.positionRange || 4096;\n// //   const normalized = rawPosition / range; // Normalize to 0-1\n// //   return (normalized * 360) - 180; // Convert to -180 to 180 degrees\n// // };\n\n// // export const degreesToVelocityRaw = (degreesPerSecond, motorSpecs) => {\n// //   // Convert degrees per second to raw velocity units\n// //   const maxVelocity = motorSpecs?.maxVelocity || 1023;\n// //   const maxDegreesPerSecond = motorSpecs?.maxDegreesPerSecond || 114; // rpm to deg/s\n\n// //   const normalized = Math.abs(degreesPerSecond) / maxDegreesPerSecond;\n// //   return Math.round(normalized * maxVelocity);\n// // };\n\n// // // Export default object for backward compatibility\n// // const robotUtils = {\n// //   degreesToPositionRaw,\n// //   rawToDegrees,\n// //   degreesToVelocityRaw,\n// //   clamp,\n// //   degreesToRadians,\n// //   radiansToDegrees\n// // };\n\n// // export default robotUtils;\n// // Existing functions (keep these if they exist)\n// export const calculateAccuracy = (targetAngles, currentAngles, tolerance = 10) => {\n//   const differences = targetAngles.map((target, i) => \n//     Math.abs(target - currentAngles[i])\n//   );\n//   const maxDifference = Math.max(...differences);\n//   return Math.max(0, 100 - (maxDifference / tolerance * 100));\n// };\n\n// export const calculateProgress = (completed, total) => {\n//   return total > 0 ? (completed / total) * 100 : 0;\n// };\n\n// export const clampAngle = (angle, min = -180, max = 180) => {\n//   return Math.max(min, Math.min(max, angle));\n// };\n\n// export const debounce = (func, wait) => {\n//   let timeout;\n//   return function executedFunction(...args) {\n//     const later = () => {\n//       clearTimeout(timeout);\n//       func(...args);\n//     };\n//     clearTimeout(timeout);\n//     timeout = setTimeout(later, wait);\n//   };\n// };\n\n// export const throttle = (func, limit) => {\n//   let inThrottle;\n//   return function(...args) {\n//     if (!inThrottle) {\n//       func.apply(this, args);\n//       inThrottle = true;\n//       setTimeout(() => inThrottle = false, limit);\n//     }\n//   };\n// };\n\n// export const degreesToRadians = (degrees) => {\n//   return degrees * Math.PI / 180;\n// };\n\n// export const radiansToDegrees = (radians) => {\n//   return radians * 180 / Math.PI;\n// };\n\n// export const formatDate = (timestamp) => {\n//   return new Date(timestamp).toLocaleString();\n// };\n\n// export const formatDuration = (seconds) => {\n//   const hours = Math.floor(seconds / 3600);\n//   const minutes = Math.floor((seconds % 3600) / 60);\n//   const secs = Math.floor(seconds % 60);\n\n//   if (hours > 0) {\n//     return `${hours}h ${minutes}m ${secs}s`;\n//   } else if (minutes > 0) {\n//     return `${minutes}m ${secs}s`;\n//   } else {\n//     return `${secs}s`;\n//   }\n// };\n\n// export const generateRandomAngles = (jointLimits) => {\n//   return jointLimits.map(limit => {\n//     const range = limit.max - limit.min;\n//     return limit.min + Math.random() * range;\n//   });\n// };\n\n// export const getDifficultyColor = (difficulty) => {\n//   switch (difficulty?.toLowerCase()) {\n//     case 'beginner':\n//       return '#4CAF50'; // Green\n//     case 'intermediate':\n//       return '#FF9800'; // Orange\n//     case 'advanced':\n//       return '#F44336'; // Red\n//     default:\n//       return '#2196F3'; // Blue\n//   }\n// };\n\n// export const getRank = (score) => {\n//   if (score >= 90) return { rank: 'Master', color: '#FFD700' };\n//   if (score >= 80) return { rank: 'Expert', color: '#C0C0C0' };\n//   if (score >= 70) return { rank: 'Advanced', color: '#CD7F32' };\n//   if (score >= 60) return { rank: 'Intermediate', color: '#4CAF50' };\n//   return { rank: 'Beginner', color: '#2196F3' };\n// };\n\n// export const getScoreColor = (score) => {\n//   if (score >= 90) return '#4CAF50'; // Green\n//   if (score >= 80) return '#8BC34A'; // Light green\n//   if (score >= 70) return '#CDDC39'; // Yellow-green\n//   if (score >= 60) return '#FFEB3B'; // Yellow\n//   if (score >= 50) return '#FF9800'; // Orange\n//   return '#F44336'; // Red\n// };\n\n// // Missing functions that useRobotController expects\n// export const now = () => Date.now();\n\n// export const debugLog = (message, ...args) => {\n//   if (process.env.NODE_ENV === 'development') {\n//     console.log(`[DEBUG] ${message}`, ...args);\n//   }\n// };\n\n// export const errorLog = (message, error) => {\n//   console.error(`[ERROR] ${message}`, error);\n// };\n\n// export const clamp = (value, min, max) => {\n//   return Math.max(min, Math.min(max, value));\n// };\n\n// // Robot utility functions - EXPORTED AS NAMED EXPORTS\n// export const degreesToPositionRaw = (degrees, motorSpecs) => {\n//   // Convert degrees to raw motor position\n//   // This is a simplified conversion - adjust based on your motor specs\n//   const range = motorSpecs?.positionRange || 4096;\n//   const normalized = (degrees + 180) / 360; // Normalize to 0-1\n//   return Math.round(normalized * range);\n// };\n\n// export const rawToDegrees = (rawPosition, motorSpecs) => {\n//   // Convert raw motor position to degrees\n//   const range = motorSpecs?.positionRange || 4096;\n//   const normalized = rawPosition / range; // Normalize to 0-1\n//   return (normalized * 360) - 180; // Convert to -180 to 180 degrees\n// };\n\n// export const degreesToVelocityRaw = (degreesPerSecond, motorSpecs) => {\n//   // Convert degrees per second to raw velocity units\n//   const maxVelocity = motorSpecs?.maxVelocity || 1023;\n//   const maxDegreesPerSecond = motorSpecs?.maxDegreesPerSecond || 114; // rpm to deg/s\n\n//   const normalized = Math.abs(degreesPerSecond) / maxDegreesPerSecond;\n//   return Math.round(normalized * maxVelocity);\n// };\n\n// // Export default object for backward compatibility but keep named exports above\n// const robotUtils = {\n//   degreesToPositionRaw,\n//   rawToDegrees,\n//   degreesToVelocityRaw,\n//   clamp,\n//   degreesToRadians,\n//   radiansToDegrees\n// };\n\n// export default robotUtils;","map":{"version":3,"names":[],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/utils/helpers.js"],"sourcesContent":["// // // Existing functions (keep these if they exist)\n// // export const calculateAccuracy = (targetAngles, currentAngles, tolerance = 10) => {\n// //   const differences = targetAngles.map((target, i) => \n// //     Math.abs(target - currentAngles[i])\n// //   );\n// //   const maxDifference = Math.max(...differences);\n// //   return Math.max(0, 100 - (maxDifference / tolerance * 100));\n// // };\n\n// // export const calculateProgress = (completed, total) => {\n// //   return total > 0 ? (completed / total) * 100 : 0;\n// // };\n\n// // export const clampAngle = (angle, min = -180, max = 180) => {\n// //   return Math.max(min, Math.min(max, angle));\n// // };\n\n// // export const debounce = (func, wait) => {\n// //   let timeout;\n// //   return function executedFunction(...args) {\n// //     const later = () => {\n// //       clearTimeout(timeout);\n// //       func(...args);\n// //     };\n// //     clearTimeout(timeout);\n// //     timeout = setTimeout(later, wait);\n// //   };\n// // };\n\n// // export const throttle = (func, limit) => {\n// //   let inThrottle;\n// //   return function(...args) {\n// //     if (!inThrottle) {\n// //       func.apply(this, args);\n// //       inThrottle = true;\n// //       setTimeout(() => inThrottle = false, limit);\n// //     }\n// //   };\n// // };\n\n// // export const degreesToRadians = (degrees) => {\n// //   return degrees * Math.PI / 180;\n// // };\n\n// // export const radiansToDegrees = (radians) => {\n// //   return radians * 180 / Math.PI;\n// // };\n\n// // export const formatDate = (timestamp) => {\n// //   return new Date(timestamp).toLocaleString();\n// // };\n\n// // export const formatDuration = (seconds) => {\n// //   const hours = Math.floor(seconds / 3600);\n// //   const minutes = Math.floor((seconds % 3600) / 60);\n// //   const secs = Math.floor(seconds % 60);\n  \n// //   if (hours > 0) {\n// //     return `${hours}h ${minutes}m ${secs}s`;\n// //   } else if (minutes > 0) {\n// //     return `${minutes}m ${secs}s`;\n// //   } else {\n// //     return `${secs}s`;\n// //   }\n// // };\n\n// // export const generateRandomAngles = (jointLimits) => {\n// //   return jointLimits.map(limit => {\n// //     const range = limit.max - limit.min;\n// //     return limit.min + Math.random() * range;\n// //   });\n// // };\n\n// // export const getDifficultyColor = (difficulty) => {\n// //   switch (difficulty?.toLowerCase()) {\n// //     case 'beginner':\n// //       return '#4CAF50'; // Green\n// //     case 'intermediate':\n// //       return '#FF9800'; // Orange\n// //     case 'advanced':\n// //       return '#F44336'; // Red\n// //     default:\n// //       return '#2196F3'; // Blue\n// //   }\n// // };\n\n// // export const getRank = (score) => {\n// //   if (score >= 90) return { rank: 'Master', color: '#FFD700' };\n// //   if (score >= 80) return { rank: 'Expert', color: '#C0C0C0' };\n// //   if (score >= 70) return { rank: 'Advanced', color: '#CD7F32' };\n// //   if (score >= 60) return { rank: 'Intermediate', color: '#4CAF50' };\n// //   return { rank: 'Beginner', color: '#2196F3' };\n// // };\n\n// // export const getScoreColor = (score) => {\n// //   if (score >= 90) return '#4CAF50'; // Green\n// //   if (score >= 80) return '#8BC34A'; // Light green\n// //   if (score >= 70) return '#CDDC39'; // Yellow-green\n// //   if (score >= 60) return '#FFEB3B'; // Yellow\n// //   if (score >= 50) return '#FF9800'; // Orange\n// //   return '#F44336'; // Red\n// // };\n\n// // // Missing functions that useRobotController expects\n// // export const now = () => Date.now();\n\n// // export const debugLog = (message, ...args) => {\n// //   if (process.env.NODE_ENV === 'development') {\n// //     console.log(`[DEBUG] ${message}`, ...args);\n// //   }\n// // };\n\n// // export const errorLog = (message, error) => {\n// //   console.error(`[ERROR] ${message}`, error);\n// // };\n\n// // export const clamp = (value, min, max) => {\n// //   return Math.max(min, Math.min(max, value));\n// // };\n\n// // // Robot utility functions\n// // export const degreesToPositionRaw = (degrees, motorSpecs) => {\n// //   // Convert degrees to raw motor position\n// //   // This is a simplified conversion - adjust based on your motor specs\n// //   const range = motorSpecs?.positionRange || 4096;\n// //   const normalized = (degrees + 180) / 360; // Normalize to 0-1\n// //   return Math.round(normalized * range);\n// // };\n\n// // export const rawToDegrees = (rawPosition, motorSpecs) => {\n// //   // Convert raw motor position to degrees\n// //   const range = motorSpecs?.positionRange || 4096;\n// //   const normalized = rawPosition / range; // Normalize to 0-1\n// //   return (normalized * 360) - 180; // Convert to -180 to 180 degrees\n// // };\n\n// // export const degreesToVelocityRaw = (degreesPerSecond, motorSpecs) => {\n// //   // Convert degrees per second to raw velocity units\n// //   const maxVelocity = motorSpecs?.maxVelocity || 1023;\n// //   const maxDegreesPerSecond = motorSpecs?.maxDegreesPerSecond || 114; // rpm to deg/s\n  \n// //   const normalized = Math.abs(degreesPerSecond) / maxDegreesPerSecond;\n// //   return Math.round(normalized * maxVelocity);\n// // };\n\n// // // Export default object for backward compatibility\n// // const robotUtils = {\n// //   degreesToPositionRaw,\n// //   rawToDegrees,\n// //   degreesToVelocityRaw,\n// //   clamp,\n// //   degreesToRadians,\n// //   radiansToDegrees\n// // };\n\n// // export default robotUtils;\n// // Existing functions (keep these if they exist)\n// export const calculateAccuracy = (targetAngles, currentAngles, tolerance = 10) => {\n//   const differences = targetAngles.map((target, i) => \n//     Math.abs(target - currentAngles[i])\n//   );\n//   const maxDifference = Math.max(...differences);\n//   return Math.max(0, 100 - (maxDifference / tolerance * 100));\n// };\n\n// export const calculateProgress = (completed, total) => {\n//   return total > 0 ? (completed / total) * 100 : 0;\n// };\n\n// export const clampAngle = (angle, min = -180, max = 180) => {\n//   return Math.max(min, Math.min(max, angle));\n// };\n\n// export const debounce = (func, wait) => {\n//   let timeout;\n//   return function executedFunction(...args) {\n//     const later = () => {\n//       clearTimeout(timeout);\n//       func(...args);\n//     };\n//     clearTimeout(timeout);\n//     timeout = setTimeout(later, wait);\n//   };\n// };\n\n// export const throttle = (func, limit) => {\n//   let inThrottle;\n//   return function(...args) {\n//     if (!inThrottle) {\n//       func.apply(this, args);\n//       inThrottle = true;\n//       setTimeout(() => inThrottle = false, limit);\n//     }\n//   };\n// };\n\n// export const degreesToRadians = (degrees) => {\n//   return degrees * Math.PI / 180;\n// };\n\n// export const radiansToDegrees = (radians) => {\n//   return radians * 180 / Math.PI;\n// };\n\n// export const formatDate = (timestamp) => {\n//   return new Date(timestamp).toLocaleString();\n// };\n\n// export const formatDuration = (seconds) => {\n//   const hours = Math.floor(seconds / 3600);\n//   const minutes = Math.floor((seconds % 3600) / 60);\n//   const secs = Math.floor(seconds % 60);\n  \n//   if (hours > 0) {\n//     return `${hours}h ${minutes}m ${secs}s`;\n//   } else if (minutes > 0) {\n//     return `${minutes}m ${secs}s`;\n//   } else {\n//     return `${secs}s`;\n//   }\n// };\n\n// export const generateRandomAngles = (jointLimits) => {\n//   return jointLimits.map(limit => {\n//     const range = limit.max - limit.min;\n//     return limit.min + Math.random() * range;\n//   });\n// };\n\n// export const getDifficultyColor = (difficulty) => {\n//   switch (difficulty?.toLowerCase()) {\n//     case 'beginner':\n//       return '#4CAF50'; // Green\n//     case 'intermediate':\n//       return '#FF9800'; // Orange\n//     case 'advanced':\n//       return '#F44336'; // Red\n//     default:\n//       return '#2196F3'; // Blue\n//   }\n// };\n\n// export const getRank = (score) => {\n//   if (score >= 90) return { rank: 'Master', color: '#FFD700' };\n//   if (score >= 80) return { rank: 'Expert', color: '#C0C0C0' };\n//   if (score >= 70) return { rank: 'Advanced', color: '#CD7F32' };\n//   if (score >= 60) return { rank: 'Intermediate', color: '#4CAF50' };\n//   return { rank: 'Beginner', color: '#2196F3' };\n// };\n\n// export const getScoreColor = (score) => {\n//   if (score >= 90) return '#4CAF50'; // Green\n//   if (score >= 80) return '#8BC34A'; // Light green\n//   if (score >= 70) return '#CDDC39'; // Yellow-green\n//   if (score >= 60) return '#FFEB3B'; // Yellow\n//   if (score >= 50) return '#FF9800'; // Orange\n//   return '#F44336'; // Red\n// };\n\n// // Missing functions that useRobotController expects\n// export const now = () => Date.now();\n\n// export const debugLog = (message, ...args) => {\n//   if (process.env.NODE_ENV === 'development') {\n//     console.log(`[DEBUG] ${message}`, ...args);\n//   }\n// };\n\n// export const errorLog = (message, error) => {\n//   console.error(`[ERROR] ${message}`, error);\n// };\n\n// export const clamp = (value, min, max) => {\n//   return Math.max(min, Math.min(max, value));\n// };\n\n// // Robot utility functions - EXPORTED AS NAMED EXPORTS\n// export const degreesToPositionRaw = (degrees, motorSpecs) => {\n//   // Convert degrees to raw motor position\n//   // This is a simplified conversion - adjust based on your motor specs\n//   const range = motorSpecs?.positionRange || 4096;\n//   const normalized = (degrees + 180) / 360; // Normalize to 0-1\n//   return Math.round(normalized * range);\n// };\n\n// export const rawToDegrees = (rawPosition, motorSpecs) => {\n//   // Convert raw motor position to degrees\n//   const range = motorSpecs?.positionRange || 4096;\n//   const normalized = rawPosition / range; // Normalize to 0-1\n//   return (normalized * 360) - 180; // Convert to -180 to 180 degrees\n// };\n\n// export const degreesToVelocityRaw = (degreesPerSecond, motorSpecs) => {\n//   // Convert degrees per second to raw velocity units\n//   const maxVelocity = motorSpecs?.maxVelocity || 1023;\n//   const maxDegreesPerSecond = motorSpecs?.maxDegreesPerSecond || 114; // rpm to deg/s\n  \n//   const normalized = Math.abs(degreesPerSecond) / maxDegreesPerSecond;\n//   return Math.round(normalized * maxVelocity);\n// };\n\n// // Export default object for backward compatibility but keep named exports above\n// const robotUtils = {\n//   degreesToPositionRaw,\n//   rawToDegrees,\n//   degreesToVelocityRaw,\n//   clamp,\n//   degreesToRadians,\n//   radiansToDegrees\n// };\n\n// export default robotUtils;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}