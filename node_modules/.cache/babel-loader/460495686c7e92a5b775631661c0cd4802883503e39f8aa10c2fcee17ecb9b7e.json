{"ast":null,"code":"var _s = $RefreshSig$();\n// import { useState, useCallback, useRef, useEffect } from 'react';\n// import { useDispatch } from 'react-redux';\n// import toast from 'react-hot-toast';\n// import { \n//   setConnectionStatus, \n//   setRobotError,\n//   clearRobotError,\n//   updateRobotState \n// } from '../store/robotSlice';\n\n// // Constants for serial configuration\n// const SERIAL_CONFIG = {\n//   BAUDRATE: 115200,\n//   DATA_BITS: 8,\n//   STOP_BITS: 1,\n//   PARITY: 'none',\n//   FLOW_CONTROL: 'none',\n//   COMMAND_DELAY: 50,\n//   TIMEOUT: 5000,\n// };\n\n// const COMMANDS = {\n//   PING: 'PING',\n//   GET_POSITION: 'GET_POS',\n//   SET_POSITION: 'SET_POS',\n//   GET_VELOCITY: 'GET_VEL',\n//   SET_VELOCITY: 'SET_VEL',\n//   EMERGENCY_STOP: 'ESTOP',\n//   ENABLE_TORQUE: 'ENABLE',\n//   DISABLE_TORQUE: 'DISABLE',\n// };\n\n// export const useWebSocket = () => {\n//   const [port, setPort] = useState(null);\n//   const [isConnected, setIsConnected] = useState(false);\n//   const [isReading, setIsReading] = useState(false);\n\n//   const readerRef = useRef(null);\n//   const writerRef = useRef(null);\n//   const dataBufferRef = useRef('');\n//   const commandQueueRef = useRef([]);\n//   const processingCommandRef = useRef(false);\n\n//   const dispatch = useDispatch();\n\n//   // Check WebSerial support\n//   const isSupported = 'serial' in navigator;\n\n//   // Helper functions\n//   const now = () => Date.now();\n//   const debugLog = (message, data) => console.log(`[DEBUG] ${message}`, data);\n//   const errorLog = (message, error) => console.error(`[ERROR] ${message}`, error);\n\n//   // Log function\n//   const log = useCallback((message, type = 'info') => {\n//     console.log(`[${type.toUpperCase()}] ${message}`);\n//   }, []);\n\n//   // Process command queue\n//   const processCommandQueue = useCallback(async () => {\n//     if (processingCommandRef.current || commandQueueRef.current.length === 0) {\n//       return;\n//     }\n\n//     processingCommandRef.current = true;\n\n//     while (commandQueueRef.current.length > 0) {\n//       const { command, resolve, reject } = commandQueueRef.current.shift();\n\n//       try {\n//         if (!writerRef.current || !isConnected) {\n//           throw new Error('Serial port not available');\n//         }\n\n//         const commandWithTerminator = command.endsWith(';') ? command : command + ';';\n//         log(`→ ${commandWithTerminator}`, 'command');\n\n//         const encoder = new TextEncoder();\n//         await writerRef.current.write(encoder.encode(commandWithTerminator));\n\n//         // Small delay between commands\n//         await new Promise(resolve => setTimeout(resolve, SERIAL_CONFIG.COMMAND_DELAY));\n\n//         resolve(true);\n//       } catch (error) {\n//         errorLog(`Command failed: ${command}`, error);\n//         log(`Command error: ${error.message}`, 'error');\n//         reject(error);\n//       }\n//     }\n\n//     processingCommandRef.current = false;\n//   }, [isConnected, log]);\n\n//   // Connect to serial port\n//   const connect = useCallback(async () => {\n//     if (!isSupported) {\n//       const message = 'WebSerial API not supported in this browser';\n//       toast.error(message);\n//       dispatch(setRobotError(message));\n//       return false;\n//     }\n\n//     try {\n//       dispatch(setConnectionStatus('connecting'));\n//       dispatch(clearRobotError());\n//       log('Requesting serial port...', 'info');\n\n//       const selectedPort = await navigator.serial.requestPort();\n\n//       await selectedPort.open({\n//         baudRate: SERIAL_CONFIG.BAUDRATE,\n//         dataBits: SERIAL_CONFIG.DATA_BITS,\n//         stopBits: SERIAL_CONFIG.STOP_BITS,\n//         parity: SERIAL_CONFIG.PARITY,\n//         flowControl: SERIAL_CONFIG.FLOW_CONTROL,\n//       });\n\n//       setPort(selectedPort);\n\n//       const reader = selectedPort.readable.getReader();\n//       const writer = selectedPort.writable.getWriter();\n\n//       readerRef.current = reader;\n//       writerRef.current = writer;\n\n//       setIsConnected(true);\n//       dispatch(setConnectionStatus('connected'));\n\n//       log('Connected to ESP32 successfully', 'info');\n//       toast.success('Connected to ESP32');\n\n//       // Start reading data\n//       startReading();\n\n//       return true;\n//     } catch (error) {\n//       errorLog('Connection failed', error);\n//       log(`Connection failed: ${error.message}`, 'error');\n//       dispatch(setConnectionStatus('disconnected'));\n//       dispatch(setRobotError(error.message));\n//       toast.error('Connection failed');\n//       return false;\n//     }\n//   }, [isSupported, dispatch, log]);\n\n//   // Disconnect from serial port\n//   const disconnect = useCallback(async () => {\n//     try {\n//       setIsReading(false);\n\n//       // Clear command queue\n//       commandQueueRef.current = [];\n//       processingCommandRef.current = false;\n\n//       if (readerRef.current) {\n//         await readerRef.current.cancel();\n//         await readerRef.current.releaseLock();\n//         readerRef.current = null;\n//       }\n\n//       if (writerRef.current) {\n//         await writerRef.current.releaseLock();\n//         writerRef.current = null;\n//       }\n\n//       if (port) {\n//         await port.close();\n//         setPort(null);\n//       }\n\n//       setIsConnected(false);\n//       dispatch(setConnectionStatus('disconnected'));\n//       dispatch(clearRobotError());\n\n//       log('Disconnected from ESP32', 'info');\n//       toast.success('Disconnected');\n\n//     } catch (error) {\n//       errorLog('Disconnection error', error);\n//       log(`Disconnection error: ${error.message}`, 'error');\n//       toast.error('Disconnection error');\n//     }\n//   }, [port, dispatch, log]);\n\n//   // Start reading serial data\n//   const startReading = useCallback(async () => {\n//     if (!readerRef.current || isReading) return;\n\n//     setIsReading(true);\n\n//     try {\n//       while (isConnected && readerRef.current) {\n//         const { value, done } = await readerRef.current.read();\n//         if (done) break;\n\n//         const text = new TextDecoder().decode(value);\n//         handleSerialData(text);\n//       }\n//     } catch (error) {\n//       if (isConnected) {\n//         errorLog('Read error', error);\n//         log(`Read error: ${error.message}`, 'error');\n//       }\n//     } finally {\n//       setIsReading(false);\n//     }\n//   }, [isConnected, isReading, log]);\n\n//   // Handle incoming serial data\n//   const handleSerialData = useCallback((text) => {\n//     dataBufferRef.current += text;\n//     const lines = dataBufferRef.current.split('\\n');\n//     dataBufferRef.current = lines.pop() || '';\n\n//     for (let line of lines) {\n//       line = line.trim();\n//       if (line) {\n//         log(`← ${line}`, 'response');\n//         processSerialResponse(line);\n//       }\n//     }\n//   }, [log]);\n\n//   // Process serial responses\n//   const processSerialResponse = useCallback((response) => {\n//     try {\n//       if (response === 'PING_OK') {\n//         window.dispatchEvent(new CustomEvent('pingResponse', { \n//           detail: { success: true } \n//         }));\n//       } else if (response === 'PING_FAIL') {\n//         window.dispatchEvent(new CustomEvent('pingResponse', { \n//           detail: { success: false } \n//         }));\n//       } else if (response === 'OK') {\n//         log('Command executed successfully', 'info');\n//       } else if (response.startsWith('POS:')) {\n//         const parts = response.split(':');\n//         if (parts.length >= 3) {\n//           const motorId = parseInt(parts[1]);\n//           const position = parseInt(parts[2]);\n//           dispatch(updateRobotState({\n//             jointAngles: { [motorId]: position }\n//           }));\n//           window.dispatchEvent(new CustomEvent('positionUpdate', { \n//             detail: { motorId, position } \n//           }));\n//         }\n//       } else if (response.startsWith('VEL:')) {\n//         const parts = response.split(':');\n//         if (parts.length >= 3) {\n//           const motorId = parseInt(parts[1]);\n//           const velocity = parseInt(parts[2]);\n//           window.dispatchEvent(new CustomEvent('velocityUpdate', { \n//             detail: { motorId, velocity } \n//           }));\n//         }\n//       } else if (response.startsWith('TEMP:')) {\n//         const parts = response.split(':');\n//         if (parts.length >= 3) {\n//           const motorId = parseInt(parts[1]);\n//           const temperature = parseInt(parts[2]);\n//           window.dispatchEvent(new CustomEvent('temperatureUpdate', { \n//             detail: { motorId, temperature } \n//           }));\n//         }\n//       } else if (response.startsWith('ERROR:')) {\n//         const errorMsg = response.substring(6);\n//         log(`Hardware error: ${errorMsg}`, 'error');\n//         toast.error(`Hardware error: ${errorMsg}`);\n//         dispatch(setRobotError(errorMsg));\n//       } else if (response === 'ESP32_DYNAMIXEL_CONTROLLER_READY') {\n//         log('ESP32 controller ready!', 'info');\n//         toast.success('ESP32 ready!');\n//         window.dispatchEvent(new CustomEvent('controllerReady'));\n//       } else if (response.includes('Motor ID')) {\n//         log(response, 'info');\n//         const match = response.match(/Motor ID (\\d+):/);\n//         if (match && response.includes('Connected')) {\n//           const motorId = parseInt(match[1]);\n//           window.dispatchEvent(new CustomEvent('motorDetected', { \n//             detail: { motorId } \n//           }));\n//         }\n//       } else {\n//         debugLog('Unknown response:', response);\n//       }\n//     } catch (error) {\n//       errorLog('Error processing serial response', error);\n//     }\n//   }, [log, dispatch]);\n\n//   // Send command to serial port\n//   const sendCommand = useCallback(async (command) => {\n//     if (!isConnected) {\n//       const error = new Error('Not connected to send command');\n//       log(error.message, 'error');\n//       throw error;\n//     }\n\n//     return new Promise((resolve, reject) => {\n//       commandQueueRef.current.push({ command, resolve, reject });\n//       processCommandQueue();\n//     });\n//   }, [isConnected, log, processCommandQueue]);\n\n//   // Ping a motor\n//   const pingMotor = useCallback(async (motorId) => {\n//     if (!isConnected) return false;\n\n//     return new Promise((resolve) => {\n//       const timeout = setTimeout(() => {\n//         resolve(false);\n//       }, SERIAL_CONFIG.TIMEOUT);\n\n//       const handlePingResponse = (event) => {\n//         clearTimeout(timeout);\n//         window.removeEventListener('pingResponse', handlePingResponse);\n//         resolve(event.detail.success);\n//       };\n\n//       window.addEventListener('pingResponse', handlePingResponse);\n\n//       sendCommand(`${COMMANDS.PING}:${motorId}`).catch(() => {\n//         clearTimeout(timeout);\n//         window.removeEventListener('pingResponse', handlePingResponse);\n//         resolve(false);\n//       });\n//     });\n//   }, [isConnected, sendCommand]);\n\n//   // Get motor position\n//   const getMotorPosition = useCallback(async (motorId) => {\n//     if (!isConnected) return null;\n\n//     return new Promise((resolve) => {\n//       const timeout = setTimeout(() => {\n//         resolve(null);\n//       }, SERIAL_CONFIG.TIMEOUT);\n\n//       const handlePositionUpdate = (event) => {\n//         if (event.detail.motorId === motorId) {\n//           clearTimeout(timeout);\n//           window.removeEventListener('positionUpdate', handlePositionUpdate);\n//           resolve(event.detail.position);\n//         }\n//       };\n\n//       window.addEventListener('positionUpdate', handlePositionUpdate);\n\n//       sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`).catch(() => {\n//         clearTimeout(timeout);\n//         window.removeEventListener('positionUpdate', handlePositionUpdate);\n//         resolve(null);\n//       });\n//     });\n//   }, [isConnected, sendCommand]);\n\n//   // Emergency stop all motors\n//   const emergencyStop = useCallback(async () => {\n//     if (!isConnected) return;\n\n//     try {\n//       await sendCommand(COMMANDS.EMERGENCY_STOP);\n//       log('Emergency stop executed', 'warning');\n//       toast.error('Emergency stop activated!');\n//     } catch (error) {\n//       errorLog('Emergency stop failed', error);\n//     }\n//   }, [isConnected, sendCommand, log]);\n\n//   // Cleanup on unmount\n//   useEffect(() => {\n//     return () => {\n//       if (isConnected) {\n//         disconnect();\n//       }\n//     };\n//   }, [isConnected, disconnect]);\n\n//   // Auto-reconnect functionality\n//   const autoReconnect = useCallback(async () => {\n//     if (!isConnected && port) {\n//       log('Attempting auto-reconnect...', 'info');\n//       try {\n//         await connect();\n//       } catch (error) {\n//         errorLog('Auto-reconnect failed', error);\n//       }\n//     }\n//   }, [isConnected, port, connect, log]);\n\n//   return {\n//     // State\n//     isSupported,\n//     isConnected,\n//     isReading,\n//     port,\n\n//     // Actions\n//     connect,\n//     disconnect,\n//     sendCommand,\n\n//     // Utilities\n//     pingMotor,\n//     getMotorPosition,\n//     emergencyStop,\n//     autoReconnect,\n//   };\n// };\n\nimport { useState, useCallback } from 'react';\n\n// Simple Web Serial API hook\nexport const useWebSerial = () => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [port, setPort] = useState(null);\n  const [error, setError] = useState(null);\n  const connect = useCallback(async () => {\n    try {\n      if (!('serial' in navigator)) {\n        throw new Error('Web Serial API not supported');\n      }\n\n      // Request a port and open a connection\n      const selectedPort = await navigator.serial.requestPort();\n      await selectedPort.open({\n        baudRate: 1000000\n      });\n      setPort(selectedPort);\n      setIsConnected(true);\n      setError(null);\n      return selectedPort;\n    } catch (err) {\n      setError(err.message);\n      setIsConnected(false);\n      throw err;\n    }\n  }, []);\n  const disconnect = useCallback(async () => {\n    try {\n      if (port && port.readable) {\n        await port.close();\n      }\n      setPort(null);\n      setIsConnected(false);\n      setError(null);\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  }, [port]);\n  const sendCommand = useCallback(async command => {\n    if (!port || !isConnected) {\n      throw new Error('Serial port not connected');\n    }\n    try {\n      const writer = port.writable.getWriter();\n      const encoder = new TextEncoder();\n      await writer.write(encoder.encode(command + '\\n'));\n      writer.releaseLock();\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  }, [port, isConnected]);\n  const readResponse = useCallback(async () => {\n    if (!port || !isConnected) {\n      throw new Error('Serial port not connected');\n    }\n    try {\n      const reader = port.readable.getReader();\n      const decoder = new TextDecoder();\n      const {\n        value,\n        done\n      } = await reader.read();\n      reader.releaseLock();\n      if (done) {\n        throw new Error('Serial connection closed');\n      }\n      return decoder.decode(value);\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  }, [port, isConnected]);\n  return {\n    isConnected,\n    port,\n    error,\n    connect,\n    disconnect,\n    sendCommand,\n    readResponse\n  };\n};\n_s(useWebSerial, \"Ki1Ek0HW8oCRnxugQGY/g9Wqi68=\");\nexport default useWebSerial;","map":{"version":3,"names":["useState","useCallback","useWebSerial","_s","isConnected","setIsConnected","port","setPort","error","setError","connect","navigator","Error","selectedPort","serial","requestPort","open","baudRate","err","message","disconnect","readable","close","sendCommand","command","writer","writable","getWriter","encoder","TextEncoder","write","encode","releaseLock","readResponse","reader","getReader","decoder","TextDecoder","value","done","read","decode"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["// import { useState, useCallback, useRef, useEffect } from 'react';\n// import { useDispatch } from 'react-redux';\n// import toast from 'react-hot-toast';\n// import { \n//   setConnectionStatus, \n//   setRobotError,\n//   clearRobotError,\n//   updateRobotState \n// } from '../store/robotSlice';\n\n// // Constants for serial configuration\n// const SERIAL_CONFIG = {\n//   BAUDRATE: 115200,\n//   DATA_BITS: 8,\n//   STOP_BITS: 1,\n//   PARITY: 'none',\n//   FLOW_CONTROL: 'none',\n//   COMMAND_DELAY: 50,\n//   TIMEOUT: 5000,\n// };\n\n// const COMMANDS = {\n//   PING: 'PING',\n//   GET_POSITION: 'GET_POS',\n//   SET_POSITION: 'SET_POS',\n//   GET_VELOCITY: 'GET_VEL',\n//   SET_VELOCITY: 'SET_VEL',\n//   EMERGENCY_STOP: 'ESTOP',\n//   ENABLE_TORQUE: 'ENABLE',\n//   DISABLE_TORQUE: 'DISABLE',\n// };\n\n// export const useWebSocket = () => {\n//   const [port, setPort] = useState(null);\n//   const [isConnected, setIsConnected] = useState(false);\n//   const [isReading, setIsReading] = useState(false);\n  \n//   const readerRef = useRef(null);\n//   const writerRef = useRef(null);\n//   const dataBufferRef = useRef('');\n//   const commandQueueRef = useRef([]);\n//   const processingCommandRef = useRef(false);\n  \n//   const dispatch = useDispatch();\n\n//   // Check WebSerial support\n//   const isSupported = 'serial' in navigator;\n\n//   // Helper functions\n//   const now = () => Date.now();\n//   const debugLog = (message, data) => console.log(`[DEBUG] ${message}`, data);\n//   const errorLog = (message, error) => console.error(`[ERROR] ${message}`, error);\n\n//   // Log function\n//   const log = useCallback((message, type = 'info') => {\n//     console.log(`[${type.toUpperCase()}] ${message}`);\n//   }, []);\n\n//   // Process command queue\n//   const processCommandQueue = useCallback(async () => {\n//     if (processingCommandRef.current || commandQueueRef.current.length === 0) {\n//       return;\n//     }\n\n//     processingCommandRef.current = true;\n\n//     while (commandQueueRef.current.length > 0) {\n//       const { command, resolve, reject } = commandQueueRef.current.shift();\n      \n//       try {\n//         if (!writerRef.current || !isConnected) {\n//           throw new Error('Serial port not available');\n//         }\n\n//         const commandWithTerminator = command.endsWith(';') ? command : command + ';';\n//         log(`→ ${commandWithTerminator}`, 'command');\n        \n//         const encoder = new TextEncoder();\n//         await writerRef.current.write(encoder.encode(commandWithTerminator));\n        \n//         // Small delay between commands\n//         await new Promise(resolve => setTimeout(resolve, SERIAL_CONFIG.COMMAND_DELAY));\n        \n//         resolve(true);\n//       } catch (error) {\n//         errorLog(`Command failed: ${command}`, error);\n//         log(`Command error: ${error.message}`, 'error');\n//         reject(error);\n//       }\n//     }\n\n//     processingCommandRef.current = false;\n//   }, [isConnected, log]);\n\n//   // Connect to serial port\n//   const connect = useCallback(async () => {\n//     if (!isSupported) {\n//       const message = 'WebSerial API not supported in this browser';\n//       toast.error(message);\n//       dispatch(setRobotError(message));\n//       return false;\n//     }\n\n//     try {\n//       dispatch(setConnectionStatus('connecting'));\n//       dispatch(clearRobotError());\n//       log('Requesting serial port...', 'info');\n\n//       const selectedPort = await navigator.serial.requestPort();\n      \n//       await selectedPort.open({\n//         baudRate: SERIAL_CONFIG.BAUDRATE,\n//         dataBits: SERIAL_CONFIG.DATA_BITS,\n//         stopBits: SERIAL_CONFIG.STOP_BITS,\n//         parity: SERIAL_CONFIG.PARITY,\n//         flowControl: SERIAL_CONFIG.FLOW_CONTROL,\n//       });\n\n//       setPort(selectedPort);\n      \n//       const reader = selectedPort.readable.getReader();\n//       const writer = selectedPort.writable.getWriter();\n      \n//       readerRef.current = reader;\n//       writerRef.current = writer;\n      \n//       setIsConnected(true);\n//       dispatch(setConnectionStatus('connected'));\n      \n//       log('Connected to ESP32 successfully', 'info');\n//       toast.success('Connected to ESP32');\n\n//       // Start reading data\n//       startReading();\n      \n//       return true;\n//     } catch (error) {\n//       errorLog('Connection failed', error);\n//       log(`Connection failed: ${error.message}`, 'error');\n//       dispatch(setConnectionStatus('disconnected'));\n//       dispatch(setRobotError(error.message));\n//       toast.error('Connection failed');\n//       return false;\n//     }\n//   }, [isSupported, dispatch, log]);\n\n//   // Disconnect from serial port\n//   const disconnect = useCallback(async () => {\n//     try {\n//       setIsReading(false);\n      \n//       // Clear command queue\n//       commandQueueRef.current = [];\n//       processingCommandRef.current = false;\n      \n//       if (readerRef.current) {\n//         await readerRef.current.cancel();\n//         await readerRef.current.releaseLock();\n//         readerRef.current = null;\n//       }\n      \n//       if (writerRef.current) {\n//         await writerRef.current.releaseLock();\n//         writerRef.current = null;\n//       }\n      \n//       if (port) {\n//         await port.close();\n//         setPort(null);\n//       }\n      \n//       setIsConnected(false);\n//       dispatch(setConnectionStatus('disconnected'));\n//       dispatch(clearRobotError());\n      \n//       log('Disconnected from ESP32', 'info');\n//       toast.success('Disconnected');\n      \n//     } catch (error) {\n//       errorLog('Disconnection error', error);\n//       log(`Disconnection error: ${error.message}`, 'error');\n//       toast.error('Disconnection error');\n//     }\n//   }, [port, dispatch, log]);\n\n//   // Start reading serial data\n//   const startReading = useCallback(async () => {\n//     if (!readerRef.current || isReading) return;\n    \n//     setIsReading(true);\n    \n//     try {\n//       while (isConnected && readerRef.current) {\n//         const { value, done } = await readerRef.current.read();\n//         if (done) break;\n        \n//         const text = new TextDecoder().decode(value);\n//         handleSerialData(text);\n//       }\n//     } catch (error) {\n//       if (isConnected) {\n//         errorLog('Read error', error);\n//         log(`Read error: ${error.message}`, 'error');\n//       }\n//     } finally {\n//       setIsReading(false);\n//     }\n//   }, [isConnected, isReading, log]);\n\n//   // Handle incoming serial data\n//   const handleSerialData = useCallback((text) => {\n//     dataBufferRef.current += text;\n//     const lines = dataBufferRef.current.split('\\n');\n//     dataBufferRef.current = lines.pop() || '';\n    \n//     for (let line of lines) {\n//       line = line.trim();\n//       if (line) {\n//         log(`← ${line}`, 'response');\n//         processSerialResponse(line);\n//       }\n//     }\n//   }, [log]);\n\n//   // Process serial responses\n//   const processSerialResponse = useCallback((response) => {\n//     try {\n//       if (response === 'PING_OK') {\n//         window.dispatchEvent(new CustomEvent('pingResponse', { \n//           detail: { success: true } \n//         }));\n//       } else if (response === 'PING_FAIL') {\n//         window.dispatchEvent(new CustomEvent('pingResponse', { \n//           detail: { success: false } \n//         }));\n//       } else if (response === 'OK') {\n//         log('Command executed successfully', 'info');\n//       } else if (response.startsWith('POS:')) {\n//         const parts = response.split(':');\n//         if (parts.length >= 3) {\n//           const motorId = parseInt(parts[1]);\n//           const position = parseInt(parts[2]);\n//           dispatch(updateRobotState({\n//             jointAngles: { [motorId]: position }\n//           }));\n//           window.dispatchEvent(new CustomEvent('positionUpdate', { \n//             detail: { motorId, position } \n//           }));\n//         }\n//       } else if (response.startsWith('VEL:')) {\n//         const parts = response.split(':');\n//         if (parts.length >= 3) {\n//           const motorId = parseInt(parts[1]);\n//           const velocity = parseInt(parts[2]);\n//           window.dispatchEvent(new CustomEvent('velocityUpdate', { \n//             detail: { motorId, velocity } \n//           }));\n//         }\n//       } else if (response.startsWith('TEMP:')) {\n//         const parts = response.split(':');\n//         if (parts.length >= 3) {\n//           const motorId = parseInt(parts[1]);\n//           const temperature = parseInt(parts[2]);\n//           window.dispatchEvent(new CustomEvent('temperatureUpdate', { \n//             detail: { motorId, temperature } \n//           }));\n//         }\n//       } else if (response.startsWith('ERROR:')) {\n//         const errorMsg = response.substring(6);\n//         log(`Hardware error: ${errorMsg}`, 'error');\n//         toast.error(`Hardware error: ${errorMsg}`);\n//         dispatch(setRobotError(errorMsg));\n//       } else if (response === 'ESP32_DYNAMIXEL_CONTROLLER_READY') {\n//         log('ESP32 controller ready!', 'info');\n//         toast.success('ESP32 ready!');\n//         window.dispatchEvent(new CustomEvent('controllerReady'));\n//       } else if (response.includes('Motor ID')) {\n//         log(response, 'info');\n//         const match = response.match(/Motor ID (\\d+):/);\n//         if (match && response.includes('Connected')) {\n//           const motorId = parseInt(match[1]);\n//           window.dispatchEvent(new CustomEvent('motorDetected', { \n//             detail: { motorId } \n//           }));\n//         }\n//       } else {\n//         debugLog('Unknown response:', response);\n//       }\n//     } catch (error) {\n//       errorLog('Error processing serial response', error);\n//     }\n//   }, [log, dispatch]);\n\n//   // Send command to serial port\n//   const sendCommand = useCallback(async (command) => {\n//     if (!isConnected) {\n//       const error = new Error('Not connected to send command');\n//       log(error.message, 'error');\n//       throw error;\n//     }\n\n//     return new Promise((resolve, reject) => {\n//       commandQueueRef.current.push({ command, resolve, reject });\n//       processCommandQueue();\n//     });\n//   }, [isConnected, log, processCommandQueue]);\n\n//   // Ping a motor\n//   const pingMotor = useCallback(async (motorId) => {\n//     if (!isConnected) return false;\n\n//     return new Promise((resolve) => {\n//       const timeout = setTimeout(() => {\n//         resolve(false);\n//       }, SERIAL_CONFIG.TIMEOUT);\n      \n//       const handlePingResponse = (event) => {\n//         clearTimeout(timeout);\n//         window.removeEventListener('pingResponse', handlePingResponse);\n//         resolve(event.detail.success);\n//       };\n      \n//       window.addEventListener('pingResponse', handlePingResponse);\n      \n//       sendCommand(`${COMMANDS.PING}:${motorId}`).catch(() => {\n//         clearTimeout(timeout);\n//         window.removeEventListener('pingResponse', handlePingResponse);\n//         resolve(false);\n//       });\n//     });\n//   }, [isConnected, sendCommand]);\n\n//   // Get motor position\n//   const getMotorPosition = useCallback(async (motorId) => {\n//     if (!isConnected) return null;\n\n//     return new Promise((resolve) => {\n//       const timeout = setTimeout(() => {\n//         resolve(null);\n//       }, SERIAL_CONFIG.TIMEOUT);\n      \n//       const handlePositionUpdate = (event) => {\n//         if (event.detail.motorId === motorId) {\n//           clearTimeout(timeout);\n//           window.removeEventListener('positionUpdate', handlePositionUpdate);\n//           resolve(event.detail.position);\n//         }\n//       };\n      \n//       window.addEventListener('positionUpdate', handlePositionUpdate);\n      \n//       sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`).catch(() => {\n//         clearTimeout(timeout);\n//         window.removeEventListener('positionUpdate', handlePositionUpdate);\n//         resolve(null);\n//       });\n//     });\n//   }, [isConnected, sendCommand]);\n\n//   // Emergency stop all motors\n//   const emergencyStop = useCallback(async () => {\n//     if (!isConnected) return;\n\n//     try {\n//       await sendCommand(COMMANDS.EMERGENCY_STOP);\n//       log('Emergency stop executed', 'warning');\n//       toast.error('Emergency stop activated!');\n//     } catch (error) {\n//       errorLog('Emergency stop failed', error);\n//     }\n//   }, [isConnected, sendCommand, log]);\n\n//   // Cleanup on unmount\n//   useEffect(() => {\n//     return () => {\n//       if (isConnected) {\n//         disconnect();\n//       }\n//     };\n//   }, [isConnected, disconnect]);\n\n//   // Auto-reconnect functionality\n//   const autoReconnect = useCallback(async () => {\n//     if (!isConnected && port) {\n//       log('Attempting auto-reconnect...', 'info');\n//       try {\n//         await connect();\n//       } catch (error) {\n//         errorLog('Auto-reconnect failed', error);\n//       }\n//     }\n//   }, [isConnected, port, connect, log]);\n\n//   return {\n//     // State\n//     isSupported,\n//     isConnected,\n//     isReading,\n//     port,\n    \n//     // Actions\n//     connect,\n//     disconnect,\n//     sendCommand,\n    \n//     // Utilities\n//     pingMotor,\n//     getMotorPosition,\n//     emergencyStop,\n//     autoReconnect,\n//   };\n// };\n\nimport { useState, useCallback } from 'react';\n\n// Simple Web Serial API hook\nexport const useWebSerial = () => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [port, setPort] = useState(null);\n  const [error, setError] = useState(null);\n\n  const connect = useCallback(async () => {\n    try {\n      if (!('serial' in navigator)) {\n        throw new Error('Web Serial API not supported');\n      }\n\n      // Request a port and open a connection\n      const selectedPort = await navigator.serial.requestPort();\n      await selectedPort.open({ baudRate: 1000000 });\n      \n      setPort(selectedPort);\n      setIsConnected(true);\n      setError(null);\n      \n      return selectedPort;\n    } catch (err) {\n      setError(err.message);\n      setIsConnected(false);\n      throw err;\n    }\n  }, []);\n\n  const disconnect = useCallback(async () => {\n    try {\n      if (port && port.readable) {\n        await port.close();\n      }\n      setPort(null);\n      setIsConnected(false);\n      setError(null);\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  }, [port]);\n\n  const sendCommand = useCallback(async (command) => {\n    if (!port || !isConnected) {\n      throw new Error('Serial port not connected');\n    }\n\n    try {\n      const writer = port.writable.getWriter();\n      const encoder = new TextEncoder();\n      await writer.write(encoder.encode(command + '\\n'));\n      writer.releaseLock();\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  }, [port, isConnected]);\n\n  const readResponse = useCallback(async () => {\n    if (!port || !isConnected) {\n      throw new Error('Serial port not connected');\n    }\n\n    try {\n      const reader = port.readable.getReader();\n      const decoder = new TextDecoder();\n      const { value, done } = await reader.read();\n      reader.releaseLock();\n      \n      if (done) {\n        throw new Error('Serial connection closed');\n      }\n      \n      return decoder.decode(value);\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  }, [port, isConnected]);\n\n  return {\n    isConnected,\n    port,\n    error,\n    connect,\n    disconnect,\n    sendCommand,\n    readResponse\n  };\n};\n\nexport default useWebSerial;"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}