{"ast":null,"code":"var _s = $RefreshSig$();\n// import { useState, useEffect, useCallback, useRef } from 'react';\n// import { useDispatch, useSelector } from 'react-redux';\n// import { useWebSerial } from './useWebSerial';\n// import {\n//   updateConnectionStatus,\n//   setMotors,\n//   updateMotor,\n//   addMotor,\n//   removeMotor,\n//   updateChartData,\n//   addLogEntry,\n//   incrementCommandCount,\n//   updateUptime,\n//   startChallenge,\n//   stopChallenge as stopChallengeAction,\n//   updateChallengeProgress,\n//   updateHardwareStats,\n//   setEmergencyStop,\n//   selectRobot,\n//   selectIsConnected,\n//   selectMotors,\n//   selectChallengeStatus,\n// } from '../store/robotSlice';\n// import { \n//   rawToDegrees, \n//   degreesToPositionRaw, \n//   degreesToVelocityRaw \n// } from '../utils/robotUtils';\n// import { COMMANDS, ROBOT_SPECS, PERFORMANCE } from '../utils/constants';\n// import { now, clamp, throttle, debugLog, errorLog } from '../utils/helpers';\n// import toast from 'react-hot-toast';\n\n// export const useRobotController = () => {\n//   const dispatch = useDispatch();\n//   const robotState = useSelector(selectRobot);\n//   const isConnected = useSelector(selectIsConnected);\n//   const motors = useSelector(selectMotors);\n//   const challengeStatus = useSelector(selectChallengeStatus);\n\n//   const { \n//     isSupported, \n//     connect: connectSerial, \n//     disconnect: disconnectSerial, \n//     sendCommand, \n//     pingMotor: serialPingMotor,\n//     emergencyStop: serialEmergencyStop \n//   } = useWebSerial();\n\n//   const [connectionStartTime, setConnectionStartTime] = useState(null);\n//   const [challengeInterval, setChallengeInterval] = useState(null);\n//   const [uptimeInterval, setUptimeInterval] = useState(null);\n//   const [monitoringInterval, setMonitoringInterval] = useState(null);\n\n//   const performanceRef = useRef({\n//     commandsSent: 0,\n//     commandsSuccessful: 0,\n//     lastPerformanceUpdate: now(),\n//   });\n\n//   // Connection management\n//   useEffect(() => {\n//     if (isConnected && !connectionStartTime) {\n//       setConnectionStartTime(now());\n//       startUptimeCounter();\n//       startPeriodicMonitoring();\n\n//       // Auto-scan for motors after connection\n//       setTimeout(() => {\n//         scanMotors();\n//       }, 2000);\n\n//     } else if (!isConnected && connectionStartTime) {\n//       setConnectionStartTime(null);\n//       stopUptimeCounter();\n//       stopPeriodicMonitoring();\n//       stopChallenge();\n//     }\n//   }, [isConnected, connectionStartTime]);\n\n//   // Uptime counter\n//   const startUptimeCounter = useCallback(() => {\n//     const interval = setInterval(() => {\n//       if (connectionStartTime) {\n//         const uptime = now() - connectionStartTime;\n//         dispatch(updateUptime(uptime));\n//       }\n//     }, 1000);\n//     setUptimeInterval(interval);\n//   }, [connectionStartTime, dispatch]);\n\n//   const stopUptimeCounter = useCallback(() => {\n//     if (uptimeInterval) {\n//       clearInterval(uptimeInterval);\n//       setUptimeInterval(null);\n//     }\n//   }, [uptimeInterval]);\n\n//   // Periodic monitoring\n//   const startPeriodicMonitoring = useCallback(() => {\n//     const interval = setInterval(async () => {\n//       if (!isConnected || motors.length === 0) return;\n\n//       try {\n//         // Monitor each connected motor\n//         for (const motor of motors) {\n//           if (motor.online) {\n//             // Get current position and temperature\n//             await updateMotorData(motor.id);\n//           }\n//         }\n\n//         // Update performance metrics\n//         updatePerformanceMetrics();\n\n//       } catch (error) {\n//         debugLog('Monitoring error:', error);\n//       }\n//     }, robotState.settings.updateRate || 1000);\n\n//     setMonitoringInterval(interval);\n//   }, [isConnected, motors, robotState.settings.updateRate]);\n\n//   const stopPeriodicMonitoring = useCallback(() => {\n//     if (monitoringInterval) {\n//       clearInterval(monitoringInterval);\n//       setMonitoringInterval(null);\n//     }\n//   }, [monitoringInterval]);\n\n//   // Update motor data\n//   const updateMotorData = useCallback(async (motorId) => {\n//     try {\n//       // This would be implemented with actual sensor reading\n//       // For now, we'll simulate or use cached values\n\n//       const motor = motors.find(m => m.id === motorId);\n//       if (!motor) return;\n\n//       // Simulate data updates (in real implementation, this would read from hardware)\n//       const currentTime = now();\n//       const timeDiff = currentTime - motor.lastUpdate;\n\n//       if (timeDiff > 100) { // Update every 100ms\n//         const simulatedData = {\n//           position: motor.position + (Math.random() - 0.5) * 2, // Small random variation\n//           velocity: motor.velocity + (Math.random() - 0.5) * 5,\n//           temperature: 25 + Math.random() * 10,\n//           current: Math.random() * 0.5,\n//         };\n\n//         dispatch(updateMotor({\n//           motorId,\n//           updates: {\n//             ...simulatedData,\n//             lastUpdate: currentTime,\n//           },\n//         }));\n\n//         // Update chart data\n//         dispatch(updateChartData({\n//           time: currentTime,\n//           motorId,\n//           position: simulatedData.position,\n//           velocity: simulatedData.velocity,\n//           temperature: simulatedData.temperature,\n//           current: simulatedData.current,\n//         }));\n//       }\n\n//     } catch (error) {\n//       errorLog(`Failed to update motor ${motorId} data`, error);\n//     }\n//   }, [motors, dispatch]);\n\n//   // Performance metrics update (throttled)\n//   const updatePerformanceMetrics = useCallback(\n//     throttle(() => {\n//       const now_time = now();\n//       const timeDiff = now_time - performanceRef.current.lastPerformanceUpdate;\n\n//       if (timeDiff > 0) {\n//         const commandsPerSecond = (performanceRef.current.commandsSent / timeDiff) * 1000;\n//         const successRate = performanceRef.current.commandsSuccessful / performanceRef.current.commandsSent;\n\n//         // Reset counters\n//         performanceRef.current.commandsSent = 0;\n//         performanceRef.current.commandsSuccessful = 0;\n//         performanceRef.current.lastPerformanceUpdate = now_time;\n\n//         // Dispatch performance update if needed\n//         debugLog('Performance metrics:', { commandsPerSecond, successRate });\n//       }\n//     }, 5000), // Update every 5 seconds\n//     []\n//   );\n\n//   // Connect to robot\n//   const connect = useCallback(async () => {\n//     try {\n//       dispatch(addLogEntry({\n//         message: 'Attempting to connect to robot...',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       const success = await connectSerial();\n\n//       if (success) {\n//         dispatch(addLogEntry({\n//           message: 'Successfully connected to robot',\n//           type: 'info',\n//           timestamp: now(),\n//         }));\n//         toast.success('Robot connected!');\n//       }\n\n//       return success;\n//     } catch (error) {\n//       errorLog('Robot connection failed', error);\n//       dispatch(addLogEntry({\n//         message: `Connection failed: ${error.message}`,\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n//       toast.error('Connection failed');\n//       return false;\n//     }\n//   }, [connectSerial, dispatch]);\n\n//   // Disconnect from robot\n//   const disconnect = useCallback(async () => {\n//     try {\n//       // Stop any running challenge\n//       if (challengeStatus.running) {\n//         await stopChallenge();\n//       }\n\n//       await disconnectSerial();\n\n//       dispatch(addLogEntry({\n//         message: 'Disconnected from robot',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       toast.success('Robot disconnected');\n//     } catch (error) {\n//       errorLog('Disconnect error', error);\n//       toast.error('Disconnect error');\n//     }\n//   }, [disconnectSerial, challengeStatus.running, dispatch]);\n\n//   // Motor scanning\n//   const scanMotors = useCallback(async () => {\n//     if (!isConnected) {\n//       toast.error('Robot not connected');\n//       return;\n//     }\n\n//     dispatch(addLogEntry({\n//       message: 'Scanning for motors (ID 1-10)...',\n//       type: 'info',\n//       timestamp: now(),\n//     }));\n\n//     const detectedMotors = [];\n\n//     try {\n//       for (let id = 1; id <= 10; id++) {\n//         try {\n//           const isOnline = await serialPingMotor(id);\n\n//           if (isOnline) {\n//             const motor = {\n//               id,\n//               model: ROBOT_SPECS.MODEL,\n//               status: 'online',\n//               online: true,\n//               torqueEnabled: false,\n//               position: ROBOT_SPECS.MAX_POSITION / 2,\n//               velocity: 0,\n//               goalPosition: ROBOT_SPECS.MAX_POSITION / 2,\n//               goalVelocity: 0,\n//               temperature: 25,\n//               voltage: 7.0,\n//               current: 0.0,\n//               load: 0,\n//               lastUpdate: now(),\n//               operatingMode: 3, // Position mode\n//             };\n\n//             detectedMotors.push(motor);\n\n//             dispatch(addLogEntry({\n//               message: `✅ Motor ${id} detected`,\n//               type: 'info',\n//               timestamp: now(),\n//             }));\n//           }\n\n//           // Small delay between pings\n//           await new Promise(resolve => setTimeout(resolve, 200));\n\n//         } catch (error) {\n//           debugLog(`Motor ${id} scan failed:`, error);\n//         }\n//       }\n\n//       dispatch(setMotors(detectedMotors));\n\n//       const message = `Scan complete. Found ${detectedMotors.length} motors.`;\n//       dispatch(addLogEntry({\n//         message,\n//         type: detectedMotors.length > 0 ? 'info' : 'warning',\n//         timestamp: now(),\n//       }));\n\n//       if (detectedMotors.length === 0) {\n//         toast.error('No motors detected. Check connections and power.');\n//       } else {\n//         toast.success(`Found ${detectedMotors.length} motors`);\n//       }\n\n//     } catch (error) {\n//       errorLog('Motor scan failed', error);\n//       dispatch(addLogEntry({\n//         message: `Motor scan failed: ${error.message}`,\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n//       toast.error('Motor scan failed');\n//     }\n//   }, [isConnected, serialPingMotor, dispatch]);\n\n//   // Motor control functions\n//   const enableTorque = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.ENABLE_TORQUE}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { torqueEnabled: true }\n//       }));\n\n//       dispatch(addLogEntry({\n//         message: `Torque enabled for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to enable torque for motor ${motorId}`, error);\n//       toast.error(`Failed to enable motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const disableTorque = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.DISABLE_TORQUE}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { torqueEnabled: false }\n//       }));\n\n//       dispatch(addLogEntry({\n//         message: `Torque disabled for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to disable torque for motor ${motorId}`, error);\n//       toast.error(`Failed to disable motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const setMotorPosition = useCallback(async (motorId, degrees) => {\n//     try {\n//       const positionRaw = degreesToPositionRaw(degrees);\n//       const clampedPosition = clamp(positionRaw, 0, ROBOT_SPECS.MAX_POSITION);\n\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.SET_POSITION}:${motorId}:${clampedPosition}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { \n//           goalPosition: rawToDegrees(clampedPosition),\n//           position: rawToDegrees(clampedPosition) // Immediate update for UI responsiveness\n//         }\n//       }));\n\n//       dispatch(addLogEntry({\n//         message: `Motor ${motorId} position set to ${degrees.toFixed(1)}° (raw: ${clampedPosition})`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to set position for motor ${motorId}`, error);\n//       toast.error(`Failed to move motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const setMotorVelocity = useCallback(async (motorId, degreesPerSec) => {\n//     try {\n//       const velocityRaw = degreesToVelocityRaw(degreesPerSec);\n//       const clampedVelocity = clamp(velocityRaw, ROBOT_SPECS.MIN_VELOCITY, ROBOT_SPECS.MAX_VELOCITY);\n\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.SET_VELOCITY}:${motorId}:${clampedVelocity}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { \n//           goalVelocity: degreesPerSec,\n//           velocity: degreesPerSec // Immediate update\n//         }\n//       }));\n\n//       dispatch(addLogEntry({\n//         message: `Motor ${motorId} velocity set to ${degreesPerSec.toFixed(1)}°/s (raw: ${clampedVelocity})`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to set velocity for motor ${motorId}`, error);\n//       toast.error(`Failed to set velocity for motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const homeMotor = useCallback(async (motorId) => {\n//     const homePosition = 180; // Center position in degrees\n//     return await setMotorPosition(motorId, homePosition);\n//   }, [setMotorPosition]);\n\n//   const stopMotor = useCallback(async (motorId) => {\n//     return await setMotorVelocity(motorId, 0);\n//   }, [setMotorVelocity]);\n\n//   const getMotorPosition = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(addLogEntry({\n//         message: `Reading position for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to get position for motor ${motorId}`, error);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   // Global control functions\n//   const enableAllTorque = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n//     let successCount = 0;\n\n//     for (const motor of onlineMotors) {\n//       const success = await enableTorque(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n\n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors enabled');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors enabled`);\n//     }\n//   }, [motors, enableTorque]);\n\n//   const disableAllTorque = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n//     let successCount = 0;\n\n//     for (const motor of onlineMotors) {\n//       const success = await disableTorque(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n\n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors disabled');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors disabled`);\n//     }\n//   }, [motors, disableTorque]);\n\n//   const homeAllMotors = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n\n//     dispatch(addLogEntry({\n//       message: 'Moving all motors to home position...',\n//       type: 'info',\n//       timestamp: now(),\n//     }));\n\n//     let successCount = 0;\n\n//     for (const motor of onlineMotors) {\n//       const success = await homeMotor(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n\n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors homed');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors homed`);\n//     }\n//   }, [motors, homeMotor, dispatch]);\n\n//   const emergencyStop = useCallback(async () => {\n//     try {\n//       dispatch(addLogEntry({\n//         message: '🛑 EMERGENCY STOP ACTIVATED',\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(setEmergencyStop(true));\n\n//       // Stop serial communication emergency stop\n//       await serialEmergencyStop();\n\n//       // Stop any running challenge\n//       if (challengeStatus.running) {\n//         stopChallenge();\n//       }\n\n//       toast.error('Emergency stop activated!');\n\n//     } catch (error) {\n//       errorLog('Emergency stop failed', error);\n//       toast.error('Emergency stop failed!');\n//     }\n//   }, [serialEmergencyStop, challengeStatus.running, dispatch]);\n\n//   // Challenge execution\n//   const startChallengeExecution = useCallback(async (challengeParams) => {\n//     if (!isConnected || challengeStatus.running) {\n//       toast.error('Cannot start challenge: Robot not ready');\n//       return false;\n//     }\n\n//     const requiredMotors = challengeParams.requiredMotors || [1, 2];\n//     const availableMotors = motors.filter(m => \n//       requiredMotors.includes(m.id) && m.online\n//     );\n\n//     if (availableMotors.length < requiredMotors.length) {\n//       toast.error(`Challenge requires motors ${requiredMotors.join(', ')} to be connected`);\n//       return false;\n//     }\n\n//     try {\n//       dispatch(startChallenge(challengeParams));\n\n//       dispatch(addLogEntry({\n//         message: '🚀 Challenge started successfully',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       toast.success('Challenge started!');\n//       return true;\n\n//     } catch (error) {\n//       errorLog('Challenge start failed', error);\n//       toast.error('Failed to start challenge');\n//       return false;\n//     }\n//   }, [isConnected, challengeStatus.running, motors, dispatch]);\n\n//   const stopChallenge = useCallback(async () => {\n//     if (!challengeStatus.running) return;\n\n//     try {\n//       // Stop challenge interval if running\n//       if (challengeInterval) {\n//         clearInterval(challengeInterval);\n//         setChallengeInterval(null);\n//       }\n\n//       // Stop all motors\n//       const onlineMotors = motors.filter(m => m.online);\n//       for (const motor of onlineMotors) {\n//         await stopMotor(motor.id);\n//       }\n\n//       dispatch(stopChallengeAction());\n\n//       dispatch(addLogEntry({\n//         message: '🏁 Challenge stopped',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       toast.success('Challenge stopped');\n\n//     } catch (error) {\n//       errorLog('Challenge stop failed', error);\n//       toast.error('Error stopping challenge');\n//     }\n//   }, [challengeStatus.running, challengeInterval, motors, stopMotor, dispatch]);\n\n//   // Cleanup on unmount\n//   useEffect(() => {\n//     return () => {\n//       stopUptimeCounter();\n//       stopPeriodicMonitoring();\n//       if (challengeInterval) {\n//         clearInterval(challengeInterval);\n//       }\n//     };\n//   }, [stopUptimeCounter, stopPeriodicMonitoring, challengeInterval]);\n\n//   return {\n//     // Connection state\n//     isSupported,\n//     isConnected,\n//     connectionStatus: robotState.connectionStatus,\n\n//     // Motor state\n//     motors,\n//     connectedMotorCount: robotState.connectedMotorCount,\n\n//     // Challenge state\n//     challengeRunning: challengeStatus.running,\n//     challengeProgress: challengeStatus.progress,\n\n//     // Communication state\n//     logs: robotState.logs,\n//     commandCount: robotState.commandCount,\n//     uptime: robotState.uptime,\n\n//     // Control functions\n//     connect,\n//     disconnect,\n//     scanMotors,\n\n//     // Motor control\n//     enableTorque,\n//     disableTorque,\n//     setMotorPosition,\n//     setMotorVelocity,\n//     homeMotor,\n//     stopMotor,\n//     getMotorPosition,\n\n//     // Global control\n//     enableAllTorque,\n//     disableAllTorque,\n//     homeAllMotors,\n//     emergencyStop,\n\n//     // Challenge control\n//     startChallenge: startChallengeExecution,\n//     stopChallenge,\n//   };\n// };\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { updateRobotState, setConnectionStatus } from '../store/robotSlice';\n\n// Mock robot controller hook for development\nexport const useRobotController = () => {\n  _s();\n  const dispatch = useDispatch();\n  const {\n    connected,\n    connectionStatus\n  } = useSelector(state => state.robot);\n  const [currentAngles, setCurrentAngles] = useState([0, 0, 0]);\n  const [isSimulationMode, setIsSimulationMode] = useState(true);\n\n  // Mock connection status\n  const isConnected = connected || false;\n\n  // Simulate robot connection\n  useEffect(() => {\n    // Try to establish connection (mock)\n    const tryConnect = async () => {\n      try {\n        dispatch(setConnectionStatus('connecting'));\n\n        // Simulate connection attempt\n        await new Promise(resolve => setTimeout(resolve, 2000));\n\n        // For now, always fail to connect (simulation mode)\n        dispatch(setConnectionStatus('disconnected'));\n        setIsSimulationMode(true);\n        console.log('Robot controller initialized in simulation mode');\n      } catch (error) {\n        console.error('Failed to connect to robot:', error);\n        dispatch(setConnectionStatus('error'));\n        setIsSimulationMode(true);\n      }\n    };\n    tryConnect();\n  }, [dispatch]);\n\n  // Mock robot control functions\n  const disableTorque = useCallback(async () => {\n    try {\n      console.log('Disabling torque (simulation)');\n      // In simulation mode, just log\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error disabling torque:', error);\n      throw error;\n    }\n  }, []);\n  const enableTorque = useCallback(async () => {\n    try {\n      console.log('Enabling torque (simulation)');\n      // In simulation mode, just log\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error enabling torque:', error);\n      throw error;\n    }\n  }, []);\n  const getCurrentJointAngles = useCallback(async () => {\n    try {\n      // In simulation mode, return mock angles\n      if (isSimulationMode) {\n        // Simulate some random movement\n        const angles = currentAngles.map(angle => angle + (Math.random() - 0.5) * 10 // ±5 degree variation\n        );\n        setCurrentAngles(angles);\n        return angles.map(angle => angle * Math.PI / 180); // Convert to radians\n      }\n\n      // Real robot implementation would go here\n      return [0, 0, 0];\n    } catch (error) {\n      console.error('Error getting joint angles:', error);\n      return [0, 0, 0];\n    }\n  }, [currentAngles, isSimulationMode]);\n  const getRelativeJointAngles = useCallback(async () => {\n    try {\n      // In simulation mode, return mock relative angles\n      if (isSimulationMode) {\n        // For relative angles, we can just return the current angles\n        // as they represent relative positioning between joints\n        return currentAngles.map(angle => angle * Math.PI / 180); // Convert to radians\n      }\n\n      // Real robot implementation would go here\n      return [0, 0, 0];\n    } catch (error) {\n      console.error('Error getting relative joint angles:', error);\n      return [0, 0, 0];\n    }\n  }, [currentAngles, isSimulationMode]);\n  const moveToPosition = useCallback(async angles => {\n    try {\n      console.log('Moving to position (simulation):', angles);\n      if (isSimulationMode) {\n        // Simulate movement by updating current angles\n        setCurrentAngles(angles);\n      }\n\n      // Real robot implementation would go here\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error moving to position:', error);\n      throw error;\n    }\n  }, [isSimulationMode]);\n  const setVelocity = useCallback(async (motorId, velocity) => {\n    try {\n      console.log(`Setting velocity for motor ${motorId}: ${velocity} (simulation)`);\n      // Real robot implementation would go here\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error setting velocity:', error);\n      throw error;\n    }\n  }, []);\n  const emergencyStop = useCallback(async () => {\n    try {\n      console.log('Emergency stop activated (simulation)');\n      // In simulation, reset to safe position\n      setCurrentAngles([0, 0, 0]);\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error during emergency stop:', error);\n      throw error;\n    }\n  }, []);\n  const calibrate = useCallback(async () => {\n    try {\n      console.log('Calibrating robot (simulation)');\n      // Reset to home position\n      setCurrentAngles([0, 0, 0]);\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error during calibration:', error);\n      throw error;\n    }\n  }, []);\n  const startChallenge = useCallback(async challengeId => {\n    try {\n      console.log(`Starting challenge ${challengeId} (simulation)`);\n      dispatch(updateRobotState({\n        status: 'challenge_active',\n        currentChallenge: challengeId\n      }));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error starting challenge:', error);\n      throw error;\n    }\n  }, [dispatch]);\n  const stopChallenge = useCallback(async () => {\n    try {\n      console.log('Stopping challenge (simulation)');\n      dispatch(updateRobotState({\n        status: 'idle',\n        currentChallenge: null\n      }));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error stopping challenge:', error);\n      throw error;\n    }\n  }, [dispatch]);\n  return {\n    // Connection status\n    isConnected,\n    connectionStatus,\n    isSimulationMode,\n    // Current state\n    currentAngles,\n    // Control functions\n    disableTorque,\n    enableTorque,\n    getCurrentJointAngles,\n    getRelativeJointAngles,\n    moveToPosition,\n    setVelocity,\n    emergencyStop,\n    calibrate,\n    // Challenge functions\n    startChallenge,\n    stopChallenge,\n    // Mock robot specs for compatibility\n    robotSpecs: {\n      linkLengths: [0.10, 0.07, 0.05],\n      // meters\n      jointLimits: [{\n        min: -180,\n        max: 180\n      }, {\n        min: -90,\n        max: 90\n      }, {\n        min: -90,\n        max: 90\n      }],\n      maxVelocity: 50,\n      // degrees/second\n      precision: 0.1 // degrees\n    }\n  };\n};\n_s(useRobotController, \"qFZlR9Ztx1yr335UqYKb7p+DHJE=\", false, function () {\n  return [useDispatch, useSelector];\n});\nexport default useRobotController;","map":{"version":3,"names":["useState","useEffect","useCallback","useDispatch","useSelector","updateRobotState","setConnectionStatus","useRobotController","_s","dispatch","connected","connectionStatus","state","robot","currentAngles","setCurrentAngles","isSimulationMode","setIsSimulationMode","isConnected","tryConnect","Promise","resolve","setTimeout","console","log","error","disableTorque","enableTorque","getCurrentJointAngles","angles","map","angle","Math","random","PI","getRelativeJointAngles","moveToPosition","setVelocity","motorId","velocity","emergencyStop","calibrate","startChallenge","challengeId","status","currentChallenge","stopChallenge","robotSpecs","linkLengths","jointLimits","min","max","maxVelocity","precision"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/hooks/useRobotController.js"],"sourcesContent":["// import { useState, useEffect, useCallback, useRef } from 'react';\n// import { useDispatch, useSelector } from 'react-redux';\n// import { useWebSerial } from './useWebSerial';\n// import {\n//   updateConnectionStatus,\n//   setMotors,\n//   updateMotor,\n//   addMotor,\n//   removeMotor,\n//   updateChartData,\n//   addLogEntry,\n//   incrementCommandCount,\n//   updateUptime,\n//   startChallenge,\n//   stopChallenge as stopChallengeAction,\n//   updateChallengeProgress,\n//   updateHardwareStats,\n//   setEmergencyStop,\n//   selectRobot,\n//   selectIsConnected,\n//   selectMotors,\n//   selectChallengeStatus,\n// } from '../store/robotSlice';\n// import { \n//   rawToDegrees, \n//   degreesToPositionRaw, \n//   degreesToVelocityRaw \n// } from '../utils/robotUtils';\n// import { COMMANDS, ROBOT_SPECS, PERFORMANCE } from '../utils/constants';\n// import { now, clamp, throttle, debugLog, errorLog } from '../utils/helpers';\n// import toast from 'react-hot-toast';\n\n// export const useRobotController = () => {\n//   const dispatch = useDispatch();\n//   const robotState = useSelector(selectRobot);\n//   const isConnected = useSelector(selectIsConnected);\n//   const motors = useSelector(selectMotors);\n//   const challengeStatus = useSelector(selectChallengeStatus);\n  \n//   const { \n//     isSupported, \n//     connect: connectSerial, \n//     disconnect: disconnectSerial, \n//     sendCommand, \n//     pingMotor: serialPingMotor,\n//     emergencyStop: serialEmergencyStop \n//   } = useWebSerial();\n  \n//   const [connectionStartTime, setConnectionStartTime] = useState(null);\n//   const [challengeInterval, setChallengeInterval] = useState(null);\n//   const [uptimeInterval, setUptimeInterval] = useState(null);\n//   const [monitoringInterval, setMonitoringInterval] = useState(null);\n  \n//   const performanceRef = useRef({\n//     commandsSent: 0,\n//     commandsSuccessful: 0,\n//     lastPerformanceUpdate: now(),\n//   });\n\n//   // Connection management\n//   useEffect(() => {\n//     if (isConnected && !connectionStartTime) {\n//       setConnectionStartTime(now());\n//       startUptimeCounter();\n//       startPeriodicMonitoring();\n      \n//       // Auto-scan for motors after connection\n//       setTimeout(() => {\n//         scanMotors();\n//       }, 2000);\n      \n//     } else if (!isConnected && connectionStartTime) {\n//       setConnectionStartTime(null);\n//       stopUptimeCounter();\n//       stopPeriodicMonitoring();\n//       stopChallenge();\n//     }\n//   }, [isConnected, connectionStartTime]);\n\n//   // Uptime counter\n//   const startUptimeCounter = useCallback(() => {\n//     const interval = setInterval(() => {\n//       if (connectionStartTime) {\n//         const uptime = now() - connectionStartTime;\n//         dispatch(updateUptime(uptime));\n//       }\n//     }, 1000);\n//     setUptimeInterval(interval);\n//   }, [connectionStartTime, dispatch]);\n\n//   const stopUptimeCounter = useCallback(() => {\n//     if (uptimeInterval) {\n//       clearInterval(uptimeInterval);\n//       setUptimeInterval(null);\n//     }\n//   }, [uptimeInterval]);\n\n//   // Periodic monitoring\n//   const startPeriodicMonitoring = useCallback(() => {\n//     const interval = setInterval(async () => {\n//       if (!isConnected || motors.length === 0) return;\n\n//       try {\n//         // Monitor each connected motor\n//         for (const motor of motors) {\n//           if (motor.online) {\n//             // Get current position and temperature\n//             await updateMotorData(motor.id);\n//           }\n//         }\n        \n//         // Update performance metrics\n//         updatePerformanceMetrics();\n        \n//       } catch (error) {\n//         debugLog('Monitoring error:', error);\n//       }\n//     }, robotState.settings.updateRate || 1000);\n    \n//     setMonitoringInterval(interval);\n//   }, [isConnected, motors, robotState.settings.updateRate]);\n\n//   const stopPeriodicMonitoring = useCallback(() => {\n//     if (monitoringInterval) {\n//       clearInterval(monitoringInterval);\n//       setMonitoringInterval(null);\n//     }\n//   }, [monitoringInterval]);\n\n//   // Update motor data\n//   const updateMotorData = useCallback(async (motorId) => {\n//     try {\n//       // This would be implemented with actual sensor reading\n//       // For now, we'll simulate or use cached values\n      \n//       const motor = motors.find(m => m.id === motorId);\n//       if (!motor) return;\n\n//       // Simulate data updates (in real implementation, this would read from hardware)\n//       const currentTime = now();\n//       const timeDiff = currentTime - motor.lastUpdate;\n      \n//       if (timeDiff > 100) { // Update every 100ms\n//         const simulatedData = {\n//           position: motor.position + (Math.random() - 0.5) * 2, // Small random variation\n//           velocity: motor.velocity + (Math.random() - 0.5) * 5,\n//           temperature: 25 + Math.random() * 10,\n//           current: Math.random() * 0.5,\n//         };\n        \n//         dispatch(updateMotor({\n//           motorId,\n//           updates: {\n//             ...simulatedData,\n//             lastUpdate: currentTime,\n//           },\n//         }));\n        \n//         // Update chart data\n//         dispatch(updateChartData({\n//           time: currentTime,\n//           motorId,\n//           position: simulatedData.position,\n//           velocity: simulatedData.velocity,\n//           temperature: simulatedData.temperature,\n//           current: simulatedData.current,\n//         }));\n//       }\n      \n//     } catch (error) {\n//       errorLog(`Failed to update motor ${motorId} data`, error);\n//     }\n//   }, [motors, dispatch]);\n\n//   // Performance metrics update (throttled)\n//   const updatePerformanceMetrics = useCallback(\n//     throttle(() => {\n//       const now_time = now();\n//       const timeDiff = now_time - performanceRef.current.lastPerformanceUpdate;\n      \n//       if (timeDiff > 0) {\n//         const commandsPerSecond = (performanceRef.current.commandsSent / timeDiff) * 1000;\n//         const successRate = performanceRef.current.commandsSuccessful / performanceRef.current.commandsSent;\n        \n//         // Reset counters\n//         performanceRef.current.commandsSent = 0;\n//         performanceRef.current.commandsSuccessful = 0;\n//         performanceRef.current.lastPerformanceUpdate = now_time;\n        \n//         // Dispatch performance update if needed\n//         debugLog('Performance metrics:', { commandsPerSecond, successRate });\n//       }\n//     }, 5000), // Update every 5 seconds\n//     []\n//   );\n\n//   // Connect to robot\n//   const connect = useCallback(async () => {\n//     try {\n//       dispatch(addLogEntry({\n//         message: 'Attempting to connect to robot...',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       const success = await connectSerial();\n      \n//       if (success) {\n//         dispatch(addLogEntry({\n//           message: 'Successfully connected to robot',\n//           type: 'info',\n//           timestamp: now(),\n//         }));\n//         toast.success('Robot connected!');\n//       }\n      \n//       return success;\n//     } catch (error) {\n//       errorLog('Robot connection failed', error);\n//       dispatch(addLogEntry({\n//         message: `Connection failed: ${error.message}`,\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n//       toast.error('Connection failed');\n//       return false;\n//     }\n//   }, [connectSerial, dispatch]);\n\n//   // Disconnect from robot\n//   const disconnect = useCallback(async () => {\n//     try {\n//       // Stop any running challenge\n//       if (challengeStatus.running) {\n//         await stopChallenge();\n//       }\n      \n//       await disconnectSerial();\n      \n//       dispatch(addLogEntry({\n//         message: 'Disconnected from robot',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       toast.success('Robot disconnected');\n//     } catch (error) {\n//       errorLog('Disconnect error', error);\n//       toast.error('Disconnect error');\n//     }\n//   }, [disconnectSerial, challengeStatus.running, dispatch]);\n\n//   // Motor scanning\n//   const scanMotors = useCallback(async () => {\n//     if (!isConnected) {\n//       toast.error('Robot not connected');\n//       return;\n//     }\n\n//     dispatch(addLogEntry({\n//       message: 'Scanning for motors (ID 1-10)...',\n//       type: 'info',\n//       timestamp: now(),\n//     }));\n\n//     const detectedMotors = [];\n\n//     try {\n//       for (let id = 1; id <= 10; id++) {\n//         try {\n//           const isOnline = await serialPingMotor(id);\n          \n//           if (isOnline) {\n//             const motor = {\n//               id,\n//               model: ROBOT_SPECS.MODEL,\n//               status: 'online',\n//               online: true,\n//               torqueEnabled: false,\n//               position: ROBOT_SPECS.MAX_POSITION / 2,\n//               velocity: 0,\n//               goalPosition: ROBOT_SPECS.MAX_POSITION / 2,\n//               goalVelocity: 0,\n//               temperature: 25,\n//               voltage: 7.0,\n//               current: 0.0,\n//               load: 0,\n//               lastUpdate: now(),\n//               operatingMode: 3, // Position mode\n//             };\n            \n//             detectedMotors.push(motor);\n            \n//             dispatch(addLogEntry({\n//               message: `✅ Motor ${id} detected`,\n//               type: 'info',\n//               timestamp: now(),\n//             }));\n//           }\n          \n//           // Small delay between pings\n//           await new Promise(resolve => setTimeout(resolve, 200));\n          \n//         } catch (error) {\n//           debugLog(`Motor ${id} scan failed:`, error);\n//         }\n//       }\n\n//       dispatch(setMotors(detectedMotors));\n      \n//       const message = `Scan complete. Found ${detectedMotors.length} motors.`;\n//       dispatch(addLogEntry({\n//         message,\n//         type: detectedMotors.length > 0 ? 'info' : 'warning',\n//         timestamp: now(),\n//       }));\n      \n//       if (detectedMotors.length === 0) {\n//         toast.error('No motors detected. Check connections and power.');\n//       } else {\n//         toast.success(`Found ${detectedMotors.length} motors`);\n//       }\n      \n//     } catch (error) {\n//       errorLog('Motor scan failed', error);\n//       dispatch(addLogEntry({\n//         message: `Motor scan failed: ${error.message}`,\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n//       toast.error('Motor scan failed');\n//     }\n//   }, [isConnected, serialPingMotor, dispatch]);\n\n//   // Motor control functions\n//   const enableTorque = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.ENABLE_TORQUE}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { torqueEnabled: true }\n//       }));\n      \n//       dispatch(addLogEntry({\n//         message: `Torque enabled for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to enable torque for motor ${motorId}`, error);\n//       toast.error(`Failed to enable motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const disableTorque = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.DISABLE_TORQUE}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { torqueEnabled: false }\n//       }));\n      \n//       dispatch(addLogEntry({\n//         message: `Torque disabled for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to disable torque for motor ${motorId}`, error);\n//       toast.error(`Failed to disable motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const setMotorPosition = useCallback(async (motorId, degrees) => {\n//     try {\n//       const positionRaw = degreesToPositionRaw(degrees);\n//       const clampedPosition = clamp(positionRaw, 0, ROBOT_SPECS.MAX_POSITION);\n      \n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.SET_POSITION}:${motorId}:${clampedPosition}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { \n//           goalPosition: rawToDegrees(clampedPosition),\n//           position: rawToDegrees(clampedPosition) // Immediate update for UI responsiveness\n//         }\n//       }));\n      \n//       dispatch(addLogEntry({\n//         message: `Motor ${motorId} position set to ${degrees.toFixed(1)}° (raw: ${clampedPosition})`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to set position for motor ${motorId}`, error);\n//       toast.error(`Failed to move motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const setMotorVelocity = useCallback(async (motorId, degreesPerSec) => {\n//     try {\n//       const velocityRaw = degreesToVelocityRaw(degreesPerSec);\n//       const clampedVelocity = clamp(velocityRaw, ROBOT_SPECS.MIN_VELOCITY, ROBOT_SPECS.MAX_VELOCITY);\n      \n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.SET_VELOCITY}:${motorId}:${clampedVelocity}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { \n//           goalVelocity: degreesPerSec,\n//           velocity: degreesPerSec // Immediate update\n//         }\n//       }));\n      \n//       dispatch(addLogEntry({\n//         message: `Motor ${motorId} velocity set to ${degreesPerSec.toFixed(1)}°/s (raw: ${clampedVelocity})`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to set velocity for motor ${motorId}`, error);\n//       toast.error(`Failed to set velocity for motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const homeMotor = useCallback(async (motorId) => {\n//     const homePosition = 180; // Center position in degrees\n//     return await setMotorPosition(motorId, homePosition);\n//   }, [setMotorPosition]);\n\n//   const stopMotor = useCallback(async (motorId) => {\n//     return await setMotorVelocity(motorId, 0);\n//   }, [setMotorVelocity]);\n\n//   const getMotorPosition = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(addLogEntry({\n//         message: `Reading position for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to get position for motor ${motorId}`, error);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   // Global control functions\n//   const enableAllTorque = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n//     let successCount = 0;\n    \n//     for (const motor of onlineMotors) {\n//       const success = await enableTorque(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n    \n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors enabled');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors enabled`);\n//     }\n//   }, [motors, enableTorque]);\n\n//   const disableAllTorque = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n//     let successCount = 0;\n    \n//     for (const motor of onlineMotors) {\n//       const success = await disableTorque(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n    \n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors disabled');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors disabled`);\n//     }\n//   }, [motors, disableTorque]);\n\n//   const homeAllMotors = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n    \n//     dispatch(addLogEntry({\n//       message: 'Moving all motors to home position...',\n//       type: 'info',\n//       timestamp: now(),\n//     }));\n    \n//     let successCount = 0;\n    \n//     for (const motor of onlineMotors) {\n//       const success = await homeMotor(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n    \n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors homed');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors homed`);\n//     }\n//   }, [motors, homeMotor, dispatch]);\n\n//   const emergencyStop = useCallback(async () => {\n//     try {\n//       dispatch(addLogEntry({\n//         message: '🛑 EMERGENCY STOP ACTIVATED',\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(setEmergencyStop(true));\n      \n//       // Stop serial communication emergency stop\n//       await serialEmergencyStop();\n      \n//       // Stop any running challenge\n//       if (challengeStatus.running) {\n//         stopChallenge();\n//       }\n      \n//       toast.error('Emergency stop activated!');\n      \n//     } catch (error) {\n//       errorLog('Emergency stop failed', error);\n//       toast.error('Emergency stop failed!');\n//     }\n//   }, [serialEmergencyStop, challengeStatus.running, dispatch]);\n\n//   // Challenge execution\n//   const startChallengeExecution = useCallback(async (challengeParams) => {\n//     if (!isConnected || challengeStatus.running) {\n//       toast.error('Cannot start challenge: Robot not ready');\n//       return false;\n//     }\n\n//     const requiredMotors = challengeParams.requiredMotors || [1, 2];\n//     const availableMotors = motors.filter(m => \n//       requiredMotors.includes(m.id) && m.online\n//     );\n\n//     if (availableMotors.length < requiredMotors.length) {\n//       toast.error(`Challenge requires motors ${requiredMotors.join(', ')} to be connected`);\n//       return false;\n//     }\n\n//     try {\n//       dispatch(startChallenge(challengeParams));\n      \n//       dispatch(addLogEntry({\n//         message: '🚀 Challenge started successfully',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       toast.success('Challenge started!');\n//       return true;\n      \n//     } catch (error) {\n//       errorLog('Challenge start failed', error);\n//       toast.error('Failed to start challenge');\n//       return false;\n//     }\n//   }, [isConnected, challengeStatus.running, motors, dispatch]);\n\n//   const stopChallenge = useCallback(async () => {\n//     if (!challengeStatus.running) return;\n\n//     try {\n//       // Stop challenge interval if running\n//       if (challengeInterval) {\n//         clearInterval(challengeInterval);\n//         setChallengeInterval(null);\n//       }\n\n//       // Stop all motors\n//       const onlineMotors = motors.filter(m => m.online);\n//       for (const motor of onlineMotors) {\n//         await stopMotor(motor.id);\n//       }\n      \n//       dispatch(stopChallengeAction());\n      \n//       dispatch(addLogEntry({\n//         message: '🏁 Challenge stopped',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       toast.success('Challenge stopped');\n      \n//     } catch (error) {\n//       errorLog('Challenge stop failed', error);\n//       toast.error('Error stopping challenge');\n//     }\n//   }, [challengeStatus.running, challengeInterval, motors, stopMotor, dispatch]);\n\n//   // Cleanup on unmount\n//   useEffect(() => {\n//     return () => {\n//       stopUptimeCounter();\n//       stopPeriodicMonitoring();\n//       if (challengeInterval) {\n//         clearInterval(challengeInterval);\n//       }\n//     };\n//   }, [stopUptimeCounter, stopPeriodicMonitoring, challengeInterval]);\n\n//   return {\n//     // Connection state\n//     isSupported,\n//     isConnected,\n//     connectionStatus: robotState.connectionStatus,\n    \n//     // Motor state\n//     motors,\n//     connectedMotorCount: robotState.connectedMotorCount,\n    \n//     // Challenge state\n//     challengeRunning: challengeStatus.running,\n//     challengeProgress: challengeStatus.progress,\n    \n//     // Communication state\n//     logs: robotState.logs,\n//     commandCount: robotState.commandCount,\n//     uptime: robotState.uptime,\n    \n//     // Control functions\n//     connect,\n//     disconnect,\n//     scanMotors,\n    \n//     // Motor control\n//     enableTorque,\n//     disableTorque,\n//     setMotorPosition,\n//     setMotorVelocity,\n//     homeMotor,\n//     stopMotor,\n//     getMotorPosition,\n    \n//     // Global control\n//     enableAllTorque,\n//     disableAllTorque,\n//     homeAllMotors,\n//     emergencyStop,\n    \n//     // Challenge control\n//     startChallenge: startChallengeExecution,\n//     stopChallenge,\n//   };\n// };\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { updateRobotState, setConnectionStatus } from '../store/robotSlice';\n\n// Mock robot controller hook for development\nexport const useRobotController = () => {\n  const dispatch = useDispatch();\n  const { connected, connectionStatus } = useSelector(state => state.robot);\n  \n  const [currentAngles, setCurrentAngles] = useState([0, 0, 0]);\n  const [isSimulationMode, setIsSimulationMode] = useState(true);\n\n  // Mock connection status\n  const isConnected = connected || false;\n\n  // Simulate robot connection\n  useEffect(() => {\n    // Try to establish connection (mock)\n    const tryConnect = async () => {\n      try {\n        dispatch(setConnectionStatus('connecting'));\n        \n        // Simulate connection attempt\n        await new Promise(resolve => setTimeout(resolve, 2000));\n        \n        // For now, always fail to connect (simulation mode)\n        dispatch(setConnectionStatus('disconnected'));\n        setIsSimulationMode(true);\n        \n        console.log('Robot controller initialized in simulation mode');\n      } catch (error) {\n        console.error('Failed to connect to robot:', error);\n        dispatch(setConnectionStatus('error'));\n        setIsSimulationMode(true);\n      }\n    };\n\n    tryConnect();\n  }, [dispatch]);\n\n  // Mock robot control functions\n  const disableTorque = useCallback(async () => {\n    try {\n      console.log('Disabling torque (simulation)');\n      // In simulation mode, just log\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error disabling torque:', error);\n      throw error;\n    }\n  }, []);\n\n  const enableTorque = useCallback(async () => {\n    try {\n      console.log('Enabling torque (simulation)');\n      // In simulation mode, just log\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error enabling torque:', error);\n      throw error;\n    }\n  }, []);\n\n  const getCurrentJointAngles = useCallback(async () => {\n    try {\n      // In simulation mode, return mock angles\n      if (isSimulationMode) {\n        // Simulate some random movement\n        const angles = currentAngles.map(angle => \n          angle + (Math.random() - 0.5) * 10 // ±5 degree variation\n        );\n        setCurrentAngles(angles);\n        return angles.map(angle => angle * Math.PI / 180); // Convert to radians\n      }\n      \n      // Real robot implementation would go here\n      return [0, 0, 0];\n    } catch (error) {\n      console.error('Error getting joint angles:', error);\n      return [0, 0, 0];\n    }\n  }, [currentAngles, isSimulationMode]);\n\n  const getRelativeJointAngles = useCallback(async () => {\n    try {\n      // In simulation mode, return mock relative angles\n      if (isSimulationMode) {\n        // For relative angles, we can just return the current angles\n        // as they represent relative positioning between joints\n        return currentAngles.map(angle => angle * Math.PI / 180); // Convert to radians\n      }\n      \n      // Real robot implementation would go here\n      return [0, 0, 0];\n    } catch (error) {\n      console.error('Error getting relative joint angles:', error);\n      return [0, 0, 0];\n    }\n  }, [currentAngles, isSimulationMode]);\n\n  const moveToPosition = useCallback(async (angles) => {\n    try {\n      console.log('Moving to position (simulation):', angles);\n      \n      if (isSimulationMode) {\n        // Simulate movement by updating current angles\n        setCurrentAngles(angles);\n      }\n      \n      // Real robot implementation would go here\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error moving to position:', error);\n      throw error;\n    }\n  }, [isSimulationMode]);\n\n  const setVelocity = useCallback(async (motorId, velocity) => {\n    try {\n      console.log(`Setting velocity for motor ${motorId}: ${velocity} (simulation)`);\n      // Real robot implementation would go here\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error setting velocity:', error);\n      throw error;\n    }\n  }, []);\n\n  const emergencyStop = useCallback(async () => {\n    try {\n      console.log('Emergency stop activated (simulation)');\n      // In simulation, reset to safe position\n      setCurrentAngles([0, 0, 0]);\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error during emergency stop:', error);\n      throw error;\n    }\n  }, []);\n\n  const calibrate = useCallback(async () => {\n    try {\n      console.log('Calibrating robot (simulation)');\n      // Reset to home position\n      setCurrentAngles([0, 0, 0]);\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error during calibration:', error);\n      throw error;\n    }\n  }, []);\n\n  const startChallenge = useCallback(async (challengeId) => {\n    try {\n      console.log(`Starting challenge ${challengeId} (simulation)`);\n      dispatch(updateRobotState({ \n        status: 'challenge_active',\n        currentChallenge: challengeId \n      }));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error starting challenge:', error);\n      throw error;\n    }\n  }, [dispatch]);\n\n  const stopChallenge = useCallback(async () => {\n    try {\n      console.log('Stopping challenge (simulation)');\n      dispatch(updateRobotState({ \n        status: 'idle',\n        currentChallenge: null \n      }));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error stopping challenge:', error);\n      throw error;\n    }\n  }, [dispatch]);\n\n  return {\n    // Connection status\n    isConnected,\n    connectionStatus,\n    isSimulationMode,\n    \n    // Current state\n    currentAngles,\n    \n    // Control functions\n    disableTorque,\n    enableTorque,\n    getCurrentJointAngles,\n    getRelativeJointAngles,\n    moveToPosition,\n    setVelocity,\n    emergencyStop,\n    calibrate,\n    \n    // Challenge functions\n    startChallenge,\n    stopChallenge,\n    \n    // Mock robot specs for compatibility\n    robotSpecs: {\n      linkLengths: [0.10, 0.07, 0.05], // meters\n      jointLimits: [\n        { min: -180, max: 180 },\n        { min: -90, max: 90 },\n        { min: -90, max: 90 }\n      ],\n      maxVelocity: 50, // degrees/second\n      precision: 0.1 // degrees\n    }\n  };\n};\n\nexport default useRobotController;"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AACxD,SAASC,WAAW,EAAEC,WAAW,QAAQ,aAAa;AACtD,SAASC,gBAAgB,EAAEC,mBAAmB,QAAQ,qBAAqB;;AAE3E;AACA,OAAO,MAAMC,kBAAkB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACtC,MAAMC,QAAQ,GAAGN,WAAW,CAAC,CAAC;EAC9B,MAAM;IAAEO,SAAS;IAAEC;EAAiB,CAAC,GAAGP,WAAW,CAACQ,KAAK,IAAIA,KAAK,CAACC,KAAK,CAAC;EAEzE,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGf,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EAC7D,MAAM,CAACgB,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGjB,QAAQ,CAAC,IAAI,CAAC;;EAE9D;EACA,MAAMkB,WAAW,GAAGR,SAAS,IAAI,KAAK;;EAEtC;EACAT,SAAS,CAAC,MAAM;IACd;IACA,MAAMkB,UAAU,GAAG,MAAAA,CAAA,KAAY;MAC7B,IAAI;QACFV,QAAQ,CAACH,mBAAmB,CAAC,YAAY,CAAC,CAAC;;QAE3C;QACA,MAAM,IAAIc,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;;QAEvD;QACAZ,QAAQ,CAACH,mBAAmB,CAAC,cAAc,CAAC,CAAC;QAC7CW,mBAAmB,CAAC,IAAI,CAAC;QAEzBM,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;MAChE,CAAC,CAAC,OAAOC,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;QACnDhB,QAAQ,CAACH,mBAAmB,CAAC,OAAO,CAAC,CAAC;QACtCW,mBAAmB,CAAC,IAAI,CAAC;MAC3B;IACF,CAAC;IAEDE,UAAU,CAAC,CAAC;EACd,CAAC,EAAE,CAACV,QAAQ,CAAC,CAAC;;EAEd;EACA,MAAMiB,aAAa,GAAGxB,WAAW,CAAC,YAAY;IAC5C,IAAI;MACFqB,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;MAC5C;MACA,OAAOJ,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAME,YAAY,GAAGzB,WAAW,CAAC,YAAY;IAC3C,IAAI;MACFqB,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC;MAC3C;MACA,OAAOJ,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMG,qBAAqB,GAAG1B,WAAW,CAAC,YAAY;IACpD,IAAI;MACF;MACA,IAAIc,gBAAgB,EAAE;QACpB;QACA,MAAMa,MAAM,GAAGf,aAAa,CAACgB,GAAG,CAACC,KAAK,IACpCA,KAAK,GAAG,CAACC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,IAAI,EAAE,CAAC;QACrC,CAAC;QACDlB,gBAAgB,CAACc,MAAM,CAAC;QACxB,OAAOA,MAAM,CAACC,GAAG,CAACC,KAAK,IAAIA,KAAK,GAAGC,IAAI,CAACE,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;MACrD;;MAEA;MACA,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAClB,CAAC,CAAC,OAAOT,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnD,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAClB;EACF,CAAC,EAAE,CAACX,aAAa,EAAEE,gBAAgB,CAAC,CAAC;EAErC,MAAMmB,sBAAsB,GAAGjC,WAAW,CAAC,YAAY;IACrD,IAAI;MACF;MACA,IAAIc,gBAAgB,EAAE;QACpB;QACA;QACA,OAAOF,aAAa,CAACgB,GAAG,CAACC,KAAK,IAAIA,KAAK,GAAGC,IAAI,CAACE,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;MAC5D;;MAEA;MACA,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAClB,CAAC,CAAC,OAAOT,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;MAC5D,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAClB;EACF,CAAC,EAAE,CAACX,aAAa,EAAEE,gBAAgB,CAAC,CAAC;EAErC,MAAMoB,cAAc,GAAGlC,WAAW,CAAC,MAAO2B,MAAM,IAAK;IACnD,IAAI;MACFN,OAAO,CAACC,GAAG,CAAC,kCAAkC,EAAEK,MAAM,CAAC;MAEvD,IAAIb,gBAAgB,EAAE;QACpB;QACAD,gBAAgB,CAACc,MAAM,CAAC;MAC1B;;MAEA;MACA,OAAOT,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,CAACT,gBAAgB,CAAC,CAAC;EAEtB,MAAMqB,WAAW,GAAGnC,WAAW,CAAC,OAAOoC,OAAO,EAAEC,QAAQ,KAAK;IAC3D,IAAI;MACFhB,OAAO,CAACC,GAAG,CAAC,8BAA8Bc,OAAO,KAAKC,QAAQ,eAAe,CAAC;MAC9E;MACA,OAAOnB,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMe,aAAa,GAAGtC,WAAW,CAAC,YAAY;IAC5C,IAAI;MACFqB,OAAO,CAACC,GAAG,CAAC,uCAAuC,CAAC;MACpD;MACAT,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAC3B,OAAOK,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMgB,SAAS,GAAGvC,WAAW,CAAC,YAAY;IACxC,IAAI;MACFqB,OAAO,CAACC,GAAG,CAAC,gCAAgC,CAAC;MAC7C;MACAT,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAC3B,OAAOK,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMiB,cAAc,GAAGxC,WAAW,CAAC,MAAOyC,WAAW,IAAK;IACxD,IAAI;MACFpB,OAAO,CAACC,GAAG,CAAC,sBAAsBmB,WAAW,eAAe,CAAC;MAC7DlC,QAAQ,CAACJ,gBAAgB,CAAC;QACxBuC,MAAM,EAAE,kBAAkB;QAC1BC,gBAAgB,EAAEF;MACpB,CAAC,CAAC,CAAC;MACH,OAAOvB,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,CAAChB,QAAQ,CAAC,CAAC;EAEd,MAAMqC,aAAa,GAAG5C,WAAW,CAAC,YAAY;IAC5C,IAAI;MACFqB,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;MAC9Cf,QAAQ,CAACJ,gBAAgB,CAAC;QACxBuC,MAAM,EAAE,MAAM;QACdC,gBAAgB,EAAE;MACpB,CAAC,CAAC,CAAC;MACH,OAAOzB,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,CAAChB,QAAQ,CAAC,CAAC;EAEd,OAAO;IACL;IACAS,WAAW;IACXP,gBAAgB;IAChBK,gBAAgB;IAEhB;IACAF,aAAa;IAEb;IACAY,aAAa;IACbC,YAAY;IACZC,qBAAqB;IACrBO,sBAAsB;IACtBC,cAAc;IACdC,WAAW;IACXG,aAAa;IACbC,SAAS;IAET;IACAC,cAAc;IACdI,aAAa;IAEb;IACAC,UAAU,EAAE;MACVC,WAAW,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;MAAE;MACjCC,WAAW,EAAE,CACX;QAAEC,GAAG,EAAE,CAAC,GAAG;QAAEC,GAAG,EAAE;MAAI,CAAC,EACvB;QAAED,GAAG,EAAE,CAAC,EAAE;QAAEC,GAAG,EAAE;MAAG,CAAC,EACrB;QAAED,GAAG,EAAE,CAAC,EAAE;QAAEC,GAAG,EAAE;MAAG,CAAC,CACtB;MACDC,WAAW,EAAE,EAAE;MAAE;MACjBC,SAAS,EAAE,GAAG,CAAC;IACjB;EACF,CAAC;AACH,CAAC;AAAC7C,EAAA,CAlNWD,kBAAkB;EAAA,QACZJ,WAAW,EACYC,WAAW;AAAA;AAkNrD,eAAeG,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}