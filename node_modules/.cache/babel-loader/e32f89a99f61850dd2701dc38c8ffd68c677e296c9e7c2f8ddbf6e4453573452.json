{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { robotService } from '../services/robotService';\nimport { websocketService } from '../services/websocketService';\nimport { setRobotData, setConnectionStatus, setExecutionState } from '../store/robotSlice';\nexport const useRobotController = () => {\n  _s();\n  const dispatch = useDispatch();\n  const {\n    robot,\n    isConnected\n  } = useSelector(state => state.robot);\n  const [isExecuting, setIsExecuting] = useState(false);\n  const [executionResults, setExecutionResults] = useState(null);\n  const [error, setError] = useState(null);\n  const [telemetryData, setTelemetryData] = useState(null);\n\n  // WebSocket connection for real-time updates\n  const wsRef = useRef(null);\n  const telemetryIntervalRef = useRef(null);\n\n  // Initialize WebSocket connection\n  useEffect(() => {\n    if (isConnected && !wsRef.current) {\n      initializeWebSocket();\n    }\n    return () => {\n      cleanupWebSocket();\n    };\n  }, [isConnected]);\n  const initializeWebSocket = useCallback(() => {\n    try {\n      wsRef.current = websocketService.connect({\n        onMessage: handleWebSocketMessage,\n        onError: handleWebSocketError,\n        onClose: handleWebSocketClose,\n        onOpen: handleWebSocketOpen\n      });\n    } catch (error) {\n      console.error('Failed to initialize WebSocket:', error);\n      setError('WebSocket connection failed');\n    }\n  }, []);\n  const cleanupWebSocket = useCallback(() => {\n    if (wsRef.current) {\n      websocketService.disconnect();\n      wsRef.current = null;\n    }\n    if (telemetryIntervalRef.current) {\n      clearInterval(telemetryIntervalRef.current);\n      telemetryIntervalRef.current = null;\n    }\n  }, []);\n\n  // WebSocket event handlers\n  const handleWebSocketOpen = useCallback(() => {\n    console.log('Robot WebSocket connected');\n    startTelemetryUpdates();\n  }, []);\n  const handleWebSocketClose = useCallback(() => {\n    console.log('Robot WebSocket disconnected');\n    dispatch(setConnectionStatus(false));\n    cleanupWebSocket();\n  }, [dispatch]);\n  const handleWebSocketError = useCallback(error => {\n    console.error('Robot WebSocket error:', error);\n    setError('Real-time communication error');\n  }, []);\n  const handleWebSocketMessage = useCallback(message => {\n    try {\n      const data = JSON.parse(message);\n      switch (data.type) {\n        case 'robot_telemetry':\n          handleTelemetryUpdate(data.payload);\n          break;\n        case 'execution_result':\n          handleExecutionResult(data.payload);\n          break;\n        case 'execution_progress':\n          handleExecutionProgress(data.payload);\n          break;\n        case 'error':\n          handleExecutionError(data.payload);\n          break;\n        case 'robot_status':\n          handleRobotStatusUpdate(data.payload);\n          break;\n        default:\n          console.log('Unknown WebSocket message type:', data.type);\n      }\n    } catch (error) {\n      console.error('Failed to parse WebSocket message:', error);\n    }\n  }, []);\n\n  // Handle real-time telemetry updates\n  const handleTelemetryUpdate = useCallback(telemetry => {\n    const robotData = {\n      joint_angles: telemetry.joint_angles || [0, 0, 0],\n      joint_velocities: telemetry.joint_velocities || [0, 0, 0],\n      joint_currents: telemetry.joint_currents || [0, 0, 0],\n      joint_temperatures: telemetry.joint_temperatures || [25, 25, 25],\n      end_effector_position: telemetry.end_effector_position || {\n        x: 0,\n        y: 0,\n        z: 0\n      },\n      system_status: telemetry.system_status || 'operational',\n      timestamp: telemetry.timestamp || new Date().toISOString()\n    };\n    dispatch(setRobotData(robotData));\n    setTelemetryData(robotData);\n  }, [dispatch]);\n\n  // Handle code execution results\n  const handleExecutionResult = useCallback(result => {\n    setIsExecuting(false);\n    setExecutionResults(result);\n    dispatch(setExecutionState({\n      isExecuting: false,\n      lastExecution: {\n        success: result.success,\n        timestamp: new Date().toISOString(),\n        error: result.error,\n        metrics: result.metrics\n      }\n    }));\n  }, [dispatch]);\n\n  // Handle execution progress updates\n  const handleExecutionProgress = useCallback(progress => {\n    dispatch(setExecutionState({\n      isExecuting: true,\n      executionProgress: progress\n    }));\n  }, [dispatch]);\n\n  // Handle execution errors\n  const handleExecutionError = useCallback(error => {\n    setIsExecuting(false);\n    setError(error.message || 'Execution failed');\n    dispatch(setExecutionState({\n      isExecuting: false,\n      lastExecution: {\n        success: false,\n        timestamp: new Date().toISOString(),\n        error: error.message\n      }\n    }));\n  }, [dispatch]);\n\n  // Handle robot status updates\n  const handleRobotStatusUpdate = useCallback(status => {\n    if (!status.connected) {\n      dispatch(setConnectionStatus(false));\n    }\n  }, [dispatch]);\n\n  // Start periodic telemetry updates\n  const startTelemetryUpdates = useCallback(() => {\n    if (telemetryIntervalRef.current) {\n      clearInterval(telemetryIntervalRef.current);\n    }\n    telemetryIntervalRef.current = setInterval(async () => {\n      try {\n        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n          wsRef.current.send(JSON.stringify({\n            type: 'request_telemetry',\n            timestamp: new Date().toISOString()\n          }));\n        }\n      } catch (error) {\n        console.error('Failed to request telemetry:', error);\n      }\n    }, 100); // 10Hz update rate\n  }, []);\n\n  // Execute Python code\n  const executeCode = useCallback(async (code, options = {}) => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n    if (isExecuting) {\n      throw new Error('Code execution already in progress');\n    }\n    setIsExecuting(true);\n    setError(null);\n    setExecutionResults(null);\n    try {\n      // Send execution request via WebSocket for real-time updates\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'execute_code',\n          payload: {\n            code,\n            language: 'python',\n            options: {\n              challengeId: options.challengeId,\n              targetPosition: options.targetPosition,\n              safetyEnabled: options.safetyEnabled !== false,\n              maxExecutionTime: options.maxExecutionTime || 30000,\n              // 30 seconds default\n              ...options\n            },\n            timestamp: new Date().toISOString()\n          }\n        }));\n\n        // Return a promise that resolves when execution completes\n        return new Promise((resolve, reject) => {\n          const timeout = setTimeout(() => {\n            setIsExecuting(false);\n            reject(new Error('Code execution timeout'));\n          }, options.maxExecutionTime || 30000);\n          const checkResult = () => {\n            if (executionResults) {\n              clearTimeout(timeout);\n              resolve(executionResults);\n            } else if (!isExecuting && error) {\n              clearTimeout(timeout);\n              reject(new Error(error));\n            } else if (isExecuting) {\n              setTimeout(checkResult, 100);\n            }\n          };\n          checkResult();\n        });\n      } else {\n        // Fallback to HTTP API if WebSocket not available\n        const result = await robotService.executeCode(code, options);\n        setIsExecuting(false);\n        setExecutionResults(result);\n        return result;\n      }\n    } catch (error) {\n      setIsExecuting(false);\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected, isExecuting, executionResults, error]);\n\n  // Measure current robot position\n  const measurePosition = useCallback(async () => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n    try {\n      const position = await robotService.getCurrentPosition();\n\n      // Also request via WebSocket for real-time update\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'request_position',\n          timestamp: new Date().toISOString()\n        }));\n      }\n      return position;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Move individual joint\n  const moveJoint = useCallback(async (jointId, angle, options = {}) => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n    try {\n      const result = await robotService.moveJoint(jointId, angle, options);\n\n      // Send via WebSocket for real-time tracking\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'move_joint',\n          payload: {\n            jointId,\n            angle,\n            speed: options.speed || 50,\n            acceleration: options.acceleration || 50\n          },\n          timestamp: new Date().toISOString()\n        }));\n      }\n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Move to target position\n  const moveToPosition = useCallback(async (targetAngles, options = {}) => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n    try {\n      const result = await robotService.moveToPosition(targetAngles, options);\n\n      // Send via WebSocket for real-time tracking\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'move_to_position',\n          payload: {\n            targetAngles,\n            speed: options.speed || 50,\n            acceleration: options.acceleration || 50,\n            trajectory: options.trajectory || 'linear'\n          },\n          timestamp: new Date().toISOString()\n        }));\n      }\n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Emergency stop\n  const emergencyStop = useCallback(async () => {\n    try {\n      // Send emergency stop via both WebSocket and HTTP for redundancy\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'emergency_stop',\n          timestamp: new Date().toISOString()\n        }));\n      }\n      const result = await robotService.emergencyStop();\n      setIsExecuting(false);\n      setError(null);\n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, []);\n\n  // Connect to robot\n  const connect = useCallback(async () => {\n    try {\n      const result = await robotService.connect();\n      if (result.success) {\n        dispatch(setConnectionStatus(true));\n        initializeWebSocket();\n      } else {\n        throw new Error(result.error || 'Connection failed');\n      }\n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [dispatch, initializeWebSocket]);\n\n  // Disconnect from robot\n  const disconnect = useCallback(async () => {\n    try {\n      cleanupWebSocket();\n      const result = await robotService.disconnect();\n      dispatch(setConnectionStatus(false));\n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [dispatch, cleanupWebSocket]);\n\n  // Get robot status\n  const getRobotStatus = useCallback(async () => {\n    try {\n      const status = await robotService.getStatus();\n      return status;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, []);\n\n  // Calibrate robot\n  const calibrate = useCallback(async (options = {}) => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n    try {\n      const result = await robotService.calibrate(options);\n\n      // Send via WebSocket for real-time updates\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'start_calibration',\n          payload: options,\n          timestamp: new Date().toISOString()\n        }));\n      }\n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Reset robot to home position\n  const resetToHome = useCallback(async () => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n    try {\n      const result = await robotService.resetToHome();\n\n      // Send via WebSocket for real-time tracking\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'reset_to_home',\n          timestamp: new Date().toISOString()\n        }));\n      }\n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Calculate forward kinematics\n  const calculateForwardKinematics = useCallback(jointAngles => {\n    try {\n      // Robot link lengths (in pixels for visualization)\n      const L1 = 140,\n        L2 = 120,\n        L3 = 100;\n      const [θ1, θ2, θ3] = jointAngles.map(angle => angle * Math.PI / 180);\n\n      // Calculate joint positions\n      const positions = [{\n        x: 0,\n        y: 0\n      },\n      // Base\n      {\n        x: L1 * Math.cos(θ1),\n        y: L1 * Math.sin(θ1)\n      },\n      // Joint 1\n      {\n        x: L1 * Math.cos(θ1) + L2 * Math.cos(θ1 + θ2),\n        y: L1 * Math.sin(θ1) + L2 * Math.sin(θ1 + θ2)\n      },\n      // Joint 2\n      {\n        x: L1 * Math.cos(θ1) + L2 * Math.cos(θ1 + θ2) + L3 * Math.cos(θ1 + θ2 + θ3),\n        y: L1 * Math.sin(θ1) + L2 * Math.sin(θ1 + θ2) + L3 * Math.sin(θ1 + θ2 + θ3)\n      } // End effector\n      ];\n      return positions;\n    } catch (error) {\n      console.error('Forward kinematics calculation error:', error);\n      return [{\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: 0\n      }];\n    }\n  }, []);\n\n  // Calculate position error\n  const calculatePositionError = useCallback((currentAngles, targetAngles) => {\n    if (!currentAngles || !targetAngles) return 0;\n    const errors = currentAngles.map((angle, i) => Math.abs(angle - (targetAngles[i] || 0)));\n    return Math.max(...errors);\n  }, []);\n\n  // Get workspace boundaries\n  const getWorkspaceBoundaries = useCallback(() => {\n    const L1 = 140,\n      L2 = 120,\n      L3 = 100;\n    return {\n      maxReach: L1 + L2 + L3,\n      minReach: Math.max(0, Math.abs(L1 - L2 - L3)),\n      jointLimits: [{\n        min: -150,\n        max: 150\n      },\n      // Joint 1\n      {\n        min: -120,\n        max: 120\n      },\n      // Joint 2\n      {\n        min: -90,\n        max: 90\n      } // Joint 3\n      ]\n    };\n  }, []);\n\n  // Clear errors\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  // Clear execution results\n  const clearExecutionResults = useCallback(() => {\n    setExecutionResults(null);\n  }, []);\n  return {\n    // State\n    isConnected,\n    isExecuting,\n    error,\n    executionResults,\n    telemetryData,\n    robotData: robot,\n    // Control functions\n    executeCode,\n    measurePosition,\n    moveJoint,\n    moveToPosition,\n    emergencyStop,\n    connect,\n    disconnect,\n    getRobotStatus,\n    calibrate,\n    resetToHome,\n    // Utility functions\n    calculateForwardKinematics,\n    calculatePositionError,\n    getWorkspaceBoundaries,\n    clearError,\n    clearExecutionResults\n  };\n};\n_s(useRobotController, \"8y14U4FYCqdGlfe3ynvpAQ7J8vQ=\", false, function () {\n  return [useDispatch, useSelector];\n});","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","useDispatch","useSelector","robotService","websocketService","setRobotData","setConnectionStatus","setExecutionState","useRobotController","_s","dispatch","robot","isConnected","state","isExecuting","setIsExecuting","executionResults","setExecutionResults","error","setError","telemetryData","setTelemetryData","wsRef","telemetryIntervalRef","current","initializeWebSocket","cleanupWebSocket","connect","onMessage","handleWebSocketMessage","onError","handleWebSocketError","onClose","handleWebSocketClose","onOpen","handleWebSocketOpen","console","disconnect","clearInterval","log","startTelemetryUpdates","message","data","JSON","parse","type","handleTelemetryUpdate","payload","handleExecutionResult","handleExecutionProgress","handleExecutionError","handleRobotStatusUpdate","telemetry","robotData","joint_angles","joint_velocities","joint_currents","joint_temperatures","end_effector_position","x","y","z","system_status","timestamp","Date","toISOString","result","lastExecution","success","metrics","progress","executionProgress","status","connected","setInterval","readyState","WebSocket","OPEN","send","stringify","executeCode","code","options","Error","language","challengeId","targetPosition","safetyEnabled","maxExecutionTime","Promise","resolve","reject","timeout","setTimeout","checkResult","clearTimeout","measurePosition","position","getCurrentPosition","moveJoint","jointId","angle","speed","acceleration","moveToPosition","targetAngles","trajectory","emergencyStop","getRobotStatus","getStatus","calibrate","resetToHome","calculateForwardKinematics","jointAngles","L1","L2","L3","θ1","θ2","θ3","map","Math","PI","positions","cos","sin","calculatePositionError","currentAngles","errors","i","abs","max","getWorkspaceBoundaries","maxReach","minReach","jointLimits","min","clearError","clearExecutionResults"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/hooks/useRobotController.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { robotService } from '../services/robotService';\nimport { websocketService } from '../services/websocketService';\nimport { setRobotData, setConnectionStatus, setExecutionState } from '../store/robotSlice';\n\nexport const useRobotController = () => {\n  const dispatch = useDispatch();\n  const { robot, isConnected } = useSelector(state => state.robot);\n  const [isExecuting, setIsExecuting] = useState(false);\n  const [executionResults, setExecutionResults] = useState(null);\n  const [error, setError] = useState(null);\n  const [telemetryData, setTelemetryData] = useState(null);\n  \n  // WebSocket connection for real-time updates\n  const wsRef = useRef(null);\n  const telemetryIntervalRef = useRef(null);\n\n  // Initialize WebSocket connection\n  useEffect(() => {\n    if (isConnected && !wsRef.current) {\n      initializeWebSocket();\n    }\n    \n    return () => {\n      cleanupWebSocket();\n    };\n  }, [isConnected]);\n\n  const initializeWebSocket = useCallback(() => {\n    try {\n      wsRef.current = websocketService.connect({\n        onMessage: handleWebSocketMessage,\n        onError: handleWebSocketError,\n        onClose: handleWebSocketClose,\n        onOpen: handleWebSocketOpen\n      });\n    } catch (error) {\n      console.error('Failed to initialize WebSocket:', error);\n      setError('WebSocket connection failed');\n    }\n  }, []);\n\n  const cleanupWebSocket = useCallback(() => {\n    if (wsRef.current) {\n      websocketService.disconnect();\n      wsRef.current = null;\n    }\n    \n    if (telemetryIntervalRef.current) {\n      clearInterval(telemetryIntervalRef.current);\n      telemetryIntervalRef.current = null;\n    }\n  }, []);\n\n  // WebSocket event handlers\n  const handleWebSocketOpen = useCallback(() => {\n    console.log('Robot WebSocket connected');\n    startTelemetryUpdates();\n  }, []);\n\n  const handleWebSocketClose = useCallback(() => {\n    console.log('Robot WebSocket disconnected');\n    dispatch(setConnectionStatus(false));\n    cleanupWebSocket();\n  }, [dispatch]);\n\n  const handleWebSocketError = useCallback((error) => {\n    console.error('Robot WebSocket error:', error);\n    setError('Real-time communication error');\n  }, []);\n\n  const handleWebSocketMessage = useCallback((message) => {\n    try {\n      const data = JSON.parse(message);\n      \n      switch (data.type) {\n        case 'robot_telemetry':\n          handleTelemetryUpdate(data.payload);\n          break;\n          \n        case 'execution_result':\n          handleExecutionResult(data.payload);\n          break;\n          \n        case 'execution_progress':\n          handleExecutionProgress(data.payload);\n          break;\n          \n        case 'error':\n          handleExecutionError(data.payload);\n          break;\n          \n        case 'robot_status':\n          handleRobotStatusUpdate(data.payload);\n          break;\n          \n        default:\n          console.log('Unknown WebSocket message type:', data.type);\n      }\n    } catch (error) {\n      console.error('Failed to parse WebSocket message:', error);\n    }\n  }, []);\n\n  // Handle real-time telemetry updates\n  const handleTelemetryUpdate = useCallback((telemetry) => {\n    const robotData = {\n      joint_angles: telemetry.joint_angles || [0, 0, 0],\n      joint_velocities: telemetry.joint_velocities || [0, 0, 0],\n      joint_currents: telemetry.joint_currents || [0, 0, 0],\n      joint_temperatures: telemetry.joint_temperatures || [25, 25, 25],\n      end_effector_position: telemetry.end_effector_position || { x: 0, y: 0, z: 0 },\n      system_status: telemetry.system_status || 'operational',\n      timestamp: telemetry.timestamp || new Date().toISOString()\n    };\n    \n    dispatch(setRobotData(robotData));\n    setTelemetryData(robotData);\n  }, [dispatch]);\n\n  // Handle code execution results\n  const handleExecutionResult = useCallback((result) => {\n    setIsExecuting(false);\n    setExecutionResults(result);\n    \n    dispatch(setExecutionState({\n      isExecuting: false,\n      lastExecution: {\n        success: result.success,\n        timestamp: new Date().toISOString(),\n        error: result.error,\n        metrics: result.metrics\n      }\n    }));\n  }, [dispatch]);\n\n  // Handle execution progress updates\n  const handleExecutionProgress = useCallback((progress) => {\n    dispatch(setExecutionState({\n      isExecuting: true,\n      executionProgress: progress\n    }));\n  }, [dispatch]);\n\n  // Handle execution errors\n  const handleExecutionError = useCallback((error) => {\n    setIsExecuting(false);\n    setError(error.message || 'Execution failed');\n    \n    dispatch(setExecutionState({\n      isExecuting: false,\n      lastExecution: {\n        success: false,\n        timestamp: new Date().toISOString(),\n        error: error.message\n      }\n    }));\n  }, [dispatch]);\n\n  // Handle robot status updates\n  const handleRobotStatusUpdate = useCallback((status) => {\n    if (!status.connected) {\n      dispatch(setConnectionStatus(false));\n    }\n  }, [dispatch]);\n\n  // Start periodic telemetry updates\n  const startTelemetryUpdates = useCallback(() => {\n    if (telemetryIntervalRef.current) {\n      clearInterval(telemetryIntervalRef.current);\n    }\n    \n    telemetryIntervalRef.current = setInterval(async () => {\n      try {\n        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n          wsRef.current.send(JSON.stringify({\n            type: 'request_telemetry',\n            timestamp: new Date().toISOString()\n          }));\n        }\n      } catch (error) {\n        console.error('Failed to request telemetry:', error);\n      }\n    }, 100); // 10Hz update rate\n  }, []);\n\n  // Execute Python code\n  const executeCode = useCallback(async (code, options = {}) => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n    \n    if (isExecuting) {\n      throw new Error('Code execution already in progress');\n    }\n\n    setIsExecuting(true);\n    setError(null);\n    setExecutionResults(null);\n\n    try {\n      // Send execution request via WebSocket for real-time updates\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'execute_code',\n          payload: {\n            code,\n            language: 'python',\n            options: {\n              challengeId: options.challengeId,\n              targetPosition: options.targetPosition,\n              safetyEnabled: options.safetyEnabled !== false,\n              maxExecutionTime: options.maxExecutionTime || 30000, // 30 seconds default\n              ...options\n            },\n            timestamp: new Date().toISOString()\n          }\n        }));\n\n        // Return a promise that resolves when execution completes\n        return new Promise((resolve, reject) => {\n          const timeout = setTimeout(() => {\n            setIsExecuting(false);\n            reject(new Error('Code execution timeout'));\n          }, options.maxExecutionTime || 30000);\n\n          const checkResult = () => {\n            if (executionResults) {\n              clearTimeout(timeout);\n              resolve(executionResults);\n            } else if (!isExecuting && error) {\n              clearTimeout(timeout);\n              reject(new Error(error));\n            } else if (isExecuting) {\n              setTimeout(checkResult, 100);\n            }\n          };\n\n          checkResult();\n        });\n      } else {\n        // Fallback to HTTP API if WebSocket not available\n        const result = await robotService.executeCode(code, options);\n        setIsExecuting(false);\n        setExecutionResults(result);\n        return result;\n      }\n    } catch (error) {\n      setIsExecuting(false);\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected, isExecuting, executionResults, error]);\n\n  // Measure current robot position\n  const measurePosition = useCallback(async () => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n\n    try {\n      const position = await robotService.getCurrentPosition();\n      \n      // Also request via WebSocket for real-time update\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'request_position',\n          timestamp: new Date().toISOString()\n        }));\n      }\n      \n      return position;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Move individual joint\n  const moveJoint = useCallback(async (jointId, angle, options = {}) => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n\n    try {\n      const result = await robotService.moveJoint(jointId, angle, options);\n      \n      // Send via WebSocket for real-time tracking\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'move_joint',\n          payload: {\n            jointId,\n            angle,\n            speed: options.speed || 50,\n            acceleration: options.acceleration || 50\n          },\n          timestamp: new Date().toISOString()\n        }));\n      }\n      \n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Move to target position\n  const moveToPosition = useCallback(async (targetAngles, options = {}) => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n\n    try {\n      const result = await robotService.moveToPosition(targetAngles, options);\n      \n      // Send via WebSocket for real-time tracking\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'move_to_position',\n          payload: {\n            targetAngles,\n            speed: options.speed || 50,\n            acceleration: options.acceleration || 50,\n            trajectory: options.trajectory || 'linear'\n          },\n          timestamp: new Date().toISOString()\n        }));\n      }\n      \n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Emergency stop\n  const emergencyStop = useCallback(async () => {\n    try {\n      // Send emergency stop via both WebSocket and HTTP for redundancy\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'emergency_stop',\n          timestamp: new Date().toISOString()\n        }));\n      }\n      \n      const result = await robotService.emergencyStop();\n      \n      setIsExecuting(false);\n      setError(null);\n      \n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, []);\n\n  // Connect to robot\n  const connect = useCallback(async () => {\n    try {\n      const result = await robotService.connect();\n      \n      if (result.success) {\n        dispatch(setConnectionStatus(true));\n        initializeWebSocket();\n      } else {\n        throw new Error(result.error || 'Connection failed');\n      }\n      \n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [dispatch, initializeWebSocket]);\n\n  // Disconnect from robot\n  const disconnect = useCallback(async () => {\n    try {\n      cleanupWebSocket();\n      const result = await robotService.disconnect();\n      dispatch(setConnectionStatus(false));\n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [dispatch, cleanupWebSocket]);\n\n  // Get robot status\n  const getRobotStatus = useCallback(async () => {\n    try {\n      const status = await robotService.getStatus();\n      return status;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, []);\n\n  // Calibrate robot\n  const calibrate = useCallback(async (options = {}) => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n\n    try {\n      const result = await robotService.calibrate(options);\n      \n      // Send via WebSocket for real-time updates\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'start_calibration',\n          payload: options,\n          timestamp: new Date().toISOString()\n        }));\n      }\n      \n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Reset robot to home position\n  const resetToHome = useCallback(async () => {\n    if (!isConnected) {\n      throw new Error('Robot not connected');\n    }\n\n    try {\n      const result = await robotService.resetToHome();\n      \n      // Send via WebSocket for real-time tracking\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'reset_to_home',\n          timestamp: new Date().toISOString()\n        }));\n      }\n      \n      return result;\n    } catch (error) {\n      setError(error.message);\n      throw error;\n    }\n  }, [isConnected]);\n\n  // Calculate forward kinematics\n  const calculateForwardKinematics = useCallback((jointAngles) => {\n    try {\n      // Robot link lengths (in pixels for visualization)\n      const L1 = 140, L2 = 120, L3 = 100;\n      \n      const [θ1, θ2, θ3] = jointAngles.map(angle => angle * Math.PI / 180);\n      \n      // Calculate joint positions\n      const positions = [\n        { x: 0, y: 0 }, // Base\n        { \n          x: L1 * Math.cos(θ1), \n          y: L1 * Math.sin(θ1) \n        }, // Joint 1\n        { \n          x: L1 * Math.cos(θ1) + L2 * Math.cos(θ1 + θ2),\n          y: L1 * Math.sin(θ1) + L2 * Math.sin(θ1 + θ2)\n        }, // Joint 2\n        { \n          x: L1 * Math.cos(θ1) + L2 * Math.cos(θ1 + θ2) + L3 * Math.cos(θ1 + θ2 + θ3),\n          y: L1 * Math.sin(θ1) + L2 * Math.sin(θ1 + θ2) + L3 * Math.sin(θ1 + θ2 + θ3)\n        } // End effector\n      ];\n      \n      return positions;\n    } catch (error) {\n      console.error('Forward kinematics calculation error:', error);\n      return [{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }];\n    }\n  }, []);\n\n  // Calculate position error\n  const calculatePositionError = useCallback((currentAngles, targetAngles) => {\n    if (!currentAngles || !targetAngles) return 0;\n    \n    const errors = currentAngles.map((angle, i) => \n      Math.abs(angle - (targetAngles[i] || 0))\n    );\n    \n    return Math.max(...errors);\n  }, []);\n\n  // Get workspace boundaries\n  const getWorkspaceBoundaries = useCallback(() => {\n    const L1 = 140, L2 = 120, L3 = 100;\n    \n    return {\n      maxReach: L1 + L2 + L3,\n      minReach: Math.max(0, Math.abs(L1 - L2 - L3)),\n      jointLimits: [\n        { min: -150, max: 150 }, // Joint 1\n        { min: -120, max: 120 }, // Joint 2\n        { min: -90, max: 90 }    // Joint 3\n      ]\n    };\n  }, []);\n\n  // Clear errors\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  // Clear execution results\n  const clearExecutionResults = useCallback(() => {\n    setExecutionResults(null);\n  }, []);\n\n  return {\n    // State\n    isConnected,\n    isExecuting,\n    error,\n    executionResults,\n    telemetryData,\n    robotData: robot,\n\n    // Control functions\n    executeCode,\n    measurePosition,\n    moveJoint,\n    moveToPosition,\n    emergencyStop,\n    connect,\n    disconnect,\n    getRobotStatus,\n    calibrate,\n    resetToHome,\n\n    // Utility functions\n    calculateForwardKinematics,\n    calculatePositionError,\n    getWorkspaceBoundaries,\n    clearError,\n    clearExecutionResults\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}