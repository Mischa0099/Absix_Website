{"ast":null,"code":"// // src/store/challengeSlice.js\n// import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n// import challengeService from '../services/challengeService';\n\n// // Async thunks\n// export const fetchChallenges = createAsyncThunk(\n//   'challenges/fetchChallenges',\n//   async (_, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.getChallenges();\n//       return response.data;\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to fetch challenges');\n//     }\n//   }\n// );\n\n// export const fetchChallenge = createAsyncThunk(\n//   'challenges/fetchChallenge',\n//   async (challengeId, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.getChallenge(challengeId);\n//       return response.data;\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to fetch challenge');\n//     }\n//   }\n// );\n\n// export const startChallenge = createAsyncThunk(\n//   'challenges/startChallenge',\n//   async ({ challengeId, parameters }, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.startChallenge(challengeId, parameters);\n//       return { challengeId, data: response.data };\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to start challenge');\n//     }\n//   }\n// );\n\n// export const submitChallenge = createAsyncThunk(\n//   'challenges/submitChallenge',\n//   async ({ challengeId, submission }, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.submitChallenge(challengeId, submission);\n//       return { challengeId, data: response.data };\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to submit challenge');\n//     }\n//   }\n// );\n\n// export const completeChallenge = createAsyncThunk(\n//   'challenges/completeChallenge',\n//   async ({ challengeId, results }, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.completeChallenge(challengeId, results);\n//       return { challengeId, data: response.data };\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to complete challenge');\n//     }\n//   }\n// );\n\n// export const fetchUserProgress = createAsyncThunk(\n//   'challenges/fetchUserProgress',\n//   async (_, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.getUserProgress();\n//       return response.data;\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to fetch user progress');\n//     }\n//   }\n// );\n\n// export const fetchLeaderboard = createAsyncThunk(\n//   'challenges/fetchLeaderboard',\n//   async (challengeId, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.getLeaderboard(challengeId);\n//       return response.data;\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to fetch leaderboard');\n//     }\n//   }\n// );\n\n// const initialState = {\n//   challenges: [],\n//   currentChallenge: null,\n//   challengeDetails: {},\n//   challengeResults: {},\n//   userProgress: {\n//     completed: 0,\n//     totalScore: 0,\n//     rank: 'Rising Roboticist',\n//     challengesCompleted: 0,\n//     streakCount: 0\n//   },\n//   leaderboards: {},\n//   loading: false,\n//   error: null,\n//   // Challenge-specific states\n//   challenge1: {\n//     score: 0,\n//     timeElapsed: 0,\n//     accuracy: 0,\n//     attempts: 0\n//   },\n//   session: {\n//     sessionId: null,\n//     startTime: null\n//   }\n// };\n\n// const challengeSlice = createSlice({\n//   name: 'challenges',\n//   initialState,\n//   reducers: {\n//     setCurrentChallenge: (state, action) => {\n//       state.currentChallenge = action.payload;\n//     },\n//     clearCurrentChallenge: (state) => {\n//       state.currentChallenge = null;\n//     },\n//     updateChallengeProgress: (state, action) => {\n//       const { challengeId, progress } = action.payload;\n//       const challenge = state.challenges.find(c => c.id === challengeId);\n//       if (challenge) {\n//         challenge.progress = progress;\n//       }\n\n//       // Update challenge1 specific state if it's challenge 1\n//       if (challengeId === 1 || challengeId === '1') {\n//         state.challenge1 = {\n//           ...state.challenge1,\n//           ...progress\n//         };\n//       }\n//     },\n//     clearError: (state) => {\n//       state.error = null;\n//     },\n//     resetChallengeState: (state) => {\n//       state.currentChallenge = null;\n//       state.error = null;\n//       state.loading = false;\n//     },\n//     updateSession: (state, action) => {\n//       state.session = {\n//         ...state.session,\n//         ...action.payload\n//       };\n//     }\n//   },\n//   extraReducers: (builder) => {\n//     builder\n//       // Fetch challenges\n//       .addCase(fetchChallenges.pending, (state) => {\n//         state.loading = true;\n//         state.error = null;\n//       })\n//       .addCase(fetchChallenges.fulfilled, (state, action) => {\n//         state.loading = false;\n//         state.challenges = action.payload.challenges || action.payload;\n//         if (action.payload.userProgress) {\n//           state.userProgress = action.payload.userProgress;\n//         }\n//       })\n//       .addCase(fetchChallenges.rejected, (state, action) => {\n//         state.loading = false;\n//         state.error = action.payload;\n//       })\n\n//       // Fetch individual challenge\n//       .addCase(fetchChallenge.pending, (state) => {\n//         state.loading = true;\n//         state.error = null;\n//       })\n//       .addCase(fetchChallenge.fulfilled, (state, action) => {\n//         state.loading = false;\n//         const challenge = action.payload;\n//         state.challengeDetails[challenge.id] = challenge;\n//       })\n//       .addCase(fetchChallenge.rejected, (state, action) => {\n//         state.loading = false;\n//         state.error = action.payload;\n//       })\n\n//       // Start challenge\n//       .addCase(startChallenge.pending, (state) => {\n//         state.loading = true;\n//         state.error = null;\n//       })\n//       .addCase(startChallenge.fulfilled, (state, action) => {\n//         state.loading = false;\n//         const { challengeId, data } = action.payload;\n//         state.currentChallenge = { id: challengeId, ...data };\n\n//         // Initialize session\n//         state.session = {\n//           sessionId: data.sessionId || Date.now().toString(),\n//           startTime: new Date().toISOString()\n//         };\n//       })\n//       .addCase(startChallenge.rejected, (state, action) => {\n//         state.loading = false;\n//         state.error = action.payload;\n//       })\n\n//       // Submit challenge\n//       .addCase(submitChallenge.pending, (state) => {\n//         state.loading = true;\n//       })\n//       .addCase(submitChallenge.fulfilled, (state, action) => {\n//         state.loading = false;\n//         const { challengeId, data } = action.payload;\n//         state.challengeResults[challengeId] = data;\n\n//         // Update challenge completion status\n//         const challenge = state.challenges.find(c => c.id === challengeId);\n//         if (challenge && data.score !== undefined) {\n//           challenge.completed = true;\n//           challenge.score = data.score;\n//           state.userProgress.completed += 1;\n//           state.userProgress.totalScore += data.score;\n//           state.userProgress.challengesCompleted += 1;\n//         }\n//       })\n//       .addCase(submitChallenge.rejected, (state, action) => {\n//         state.loading = false;\n//         state.error = action.payload;\n//       })\n\n//       // Complete challenge\n//       .addCase(completeChallenge.fulfilled, (state, action) => {\n//         const { challengeId, data } = action.payload;\n//         state.challengeResults[challengeId] = data;\n//         state.currentChallenge = null;\n//       })\n\n//       // Fetch user progress\n//       .addCase(fetchUserProgress.fulfilled, (state, action) => {\n//         state.userProgress = action.payload;\n//       })\n\n//       // Fetch leaderboard\n//       .addCase(fetchLeaderboard.fulfilled, (state, action) => {\n//         const leaderboard = action.payload;\n//         if (leaderboard.challengeId) {\n//           state.leaderboards[leaderboard.challengeId] = leaderboard.data || leaderboard;\n//         }\n//       });\n//   },\n// });\n\n// export const { \n//   setCurrentChallenge, \n//   clearCurrentChallenge, \n//   updateChallengeProgress, \n//   clearError,\n//   resetChallengeState,\n//   updateSession\n// } = challengeSlice.actions;\n\n// export default challengeSlice.reducer;\n// src/store/challengeSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport challengeService from '../services/challengeService';\nimport { getMockChallengesWithProgress } from '../utils/mockChallengeData';\n\n// Async thunks\nexport const fetchChallenges = createAsyncThunk('challenges/fetchChallenges', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    console.log('🔄 Fetching challenges...');\n\n    // Try real API first\n    try {\n      const response = await challengeService.getChallenges();\n      console.log('✅ Real API response:', response.data);\n      return response.data;\n    } catch (apiError) {\n      console.warn('⚠️ Real API failed, using mock data:', apiError.message);\n\n      // Fallback to mock data\n      const mockData = getMockChallengesWithProgress();\n      console.log('📦 Using mock data:', mockData);\n\n      // Simulate API delay\n      await new Promise(resolve => setTimeout(resolve, 500));\n      return mockData;\n    }\n  } catch (error) {\n    console.error('❌ Both real API and mock data failed:', error);\n    return rejectWithValue(error.message || 'Failed to fetch challenges');\n  }\n});\nexport const fetchChallenge = createAsyncThunk('challenges/fetchChallenge', async (challengeId, {\n  rejectWithValue\n}) => {\n  try {\n    console.log('🔄 Fetching challenge:', challengeId);\n\n    // Try real API first\n    try {\n      const response = await challengeService.getChallenge(challengeId);\n      return response.data;\n    } catch (apiError) {\n      console.warn('⚠️ Real API failed, using mock data for challenge:', challengeId);\n\n      // Fallback to mock data\n      const mockData = getMockChallengesWithProgress();\n      const challenge = mockData.challenges.find(c => c.id == challengeId);\n      if (challenge) {\n        return {\n          challenge: challenge,\n          user_progress: {\n            best_score: challenge.best_score,\n            total_attempts: challenge.attempts,\n            is_completed: challenge.is_completed\n          },\n          is_unlocked: challenge.is_unlocked\n        };\n      } else {\n        throw new Error(`Challenge ${challengeId} not found`);\n      }\n    }\n  } catch (error) {\n    return rejectWithValue(error.message || 'Failed to fetch challenge');\n  }\n});\nexport const startChallenge = createAsyncThunk('challenges/startChallenge', async ({\n  challengeId,\n  parameters\n}, {\n  rejectWithValue\n}) => {\n  try {\n    console.log('🚀 Starting challenge:', challengeId, parameters);\n\n    // Try real API first\n    try {\n      const response = await challengeService.startChallenge(challengeId, parameters);\n      return {\n        challengeId,\n        data: response.data\n      };\n    } catch (apiError) {\n      console.warn('⚠️ Real API failed, using mock response for start challenge');\n\n      // Mock response\n      await new Promise(resolve => setTimeout(resolve, 300));\n      return {\n        challengeId,\n        data: {\n          attempt_id: Date.now(),\n          challenge_id: challengeId,\n          status: \"started\",\n          attempt_number: 1,\n          parameters: parameters || {}\n        }\n      };\n    }\n  } catch (error) {\n    return rejectWithValue(error.message || 'Failed to start challenge');\n  }\n});\nexport const submitChallenge = createAsyncThunk('challenges/submitChallenge', async ({\n  challengeId,\n  submission\n}, {\n  rejectWithValue\n}) => {\n  try {\n    console.log('📤 Submitting challenge:', challengeId, submission);\n\n    // Try real API first\n    try {\n      const response = await challengeService.submitChallenge(challengeId, submission);\n      return {\n        challengeId,\n        data: response.data\n      };\n    } catch (apiError) {\n      console.warn('⚠️ Real API failed, using mock response for submit challenge');\n\n      // Mock response with random score\n      await new Promise(resolve => setTimeout(resolve, 500));\n      const mockScore = Math.floor(Math.random() * 50) + 50; // 50-100\n\n      return {\n        challengeId,\n        data: {\n          attempt_id: Date.now(),\n          score: mockScore,\n          success: mockScore > 60,\n          feedback: mockScore > 80 ? \"Excellent work! You completed the challenge with high precision.\" : mockScore > 60 ? \"Good job! You completed the challenge successfully.\" : \"Keep practicing! You can improve your performance.\",\n          performance_data: submission\n        }\n      };\n    }\n  } catch (error) {\n    return rejectWithValue(error.message || 'Failed to submit challenge');\n  }\n});\nexport const completeChallenge = createAsyncThunk('challenges/completeChallenge', async ({\n  challengeId,\n  results\n}, {\n  rejectWithValue\n}) => {\n  try {\n    // Mock completion\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return {\n      challengeId,\n      data: {\n        completed: true,\n        final_score: results.score || 0,\n        completion_time: Date.now()\n      }\n    };\n  } catch (error) {\n    return rejectWithValue(error.message || 'Failed to complete challenge');\n  }\n});\nexport const fetchUserProgress = createAsyncThunk('challenges/fetchUserProgress', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    // Try real API first\n    try {\n      const response = await challengeService.getUserProgress();\n      return response.data;\n    } catch (apiError) {\n      console.warn('⚠️ Real API failed, using mock user progress');\n\n      // Mock user progress\n      const mockData = getMockChallengesWithProgress();\n      return mockData.userProgress;\n    }\n  } catch (error) {\n    return rejectWithValue(error.message || 'Failed to fetch user progress');\n  }\n});\nexport const fetchLeaderboard = createAsyncThunk('challenges/fetchLeaderboard', async (challengeId, {\n  rejectWithValue\n}) => {\n  try {\n    // Try real API first\n    try {\n      const response = await challengeService.getLeaderboard(challengeId);\n      return response.data;\n    } catch (apiError) {\n      console.warn('⚠️ Real API failed, using mock leaderboard');\n\n      // Mock leaderboard\n      return [{\n        id: 1,\n        username: \"RobotMaster\",\n        challengesCompleted: 5,\n        totalScore: 450,\n        rank: \"Robotics Master\"\n      }, {\n        id: 2,\n        username: \"TechGuru\",\n        challengesCompleted: 4,\n        totalScore: 380,\n        rank: \"Robotics Specialist\"\n      }, {\n        id: 3,\n        username: \"CodeBot\",\n        challengesCompleted: 3,\n        totalScore: 290,\n        rank: \"Robotics Beginner\"\n      }];\n    }\n  } catch (error) {\n    return rejectWithValue(error.message || 'Failed to fetch leaderboard');\n  }\n});\nconst initialState = {\n  challenges: [],\n  currentChallenge: null,\n  challengeDetails: {},\n  challengeResults: {},\n  userProgress: {\n    completed: 0,\n    totalScore: 0,\n    rank: 'Rising Roboticist',\n    challengesCompleted: 0,\n    streakCount: 0\n  },\n  leaderboards: {},\n  loading: false,\n  error: null,\n  // Challenge-specific states\n  challenge1: {\n    score: 0,\n    timeElapsed: 0,\n    accuracy: 0,\n    attempts: 0\n  },\n  session: {\n    sessionId: null,\n    startTime: null\n  },\n  // Track if we're using mock data\n  usingMockData: false\n};\nconst challengeSlice = createSlice({\n  name: 'challenges',\n  initialState,\n  reducers: {\n    setCurrentChallenge: (state, action) => {\n      state.currentChallenge = action.payload;\n    },\n    clearCurrentChallenge: state => {\n      state.currentChallenge = null;\n    },\n    updateChallengeProgress: (state, action) => {\n      const {\n        challengeId,\n        progress\n      } = action.payload;\n      const challenge = state.challenges.find(c => c.id === challengeId);\n      if (challenge) {\n        challenge.progress = progress;\n      }\n\n      // Update challenge1 specific state if it's challenge 1\n      if (challengeId === 1 || challengeId === '1') {\n        state.challenge1 = {\n          ...state.challenge1,\n          ...progress\n        };\n      }\n    },\n    clearError: state => {\n      state.error = null;\n    },\n    resetChallengeState: state => {\n      state.currentChallenge = null;\n      state.error = null;\n      state.loading = false;\n    },\n    updateSession: (state, action) => {\n      state.session = {\n        ...state.session,\n        ...action.payload\n      };\n    },\n    // Add action to manually set mock data (for testing)\n    setMockChallenges: state => {\n      const mockData = getMockChallengesWithProgress();\n      state.challenges = mockData.challenges;\n      state.userProgress = mockData.userProgress;\n      state.usingMockData = true;\n      state.loading = false;\n      state.error = null;\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Fetch challenges\n    .addCase(fetchChallenges.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchChallenges.fulfilled, (state, action) => {\n      state.loading = false;\n      state.challenges = action.payload.challenges || action.payload;\n      if (action.payload.userProgress) {\n        state.userProgress = action.payload.userProgress;\n      }\n      // Check if this was mock data\n      state.usingMockData = Array.isArray(action.payload.challenges);\n    }).addCase(fetchChallenges.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Fetch individual challenge\n    .addCase(fetchChallenge.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchChallenge.fulfilled, (state, action) => {\n      var _challenge$challenge;\n      state.loading = false;\n      const challenge = action.payload;\n      state.challengeDetails[((_challenge$challenge = challenge.challenge) === null || _challenge$challenge === void 0 ? void 0 : _challenge$challenge.id) || challenge.id] = challenge;\n    }).addCase(fetchChallenge.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Start challenge\n    .addCase(startChallenge.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(startChallenge.fulfilled, (state, action) => {\n      state.loading = false;\n      const {\n        challengeId,\n        data\n      } = action.payload;\n      state.currentChallenge = {\n        id: challengeId,\n        ...data\n      };\n\n      // Initialize session\n      state.session = {\n        sessionId: data.sessionId || Date.now().toString(),\n        startTime: new Date().toISOString()\n      };\n    }).addCase(startChallenge.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Submit challenge\n    .addCase(submitChallenge.pending, state => {\n      state.loading = true;\n    }).addCase(submitChallenge.fulfilled, (state, action) => {\n      state.loading = false;\n      const {\n        challengeId,\n        data\n      } = action.payload;\n      state.challengeResults[challengeId] = data;\n\n      // Update challenge completion status\n      const challenge = state.challenges.find(c => c.id == challengeId);\n      if (challenge && data.score !== undefined) {\n        challenge.is_completed = data.success;\n        challenge.best_score = Math.max(challenge.best_score || 0, data.score);\n        challenge.attempts = (challenge.attempts || 0) + 1;\n\n        // Update user progress\n        if (data.success && !challenge.is_completed) {\n          state.userProgress.challengesCompleted += 1;\n        }\n        state.userProgress.totalScore += data.score;\n      }\n    }).addCase(submitChallenge.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Complete challenge\n    .addCase(completeChallenge.fulfilled, (state, action) => {\n      const {\n        challengeId,\n        data\n      } = action.payload;\n      state.challengeResults[challengeId] = data;\n      state.currentChallenge = null;\n    })\n\n    // Fetch user progress\n    .addCase(fetchUserProgress.fulfilled, (state, action) => {\n      state.userProgress = action.payload;\n    })\n\n    // Fetch leaderboard\n    .addCase(fetchLeaderboard.fulfilled, (state, action) => {\n      const leaderboard = action.payload;\n      if (Array.isArray(leaderboard)) {\n        state.leaderboards.global = leaderboard;\n      } else if (leaderboard.challengeId) {\n        state.leaderboards[leaderboard.challengeId] = leaderboard.data || leaderboard;\n      }\n    });\n  }\n});\nexport const {\n  setCurrentChallenge,\n  clearCurrentChallenge,\n  updateChallengeProgress,\n  clearError,\n  resetChallengeState,\n  updateSession,\n  setMockChallenges\n} = challengeSlice.actions;\nexport default challengeSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","challengeService","getMockChallengesWithProgress","fetchChallenges","_","rejectWithValue","console","log","response","getChallenges","data","apiError","warn","message","mockData","Promise","resolve","setTimeout","error","fetchChallenge","challengeId","getChallenge","challenge","challenges","find","c","id","user_progress","best_score","total_attempts","attempts","is_completed","is_unlocked","Error","startChallenge","parameters","attempt_id","Date","now","challenge_id","status","attempt_number","submitChallenge","submission","mockScore","Math","floor","random","score","success","feedback","performance_data","completeChallenge","results","completed","final_score","completion_time","fetchUserProgress","getUserProgress","userProgress","fetchLeaderboard","getLeaderboard","username","challengesCompleted","totalScore","rank","initialState","currentChallenge","challengeDetails","challengeResults","streakCount","leaderboards","loading","challenge1","timeElapsed","accuracy","session","sessionId","startTime","usingMockData","challengeSlice","name","reducers","setCurrentChallenge","state","action","payload","clearCurrentChallenge","updateChallengeProgress","progress","clearError","resetChallengeState","updateSession","setMockChallenges","extraReducers","builder","addCase","pending","fulfilled","Array","isArray","rejected","_challenge$challenge","toString","toISOString","undefined","max","leaderboard","global","actions","reducer"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/store/challengeSlice.js"],"sourcesContent":["// // src/store/challengeSlice.js\n// import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n// import challengeService from '../services/challengeService';\n\n// // Async thunks\n// export const fetchChallenges = createAsyncThunk(\n//   'challenges/fetchChallenges',\n//   async (_, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.getChallenges();\n//       return response.data;\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to fetch challenges');\n//     }\n//   }\n// );\n\n// export const fetchChallenge = createAsyncThunk(\n//   'challenges/fetchChallenge',\n//   async (challengeId, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.getChallenge(challengeId);\n//       return response.data;\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to fetch challenge');\n//     }\n//   }\n// );\n\n// export const startChallenge = createAsyncThunk(\n//   'challenges/startChallenge',\n//   async ({ challengeId, parameters }, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.startChallenge(challengeId, parameters);\n//       return { challengeId, data: response.data };\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to start challenge');\n//     }\n//   }\n// );\n\n// export const submitChallenge = createAsyncThunk(\n//   'challenges/submitChallenge',\n//   async ({ challengeId, submission }, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.submitChallenge(challengeId, submission);\n//       return { challengeId, data: response.data };\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to submit challenge');\n//     }\n//   }\n// );\n\n// export const completeChallenge = createAsyncThunk(\n//   'challenges/completeChallenge',\n//   async ({ challengeId, results }, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.completeChallenge(challengeId, results);\n//       return { challengeId, data: response.data };\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to complete challenge');\n//     }\n//   }\n// );\n\n// export const fetchUserProgress = createAsyncThunk(\n//   'challenges/fetchUserProgress',\n//   async (_, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.getUserProgress();\n//       return response.data;\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to fetch user progress');\n//     }\n//   }\n// );\n\n// export const fetchLeaderboard = createAsyncThunk(\n//   'challenges/fetchLeaderboard',\n//   async (challengeId, { rejectWithValue }) => {\n//     try {\n//       const response = await challengeService.getLeaderboard(challengeId);\n//       return response.data;\n//     } catch (error) {\n//       return rejectWithValue(error.response?.data?.message || 'Failed to fetch leaderboard');\n//     }\n//   }\n// );\n\n// const initialState = {\n//   challenges: [],\n//   currentChallenge: null,\n//   challengeDetails: {},\n//   challengeResults: {},\n//   userProgress: {\n//     completed: 0,\n//     totalScore: 0,\n//     rank: 'Rising Roboticist',\n//     challengesCompleted: 0,\n//     streakCount: 0\n//   },\n//   leaderboards: {},\n//   loading: false,\n//   error: null,\n//   // Challenge-specific states\n//   challenge1: {\n//     score: 0,\n//     timeElapsed: 0,\n//     accuracy: 0,\n//     attempts: 0\n//   },\n//   session: {\n//     sessionId: null,\n//     startTime: null\n//   }\n// };\n\n// const challengeSlice = createSlice({\n//   name: 'challenges',\n//   initialState,\n//   reducers: {\n//     setCurrentChallenge: (state, action) => {\n//       state.currentChallenge = action.payload;\n//     },\n//     clearCurrentChallenge: (state) => {\n//       state.currentChallenge = null;\n//     },\n//     updateChallengeProgress: (state, action) => {\n//       const { challengeId, progress } = action.payload;\n//       const challenge = state.challenges.find(c => c.id === challengeId);\n//       if (challenge) {\n//         challenge.progress = progress;\n//       }\n      \n//       // Update challenge1 specific state if it's challenge 1\n//       if (challengeId === 1 || challengeId === '1') {\n//         state.challenge1 = {\n//           ...state.challenge1,\n//           ...progress\n//         };\n//       }\n//     },\n//     clearError: (state) => {\n//       state.error = null;\n//     },\n//     resetChallengeState: (state) => {\n//       state.currentChallenge = null;\n//       state.error = null;\n//       state.loading = false;\n//     },\n//     updateSession: (state, action) => {\n//       state.session = {\n//         ...state.session,\n//         ...action.payload\n//       };\n//     }\n//   },\n//   extraReducers: (builder) => {\n//     builder\n//       // Fetch challenges\n//       .addCase(fetchChallenges.pending, (state) => {\n//         state.loading = true;\n//         state.error = null;\n//       })\n//       .addCase(fetchChallenges.fulfilled, (state, action) => {\n//         state.loading = false;\n//         state.challenges = action.payload.challenges || action.payload;\n//         if (action.payload.userProgress) {\n//           state.userProgress = action.payload.userProgress;\n//         }\n//       })\n//       .addCase(fetchChallenges.rejected, (state, action) => {\n//         state.loading = false;\n//         state.error = action.payload;\n//       })\n      \n//       // Fetch individual challenge\n//       .addCase(fetchChallenge.pending, (state) => {\n//         state.loading = true;\n//         state.error = null;\n//       })\n//       .addCase(fetchChallenge.fulfilled, (state, action) => {\n//         state.loading = false;\n//         const challenge = action.payload;\n//         state.challengeDetails[challenge.id] = challenge;\n//       })\n//       .addCase(fetchChallenge.rejected, (state, action) => {\n//         state.loading = false;\n//         state.error = action.payload;\n//       })\n      \n//       // Start challenge\n//       .addCase(startChallenge.pending, (state) => {\n//         state.loading = true;\n//         state.error = null;\n//       })\n//       .addCase(startChallenge.fulfilled, (state, action) => {\n//         state.loading = false;\n//         const { challengeId, data } = action.payload;\n//         state.currentChallenge = { id: challengeId, ...data };\n        \n//         // Initialize session\n//         state.session = {\n//           sessionId: data.sessionId || Date.now().toString(),\n//           startTime: new Date().toISOString()\n//         };\n//       })\n//       .addCase(startChallenge.rejected, (state, action) => {\n//         state.loading = false;\n//         state.error = action.payload;\n//       })\n      \n//       // Submit challenge\n//       .addCase(submitChallenge.pending, (state) => {\n//         state.loading = true;\n//       })\n//       .addCase(submitChallenge.fulfilled, (state, action) => {\n//         state.loading = false;\n//         const { challengeId, data } = action.payload;\n//         state.challengeResults[challengeId] = data;\n        \n//         // Update challenge completion status\n//         const challenge = state.challenges.find(c => c.id === challengeId);\n//         if (challenge && data.score !== undefined) {\n//           challenge.completed = true;\n//           challenge.score = data.score;\n//           state.userProgress.completed += 1;\n//           state.userProgress.totalScore += data.score;\n//           state.userProgress.challengesCompleted += 1;\n//         }\n//       })\n//       .addCase(submitChallenge.rejected, (state, action) => {\n//         state.loading = false;\n//         state.error = action.payload;\n//       })\n      \n//       // Complete challenge\n//       .addCase(completeChallenge.fulfilled, (state, action) => {\n//         const { challengeId, data } = action.payload;\n//         state.challengeResults[challengeId] = data;\n//         state.currentChallenge = null;\n//       })\n      \n//       // Fetch user progress\n//       .addCase(fetchUserProgress.fulfilled, (state, action) => {\n//         state.userProgress = action.payload;\n//       })\n      \n//       // Fetch leaderboard\n//       .addCase(fetchLeaderboard.fulfilled, (state, action) => {\n//         const leaderboard = action.payload;\n//         if (leaderboard.challengeId) {\n//           state.leaderboards[leaderboard.challengeId] = leaderboard.data || leaderboard;\n//         }\n//       });\n//   },\n// });\n\n// export const { \n//   setCurrentChallenge, \n//   clearCurrentChallenge, \n//   updateChallengeProgress, \n//   clearError,\n//   resetChallengeState,\n//   updateSession\n// } = challengeSlice.actions;\n\n// export default challengeSlice.reducer;\n// src/store/challengeSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport challengeService from '../services/challengeService';\nimport { getMockChallengesWithProgress } from '../utils/mockChallengeData';\n\n// Async thunks\nexport const fetchChallenges = createAsyncThunk(\n  'challenges/fetchChallenges',\n  async (_, { rejectWithValue }) => {\n    try {\n      console.log('🔄 Fetching challenges...');\n      \n      // Try real API first\n      try {\n        const response = await challengeService.getChallenges();\n        console.log('✅ Real API response:', response.data);\n        return response.data;\n      } catch (apiError) {\n        console.warn('⚠️ Real API failed, using mock data:', apiError.message);\n        \n        // Fallback to mock data\n        const mockData = getMockChallengesWithProgress();\n        console.log('📦 Using mock data:', mockData);\n        \n        // Simulate API delay\n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n        return mockData;\n      }\n    } catch (error) {\n      console.error('❌ Both real API and mock data failed:', error);\n      return rejectWithValue(error.message || 'Failed to fetch challenges');\n    }\n  }\n);\n\nexport const fetchChallenge = createAsyncThunk(\n  'challenges/fetchChallenge',\n  async (challengeId, { rejectWithValue }) => {\n    try {\n      console.log('🔄 Fetching challenge:', challengeId);\n      \n      // Try real API first\n      try {\n        const response = await challengeService.getChallenge(challengeId);\n        return response.data;\n      } catch (apiError) {\n        console.warn('⚠️ Real API failed, using mock data for challenge:', challengeId);\n        \n        // Fallback to mock data\n        const mockData = getMockChallengesWithProgress();\n        const challenge = mockData.challenges.find(c => c.id == challengeId);\n        \n        if (challenge) {\n          return {\n            challenge: challenge,\n            user_progress: {\n              best_score: challenge.best_score,\n              total_attempts: challenge.attempts,\n              is_completed: challenge.is_completed\n            },\n            is_unlocked: challenge.is_unlocked\n          };\n        } else {\n          throw new Error(`Challenge ${challengeId} not found`);\n        }\n      }\n    } catch (error) {\n      return rejectWithValue(error.message || 'Failed to fetch challenge');\n    }\n  }\n);\n\nexport const startChallenge = createAsyncThunk(\n  'challenges/startChallenge',\n  async ({ challengeId, parameters }, { rejectWithValue }) => {\n    try {\n      console.log('🚀 Starting challenge:', challengeId, parameters);\n      \n      // Try real API first\n      try {\n        const response = await challengeService.startChallenge(challengeId, parameters);\n        return { challengeId, data: response.data };\n      } catch (apiError) {\n        console.warn('⚠️ Real API failed, using mock response for start challenge');\n        \n        // Mock response\n        await new Promise(resolve => setTimeout(resolve, 300));\n        \n        return {\n          challengeId,\n          data: {\n            attempt_id: Date.now(),\n            challenge_id: challengeId,\n            status: \"started\",\n            attempt_number: 1,\n            parameters: parameters || {}\n          }\n        };\n      }\n    } catch (error) {\n      return rejectWithValue(error.message || 'Failed to start challenge');\n    }\n  }\n);\n\nexport const submitChallenge = createAsyncThunk(\n  'challenges/submitChallenge',\n  async ({ challengeId, submission }, { rejectWithValue }) => {\n    try {\n      console.log('📤 Submitting challenge:', challengeId, submission);\n      \n      // Try real API first\n      try {\n        const response = await challengeService.submitChallenge(challengeId, submission);\n        return { challengeId, data: response.data };\n      } catch (apiError) {\n        console.warn('⚠️ Real API failed, using mock response for submit challenge');\n        \n        // Mock response with random score\n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n        const mockScore = Math.floor(Math.random() * 50) + 50; // 50-100\n        \n        return {\n          challengeId,\n          data: {\n            attempt_id: Date.now(),\n            score: mockScore,\n            success: mockScore > 60,\n            feedback: mockScore > 80 ? \n              \"Excellent work! You completed the challenge with high precision.\" :\n              mockScore > 60 ?\n              \"Good job! You completed the challenge successfully.\" :\n              \"Keep practicing! You can improve your performance.\",\n            performance_data: submission\n          }\n        };\n      }\n    } catch (error) {\n      return rejectWithValue(error.message || 'Failed to submit challenge');\n    }\n  }\n);\n\nexport const completeChallenge = createAsyncThunk(\n  'challenges/completeChallenge',\n  async ({ challengeId, results }, { rejectWithValue }) => {\n    try {\n      // Mock completion\n      await new Promise(resolve => setTimeout(resolve, 300));\n      \n      return {\n        challengeId,\n        data: {\n          completed: true,\n          final_score: results.score || 0,\n          completion_time: Date.now()\n        }\n      };\n    } catch (error) {\n      return rejectWithValue(error.message || 'Failed to complete challenge');\n    }\n  }\n);\n\nexport const fetchUserProgress = createAsyncThunk(\n  'challenges/fetchUserProgress',\n  async (_, { rejectWithValue }) => {\n    try {\n      // Try real API first\n      try {\n        const response = await challengeService.getUserProgress();\n        return response.data;\n      } catch (apiError) {\n        console.warn('⚠️ Real API failed, using mock user progress');\n        \n        // Mock user progress\n        const mockData = getMockChallengesWithProgress();\n        return mockData.userProgress;\n      }\n    } catch (error) {\n      return rejectWithValue(error.message || 'Failed to fetch user progress');\n    }\n  }\n);\n\nexport const fetchLeaderboard = createAsyncThunk(\n  'challenges/fetchLeaderboard',\n  async (challengeId, { rejectWithValue }) => {\n    try {\n      // Try real API first\n      try {\n        const response = await challengeService.getLeaderboard(challengeId);\n        return response.data;\n      } catch (apiError) {\n        console.warn('⚠️ Real API failed, using mock leaderboard');\n        \n        // Mock leaderboard\n        return [\n          {\n            id: 1,\n            username: \"RobotMaster\",\n            challengesCompleted: 5,\n            totalScore: 450,\n            rank: \"Robotics Master\"\n          },\n          {\n            id: 2,\n            username: \"TechGuru\",\n            challengesCompleted: 4,\n            totalScore: 380,\n            rank: \"Robotics Specialist\"\n          },\n          {\n            id: 3,\n            username: \"CodeBot\",\n            challengesCompleted: 3,\n            totalScore: 290,\n            rank: \"Robotics Beginner\"\n          }\n        ];\n      }\n    } catch (error) {\n      return rejectWithValue(error.message || 'Failed to fetch leaderboard');\n    }\n  }\n);\n\nconst initialState = {\n  challenges: [],\n  currentChallenge: null,\n  challengeDetails: {},\n  challengeResults: {},\n  userProgress: {\n    completed: 0,\n    totalScore: 0,\n    rank: 'Rising Roboticist',\n    challengesCompleted: 0,\n    streakCount: 0\n  },\n  leaderboards: {},\n  loading: false,\n  error: null,\n  // Challenge-specific states\n  challenge1: {\n    score: 0,\n    timeElapsed: 0,\n    accuracy: 0,\n    attempts: 0\n  },\n  session: {\n    sessionId: null,\n    startTime: null\n  },\n  // Track if we're using mock data\n  usingMockData: false\n};\n\nconst challengeSlice = createSlice({\n  name: 'challenges',\n  initialState,\n  reducers: {\n    setCurrentChallenge: (state, action) => {\n      state.currentChallenge = action.payload;\n    },\n    clearCurrentChallenge: (state) => {\n      state.currentChallenge = null;\n    },\n    updateChallengeProgress: (state, action) => {\n      const { challengeId, progress } = action.payload;\n      const challenge = state.challenges.find(c => c.id === challengeId);\n      if (challenge) {\n        challenge.progress = progress;\n      }\n      \n      // Update challenge1 specific state if it's challenge 1\n      if (challengeId === 1 || challengeId === '1') {\n        state.challenge1 = {\n          ...state.challenge1,\n          ...progress\n        };\n      }\n    },\n    clearError: (state) => {\n      state.error = null;\n    },\n    resetChallengeState: (state) => {\n      state.currentChallenge = null;\n      state.error = null;\n      state.loading = false;\n    },\n    updateSession: (state, action) => {\n      state.session = {\n        ...state.session,\n        ...action.payload\n      };\n    },\n    // Add action to manually set mock data (for testing)\n    setMockChallenges: (state) => {\n      const mockData = getMockChallengesWithProgress();\n      state.challenges = mockData.challenges;\n      state.userProgress = mockData.userProgress;\n      state.usingMockData = true;\n      state.loading = false;\n      state.error = null;\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      // Fetch challenges\n      .addCase(fetchChallenges.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchChallenges.fulfilled, (state, action) => {\n        state.loading = false;\n        state.challenges = action.payload.challenges || action.payload;\n        if (action.payload.userProgress) {\n          state.userProgress = action.payload.userProgress;\n        }\n        // Check if this was mock data\n        state.usingMockData = Array.isArray(action.payload.challenges);\n      })\n      .addCase(fetchChallenges.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload;\n      })\n      \n      // Fetch individual challenge\n      .addCase(fetchChallenge.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchChallenge.fulfilled, (state, action) => {\n        state.loading = false;\n        const challenge = action.payload;\n        state.challengeDetails[challenge.challenge?.id || challenge.id] = challenge;\n      })\n      .addCase(fetchChallenge.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload;\n      })\n      \n      // Start challenge\n      .addCase(startChallenge.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(startChallenge.fulfilled, (state, action) => {\n        state.loading = false;\n        const { challengeId, data } = action.payload;\n        state.currentChallenge = { id: challengeId, ...data };\n        \n        // Initialize session\n        state.session = {\n          sessionId: data.sessionId || Date.now().toString(),\n          startTime: new Date().toISOString()\n        };\n      })\n      .addCase(startChallenge.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload;\n      })\n      \n      // Submit challenge\n      .addCase(submitChallenge.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(submitChallenge.fulfilled, (state, action) => {\n        state.loading = false;\n        const { challengeId, data } = action.payload;\n        state.challengeResults[challengeId] = data;\n        \n        // Update challenge completion status\n        const challenge = state.challenges.find(c => c.id == challengeId);\n        if (challenge && data.score !== undefined) {\n          challenge.is_completed = data.success;\n          challenge.best_score = Math.max(challenge.best_score || 0, data.score);\n          challenge.attempts = (challenge.attempts || 0) + 1;\n          \n          // Update user progress\n          if (data.success && !challenge.is_completed) {\n            state.userProgress.challengesCompleted += 1;\n          }\n          state.userProgress.totalScore += data.score;\n        }\n      })\n      .addCase(submitChallenge.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload;\n      })\n      \n      // Complete challenge\n      .addCase(completeChallenge.fulfilled, (state, action) => {\n        const { challengeId, data } = action.payload;\n        state.challengeResults[challengeId] = data;\n        state.currentChallenge = null;\n      })\n      \n      // Fetch user progress\n      .addCase(fetchUserProgress.fulfilled, (state, action) => {\n        state.userProgress = action.payload;\n      })\n      \n      // Fetch leaderboard\n      .addCase(fetchLeaderboard.fulfilled, (state, action) => {\n        const leaderboard = action.payload;\n        if (Array.isArray(leaderboard)) {\n          state.leaderboards.global = leaderboard;\n        } else if (leaderboard.challengeId) {\n          state.leaderboards[leaderboard.challengeId] = leaderboard.data || leaderboard;\n        }\n      });\n  },\n});\n\nexport const { \n  setCurrentChallenge, \n  clearCurrentChallenge, \n  updateChallengeProgress, \n  clearError,\n  resetChallengeState,\n  updateSession,\n  setMockChallenges\n} = challengeSlice.actions;\n\nexport default challengeSlice.reducer;"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}