{"ast":null,"code":"// /**\n//  * Enhanced Robot Service - Backend API Integration\n//  * Handles HTTP API communication with backend and hardware bridge\n//  */\n\n// import axios from 'axios';\n\n// class RobotService {\n//   constructor() {\n//     this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api/v1';\n//     this.hardwareBridgeURL = process.env.REACT_APP_HARDWARE_BRIDGE_URL || 'http://localhost:8001';\n//     this.timeout = 30000; // 30 seconds\n\n//     // Create axios instances\n//     this.apiClient = axios.create({\n//       baseURL: this.baseURL,\n//       timeout: this.timeout,\n//       headers: {\n//         'Content-Type': 'application/json'\n//       }\n//     });\n\n//     this.hardwareClient = axios.create({\n//       baseURL: this.hardwareBridgeURL,\n//       timeout: this.timeout,\n//       headers: {\n//         'Content-Type': 'application/json'\n//       }\n//     });\n\n//     // Request interceptors for authentication\n//     this.apiClient.interceptors.request.use(\n//       (config) => {\n//         const token = localStorage.getItem('auth_token');\n//         if (token) {\n//           config.headers.Authorization = `Bearer ${token}`;\n//         }\n//         return config;\n//       },\n//       (error) => Promise.reject(error)\n//     );\n\n//     // Response interceptors for error handling\n//     this.apiClient.interceptors.response.use(\n//       (response) => response,\n//       (error) => {\n//         if (error.response?.status === 401) {\n//           // Handle authentication errors\n//           localStorage.removeItem('auth_token');\n//           window.location.href = '/login';\n//         }\n//         return Promise.reject(error);\n//       }\n//     );\n\n//     this.hardwareClient.interceptors.response.use(\n//       (response) => response,\n//       (error) => {\n//         console.error('Hardware bridge error:', error);\n//         return Promise.reject(error);\n//       }\n//     );\n//   }\n\n//   /**\n//    * Connect to robot hardware\n//    * @returns {Promise<Object>} Connection result\n//    */\n//   async connect() {\n//     try {\n//       // First check if hardware bridge is available\n//       const bridgeStatus = await this.getHardwareBridgeStatus();\n\n//       if (!bridgeStatus.available) {\n//         throw new Error('Hardware bridge not available');\n//       }\n\n//       // Request connection through backend API\n//       const response = await this.apiClient.post('/robot/connect', {\n//         hardwareBridgeUrl: this.hardwareBridgeURL,\n//         timeout: this.timeout\n//       });\n\n//       if (response.data.success) {\n//         // Verify connection with direct hardware bridge call\n//         const hardwareResponse = await this.hardwareClient.post('/robot/connect');\n\n//         return {\n//           success: true,\n//           robotId: response.data.robotId,\n//           hardwareConnected: hardwareResponse.data.connected,\n//           capabilities: response.data.capabilities,\n//           timestamp: new Date().toISOString()\n//         };\n//       } else {\n//         throw new Error(response.data.error || 'Connection failed');\n//       }\n//     } catch (error) {\n//       console.error('Robot connection failed:', error);\n//       return {\n//         success: false,\n//         error: error.message || 'Connection failed',\n//         timestamp: new Date().toISOString()\n//       };\n//     }\n//   }\n\n//   /**\n//    * Disconnect from robot hardware\n//    * @returns {Promise<Object>} Disconnection result\n//    */\n//   async disconnect() {\n//     try {\n//       // Disconnect through both backend and hardware bridge\n//       const [apiResponse, hardwareResponse] = await Promise.allSettled([\n//         this.apiClient.post('/robot/disconnect'),\n//         this.hardwareClient.post('/robot/disconnect')\n//       ]);\n\n//       return {\n//         success: true,\n//         apiDisconnected: apiResponse.status === 'fulfilled',\n//         hardwareDisconnected: hardwareResponse.status === 'fulfilled',\n//         timestamp: new Date().toISOString()\n//       };\n//     } catch (error) {\n//       console.error('Robot disconnection error:', error);\n//       return {\n//         success: false,\n//         error: error.message,\n//         timestamp: new Date().toISOString()\n//       };\n//     }\n//   }\n\n//   /**\n//    * Get current robot status\n//    * @returns {Promise<Object>} Robot status\n//    */\n//   async getStatus() {\n//     try {\n//       const response = await this.apiClient.get('/robot/status');\n//       return response.data;\n//     } catch (error) {\n//       console.error('Failed to get robot status:', error);\n//       throw new Error('Failed to get robot status');\n//     }\n//   }\n\n//   /**\n//    * Get hardware bridge status\n//    * @returns {Promise<Object>} Hardware bridge status\n//    */\n//   async getHardwareBridgeStatus() {\n//     try {\n//       const response = await this.hardwareClient.get('/status');\n//       return {\n//         available: true,\n//         ...response.data\n//       };\n//     } catch (error) {\n//       return {\n//         available: false,\n//         error: error.message,\n//         timestamp: new Date().toISOString()\n//       };\n//     }\n//   }\n\n//   /**\n//    * Execute Python code on robot\n//    * @param {string} code Python code to execute\n//    * @param {Object} options Execution options\n//    * @returns {Promise<Object>} Execution result\n//    */\n//   async executeCode(code, options = {}) {\n//     try {\n//       const requestData = {\n//         code,\n//         language: 'python',\n//         options: {\n//           challengeId: options.challengeId,\n//           targetPosition: options.targetPosition,\n//           safetyEnabled: options.safetyEnabled !== false,\n//           maxExecutionTime: options.maxExecutionTime || 30000,\n//           ...options\n//         },\n//         timestamp: new Date().toISOString()\n//       };\n\n//       // Send through backend API for logging and challenge tracking\n//       const apiResponse = await this.apiClient.post('/robot/execute', requestData);\n\n//       // If backend allows execution, send to hardware bridge for actual execution\n//       if (apiResponse.data.approved) {\n//         const hardwareResponse = await this.hardwareClient.post('/robot/execute', {\n//           ...requestData,\n//           executionId: apiResponse.data.executionId\n//         });\n\n//         // Calculate position error if target provided\n//         let positionError = 0;\n//         if (options.targetPosition && hardwareResponse.data.finalPosition) {\n//           positionError = this.calculatePositionError(\n//             hardwareResponse.data.finalPosition,\n//             options.targetPosition\n//           );\n//         }\n\n//         return {\n//           success: true,\n//           executionId: apiResponse.data.executionId,\n//           finalPosition: hardwareResponse.data.finalPosition,\n//           positionError,\n//           executionTime: hardwareResponse.data.executionTime,\n//           logs: hardwareResponse.data.logs,\n//           timestamp: new Date().toISOString()\n//         };\n//       } else {\n//         throw new Error(apiResponse.data.reason || 'Code execution not approved');\n//       }\n//     } catch (error) {\n//       console.error('Code execution failed:', error);\n//       return {\n//         success: false,\n//         error: error.message,\n//         timestamp: new Date().toISOString()\n//       };\n//     }\n//   }\n\n//   /**\n//    * Get current robot position\n//    * @returns {Promise<Array<number>]} Joint angles in degrees\n//    */\n//   async getCurrentPosition() {\n//     try {\n//       const response = await this.hardwareClient.get('/robot/position');\n//       return response.data.joint_angles || [0, 0, 0];\n//     } catch (error) {\n//       console.error('Failed to get current position:', error);\n//       throw new Error('Failed to get current position');\n//     }\n//   }\n\n//   /**\n//    * Get real-time telemetry data\n//    * @returns {Promise<Object>} Telemetry data\n//    */\n//   async getTelemetry() {\n//     try {\n//       const response = await this.hardwareClient.get('/robot/telemetry');\n//       return response.data;\n//     } catch (error) {\n//       console.error('Failed to get telemetry:', error);\n//       throw new Error('Failed to get telemetry');\n//     }\n//   }\n\n//   /**\n//    * Move individual joint\n//    * @param {number} jointId Joint ID (1-3)\n//    * @param {number} angle Target angle in degrees\n//    * @param {Object} options Movement options\n//    * @returns {Promise<Object>} Movement result\n//    */\n//   async moveJoint(jointId, angle, options = {}) {\n//     try {\n//       // Validate joint parameters\n//       this.validateJointParameters(jointId, angle);\n\n//       const requestData = {\n//         jointId,\n//         angle,\n//         speed: options.speed || 50,\n//         acceleration: options.acceleration || 50,\n//         safetyEnabled: options.safetyEnabled !== false\n//       };\n\n//       // Send through backend for safety validation\n//       const apiResponse = await this.apiClient.post('/robot/move-joint', requestData);\n\n//       if (apiResponse.data.approved) {\n//         // Execute movement through hardware bridge\n//         const hardwareResponse = await this.hardwareClient.post('/robot/move-joint', {\n//           ...requestData,\n//           movementId: apiResponse.data.movementId\n//         });\n\n//         return {\n//           success: true,\n//           movementId: apiResponse.data.movementId,\n//           ...hardwareResponse.data\n//         };\n//       } else {\n//         throw new Error(apiResponse.data.reason || 'Movement not approved');\n//       }\n//     } catch (error) {\n//       console.error('Joint movement failed:', error);\n//       throw new Error(`Joint movement failed: ${error.message}`);\n//     }\n//   }\n\n//   /**\n//    * Move to target position\n//    * @param {Array<number>} targetAngles Target joint angles\n//    * @param {Object} options Movement options\n//    * @returns {Promise<Object>} Movement result\n//    */\n//   async moveToPosition(targetAngles, options = {}) {\n//     try {\n//       // Validate target angles\n//       if (!Array.isArray(targetAngles) || targetAngles.length !== 3) {\n//         throw new Error('Target angles must be an array of 3 values');\n//       }\n\n//       targetAngles.forEach((angle, index) => {\n//         this.validateJointParameters(index + 1, angle);\n//       });\n\n//       const requestData = {\n//         targetAngles,\n//         speed: options.speed || 50,\n//         acceleration: options.acceleration || 50,\n//         trajectory: options.trajectory || 'linear',\n//         safetyEnabled: options.safetyEnabled !== false\n//       };\n\n//       // Send through backend for safety validation\n//       const apiResponse = await this.apiClient.post('/robot/move-to-position', requestData);\n\n//       if (apiResponse.data.approved) {\n//         // Execute movement through hardware bridge\n//         const hardwareResponse = await this.hardwareClient.post('/robot/move-to-position', {\n//           ...requestData,\n//           movementId: apiResponse.data.movementId\n//         });\n\n//         return {\n//           success: true,\n//           movementId: apiResponse.data.movementId,\n//           ...hardwareResponse.data\n//         };\n//       } else {\n//         throw new Error(apiResponse.data.reason || 'Movement not approved');\n//       }\n//     } catch (error) {\n//       console.error('Position movement failed:', error);\n//       throw new Error(`Position movement failed: ${error.message}`);\n//     }\n//   }\n\n//   /**\n//    * Emergency stop\n//    * @returns {Promise<Object>} Emergency stop result\n//    */\n//   async emergencyStop() {\n//     try {\n//       // Send emergency stop to both backend and hardware bridge simultaneously\n//       const [apiResponse, hardwareResponse] = await Promise.allSettled([\n//         this.apiClient.post('/robot/emergency-stop'),\n//         this.hardwareClient.post('/robot/emergency-stop')\n//       ]);\n\n//       return {\n//         success: true,\n//         apiStopped: apiResponse.status === 'fulfilled',\n//         hardwareStopped: hardwareResponse.status === 'fulfilled',\n//         timestamp: new Date().toISOString()\n//       };\n//     } catch (error) {\n//       console.error('Emergency stop failed:', error);\n//       // Emergency stop should always succeed at hardware level\n//       try {\n//         await this.hardwareClient.post('/robot/emergency-stop');\n//         return {\n//           success: true,\n//           hardwareStopped: true,\n//           apiStopped: false,\n//           timestamp: new Date().toISOString()\n//         };\n//       } catch (hardwareError) {\n//         throw new Error('Critical: Emergency stop failed at hardware level');\n//       }\n//     }\n//   }\n\n//   /**\n//    * Calibrate robot\n//    * @param {Object} options Calibration options\n//    * @returns {Promise<Object>} Calibration result\n//    */\n//   async calibrate(options = {}) {\n//     try {\n//       const requestData = {\n//         calibrationType: options.type || 'home',\n//         joints: options.joints || [1, 2, 3],\n//         speed: options.speed || 25, // Slow for safety\n//         ...options\n//       };\n\n//       // Send through backend for approval\n//       const apiResponse = await this.apiClient.post('/robot/calibrate', requestData);\n\n//       if (apiResponse.data.approved) {\n//         // Execute calibration through hardware bridge\n//         const hardwareResponse = await this.hardwareClient.post('/robot/calibrate', {\n//           ...requestData,\n//           calibrationId: apiResponse.data.calibrationId\n//         });\n\n//         return {\n//           success: true,\n//           calibrationId: apiResponse.data.calibrationId,\n//           ...hardwareResponse.data\n//         };\n//       } else {\n//         throw new Error(apiResponse.data.reason || 'Calibration not approved');\n//       }\n//     } catch (error) {\n//       console.error('Calibration failed:', error);\n//       throw new Error(`Calibration failed: ${error.message}`);\n//     }\n//   }\n\n//   /**\n//    * Reset robot to home position\n//    * @returns {Promise<Object>} Reset result\n//    */\n//   async resetToHome() {\n//     try {\n//       return await this.moveToPosition([0, 0, 0], {\n//         speed: 25,\n//         trajectory: 'linear',\n//         safetyEnabled: true\n//       });\n//     } catch (error) {\n//       console.error('Reset to home failed:', error);\n//       throw new Error(`Reset to home failed: ${error.message}`);\n//     }\n//   }\n\n//   /**\n//    * Get robot workspace boundaries\n//    * @returns {Promise<Object>} Workspace boundaries\n//    */\n//   async getWorkspaceBoundaries() {\n//     try {\n//       const response = await this.apiClient.get('/robot/workspace');\n//       return response.data;\n//     } catch (error) {\n//       // Return default values if API not available\n//       return {\n//         maxReach: 360, // mm\n//         minReach: 0,\n//         jointLimits: [\n//           { min: -150, max: 150 }, // Joint 1\n//           { min: -120, max: 120 }, // Joint 2\n//           { min: -90, max: 90 }    // Joint 3\n//         ]\n//       };\n//     }\n//   }\n\n//   /**\n//    * Get robot configuration\n//    * @returns {Promise<Object>} Robot configuration\n//    */\n//   async getRobotConfig() {\n//     try {\n//       const response = await this.apiClient.get('/robot/config');\n//       return response.data;\n//     } catch (error) {\n//       // Return default configuration\n//       return {\n//         dof: 3,\n//         linkLengths: [140, 120, 100], // mm\n//         jointTypes: ['revolute', 'revolute', 'revolute'],\n//         baseHeight: 50, // mm\n//         endEffectorLength: 20 // mm\n//       };\n//     }\n//   }\n\n//   /**\n//    * Save robot configuration\n//    * @param {Object} config Configuration to save\n//    * @returns {Promise<Object>} Save result\n//    */\n//   async saveRobotConfig(config) {\n//     try {\n//       const response = await this.apiClient.post('/robot/config', config);\n//       return response.data;\n//     } catch (error) {\n//       console.error('Failed to save robot config:', error);\n//       throw new Error('Failed to save robot configuration');\n//     }\n//   }\n\n//   /**\n//    * Get challenge-specific robot data\n//    * @param {string} challengeId Challenge ID\n//    * @returns {Promise<Object>} Challenge robot data\n//    */\n//   async getChallengeRobotData(challengeId) {\n//     try {\n//       const response = await this.apiClient.get(`/challenges/${challengeId}/robot-data`);\n//       return response.data;\n//     } catch (error) {\n//       console.error('Failed to get challenge robot data:', error);\n//       return null;\n//     }\n//   }\n\n//   /**\n//    * Submit challenge robot results\n//    * @param {string} challengeId Challenge ID\n//    * @param {Object} results Challenge results\n//    * @returns {Promise<Object>} Submission result\n//    */\n//   async submitChallengeResults(challengeId, results) {\n//     try {\n//       const response = await this.apiClient.post(`/challenges/${challengeId}/submit-robot-results`, results);\n//       return response.data;\n//     } catch (error) {\n//       console.error('Failed to submit challenge results:', error);\n//       throw new Error('Failed to submit challenge results');\n//     }\n//   }\n\n//   // Utility methods\n\n//   /**\n//    * Validate joint parameters\n//    * @param {number} jointId Joint ID\n//    * @param {number} angle Angle in degrees\n//    */\n//   validateJointParameters(jointId, angle) {\n//     const jointLimits = {\n//       1: { min: -150, max: 150 },\n//       2: { min: -120, max: 120 },\n//       3: { min: -90, max: 90 }\n//     };\n\n//     if (!jointLimits[jointId]) {\n//       throw new Error(`Invalid joint ID: ${jointId}`);\n//     }\n\n//     const limits = jointLimits[jointId];\n//     if (angle < limits.min || angle > limits.max) {\n//       throw new Error(`Joint ${jointId} angle ${angle}° outside safe range [${limits.min}°, ${limits.max}°]`);\n//     }\n//   }\n\n//   /**\n//    * Calculate position error between current and target\n//    * @param {Array<number>} currentAngles Current joint angles\n//    * @param {Array<number>} targetAngles Target joint angles\n//    * @returns {number} Maximum angular error in degrees\n//    */\n//   calculatePositionError(currentAngles, targetAngles) {\n//     if (!currentAngles || !targetAngles || currentAngles.length !== targetAngles.length) {\n//       return 0;\n//     }\n\n//     const errors = currentAngles.map((current, index) => \n//       Math.abs(current - targetAngles[index])\n//     );\n\n//     return Math.max(...errors);\n//   }\n\n//   /**\n//    * Calculate forward kinematics\n//    * @param {Array<number>} jointAngles Joint angles in degrees\n//    * @returns {Object} End effector position\n//    */\n//   calculateForwardKinematics(jointAngles) {\n//     const [θ1, θ2, θ3] = jointAngles.map(angle => angle * Math.PI / 180);\n//     const [L1, L2, L3] = [140, 120, 100]; // Link lengths in mm\n\n//     const x = L1 * Math.cos(θ1) + L2 * Math.cos(θ1 + θ2) + L3 * Math.cos(θ1 + θ2 + θ3);\n//     const y = L1 * Math.sin(θ1) + L2 * Math.sin(θ1 + θ2) + L3 * Math.sin(θ1 + θ2 + θ3);\n//     const z = 0; // Planar robot\n\n//     return { x, y, z };\n//   }\n\n//   /**\n//    * Check if position is within workspace\n//    * @param {Object} position Position to check\n//    * @param {Object} workspace Workspace boundaries\n//    * @returns {boolean} True if position is reachable\n//    */\n//   isPositionReachable(position, workspace) {\n//     const distance = Math.sqrt(position.x ** 2 + position.y ** 2);\n//     return distance >= workspace.minReach && distance <= workspace.maxReach;\n//   }\n\n//   /**\n//    * Get service health status\n//    * @returns {Promise<Object>} Service health\n//    */\n//   async getHealthStatus() {\n//     try {\n//       const [apiHealth, hardwareHealth] = await Promise.allSettled([\n//         this.apiClient.get('/health'),\n//         this.hardwareClient.get('/health')\n//       ]);\n\n//       return {\n//         api: {\n//           available: apiHealth.status === 'fulfilled',\n//           status: apiHealth.status === 'fulfilled' ? apiHealth.value.data : null,\n//           error: apiHealth.status === 'rejected' ? apiHealth.reason.message : null\n//         },\n//         hardware: {\n//           available: hardwareHealth.status === 'fulfilled',\n//           status: hardwareHealth.status === 'fulfilled' ? hardwareHealth.value.data : null,\n//           error: hardwareHealth.status === 'rejected' ? hardwareHealth.reason.message : null\n//         },\n//         timestamp: new Date().toISOString()\n//       };\n//     } catch (error) {\n//       return {\n//         api: { available: false, error: error.message },\n//         hardware: { available: false, error: error.message },\n//         timestamp: new Date().toISOString()\n//       };\n//     }\n//   }\n// }\n\n// // Create and export singleton instance\n// export const robotService = new RobotService();\n// export default robotService;\n// src/services/websocketService.js\n\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.listeners = new Map();\n    this.connected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.heartbeatInterval = null;\n    this.token = null;\n  }\n  connect(token) {\n    this.token = token;\n    // Use the correct WebSocket URL from environment variables\n    const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\n    try {\n      // Close existing connection if any\n      if (this.socket) {\n        this.socket.close();\n      }\n\n      // Create new WebSocket connection\n      this.socket = new WebSocket(`${WS_URL}?token=${token}`);\n      this.socket.onopen = () => {\n        console.log('✅ WebSocket connected successfully');\n        this.connected = true;\n        this.reconnectAttempts = 0;\n        this.emit('connection_status', {\n          connected: true\n        });\n        this.startHeartbeat();\n      };\n      this.socket.onclose = event => {\n        console.log('🔌 WebSocket disconnected:', event.code, event.reason);\n        this.connected = false;\n        this.stopHeartbeat();\n        this.emit('connection_status', {\n          connected: false\n        });\n\n        // Attempt to reconnect if not manually closed\n        if (event.code !== 1000) {\n          this.attemptReconnect();\n        }\n      };\n      this.socket.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          this.handleMessage(data);\n        } catch (error) {\n          console.error('❌ Failed to parse WebSocket message:', error);\n          this.emit('error', {\n            type: 'parse_error',\n            message: error.message\n          });\n        }\n      };\n      this.socket.onerror = error => {\n        console.error('❌ WebSocket error:', error);\n        this.emit('error', {\n          type: 'connection_error',\n          message: 'WebSocket connection failed'\n        });\n      };\n    } catch (error) {\n      console.error('❌ Failed to create WebSocket connection:', error);\n      this.emit('error', {\n        type: 'creation_error',\n        message: error.message\n      });\n    }\n  }\n  disconnect() {\n    console.log('🔌 Manually disconnecting WebSocket...');\n\n    // Clear reconnection attempts\n    this.reconnectAttempts = this.maxReconnectAttempts;\n\n    // Clear timeouts\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.stopHeartbeat();\n\n    // Close WebSocket connection\n    if (this.socket) {\n      this.socket.close(1000, 'Manual disconnect');\n      this.socket = null;\n    }\n    this.connected = false;\n    this.token = null;\n  }\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts && this.token) {\n      this.reconnectAttempts++;\n      const delay = Math.min(Math.pow(2, this.reconnectAttempts) * 1000, 30000); // Max 30 seconds\n\n      console.log(`🔄 Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms`);\n      this.reconnectTimeout = setTimeout(() => {\n        this.connect(this.token);\n      }, delay);\n    } else {\n      console.error('❌ Max reconnection attempts reached or no token available');\n      this.emit('max_reconnect_attempts');\n    }\n  }\n  startHeartbeat() {\n    // Send ping every 30 seconds to keep connection alive\n    this.heartbeatInterval = setInterval(() => {\n      if (this.isConnected()) {\n        this.send({\n          type: 'ping',\n          timestamp: Date.now()\n        });\n      }\n    }, 30000);\n  }\n  stopHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n  handleMessage(data) {\n    const {\n      type,\n      payload\n    } = data;\n    switch (type) {\n      case 'robot_status':\n        this.emit('robot_status', payload);\n        break;\n      case 'challenge_update':\n        this.emit('challenge_update', payload);\n        break;\n      case 'system_status':\n        this.emit('system_status', payload);\n        break;\n      case 'error':\n        this.emit('error', payload);\n        break;\n      case 'ping':\n        // Respond to ping with pong\n        this.send({\n          type: 'pong',\n          timestamp: Date.now()\n        });\n        break;\n      case 'pong':\n        // Handle pong response\n        console.log('📡 Received pong from server');\n        break;\n      case 'auth_error':\n        console.error('🚫 Authentication error:', payload);\n        this.emit('auth_error', payload);\n        break;\n      case 'command_response':\n        this.emit('command_response', payload);\n        break;\n      default:\n        console.warn('⚠️ Unknown message type:', type);\n        this.emit('unknown_message', data);\n    }\n  }\n  send(data) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      try {\n        const message = JSON.stringify(data);\n        this.socket.send(message);\n        return true;\n      } catch (error) {\n        console.error('❌ Failed to send WebSocket message:', error);\n        this.emit('error', {\n          type: 'send_error',\n          message: error.message\n        });\n        return false;\n      }\n    } else {\n      console.warn('⚠️ WebSocket is not connected. Current state:', this.getConnectionState());\n      return false;\n    }\n  }\n\n  // Event listener management\n  on(event, callback) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n    this.listeners.get(event).push(callback);\n  }\n  off(event, callback) {\n    if (this.listeners.has(event)) {\n      const callbacks = this.listeners.get(event);\n      const index = callbacks.indexOf(callback);\n      if (index > -1) {\n        callbacks.splice(index, 1);\n      }\n    }\n  }\n  emit(event, data) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`❌ Error in WebSocket event callback for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  // Robot-specific methods\n  sendRobotCommand(command, parameters = {}) {\n    const commandData = {\n      type: 'robot_command',\n      payload: {\n        command,\n        parameters,\n        timestamp: Date.now(),\n        id: Math.random().toString(36).substr(2, 9)\n      }\n    };\n    const success = this.send(commandData);\n    if (success) {\n      console.log(`🤖 Sent robot command: ${command}`, parameters);\n    }\n    return success;\n  }\n  subscribeToRobotUpdates(callback) {\n    this.on('robot_status', callback);\n  }\n  subscribeToChallengeUpdates(callback) {\n    this.on('challenge_update', callback);\n  }\n  subscribeToSystemUpdates(callback) {\n    this.on('system_status', callback);\n  }\n  subscribeToErrors(callback) {\n    this.on('error', callback);\n  }\n\n  // Utility methods\n  isConnected() {\n    return this.connected && this.socket && this.socket.readyState === WebSocket.OPEN;\n  }\n  getConnectionState() {\n    if (!this.socket) return 'disconnected';\n    switch (this.socket.readyState) {\n      case WebSocket.CONNECTING:\n        return 'connecting';\n      case WebSocket.OPEN:\n        return 'connected';\n      case WebSocket.CLOSING:\n        return 'disconnecting';\n      case WebSocket.CLOSED:\n        return 'disconnected';\n      default:\n        return 'unknown';\n    }\n  }\n  getConnectionInfo() {\n    return {\n      connected: this.connected,\n      state: this.getConnectionState(),\n      reconnectAttempts: this.reconnectAttempts,\n      maxReconnectAttempts: this.maxReconnectAttempts,\n      hasToken: !!this.token\n    };\n  }\n\n  // Clear all listeners (useful for cleanup)\n  clearAllListeners() {\n    this.listeners.clear();\n  }\n}\n\n// Create singleton instance\nconst websocketService = new WebSocketService();\n\n// Mock robot service for development/testing\nconst robotService = {\n  connect: () => Promise.resolve({\n    connected: true\n  }),\n  disconnect: () => Promise.resolve({\n    connected: false\n  }),\n  getStatus: () => Promise.resolve({\n    status: 'ok'\n  }),\n  sendCommand: (command, params) => Promise.resolve({\n    success: true,\n    command,\n    params\n  })\n};\n\n// Export both the service instance and the class\nexport { WebSocketService };\nexport { websocketService };\nexport { robotService };\nexport default websocketService;","map":{"version":3,"names":["WebSocketService","constructor","socket","listeners","Map","connected","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","heartbeatInterval","token","connect","WS_URL","process","env","REACT_APP_WS_URL","close","WebSocket","onopen","console","log","emit","startHeartbeat","onclose","event","code","reason","stopHeartbeat","attemptReconnect","onmessage","data","JSON","parse","handleMessage","error","type","message","onerror","disconnect","clearTimeout","delay","Math","min","pow","setTimeout","setInterval","isConnected","send","timestamp","Date","now","clearInterval","payload","warn","readyState","OPEN","stringify","getConnectionState","on","callback","has","set","get","push","off","callbacks","index","indexOf","splice","forEach","sendRobotCommand","command","parameters","commandData","id","random","toString","substr","success","subscribeToRobotUpdates","subscribeToChallengeUpdates","subscribeToSystemUpdates","subscribeToErrors","CONNECTING","CLOSING","CLOSED","getConnectionInfo","state","hasToken","clearAllListeners","clear","websocketService","robotService","Promise","resolve","getStatus","status","sendCommand","params"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/services/websocketService.js"],"sourcesContent":["// /**\r\n//  * Enhanced Robot Service - Backend API Integration\r\n//  * Handles HTTP API communication with backend and hardware bridge\r\n//  */\r\n\r\n// import axios from 'axios';\r\n\r\n// class RobotService {\r\n//   constructor() {\r\n//     this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api/v1';\r\n//     this.hardwareBridgeURL = process.env.REACT_APP_HARDWARE_BRIDGE_URL || 'http://localhost:8001';\r\n//     this.timeout = 30000; // 30 seconds\r\n    \r\n//     // Create axios instances\r\n//     this.apiClient = axios.create({\r\n//       baseURL: this.baseURL,\r\n//       timeout: this.timeout,\r\n//       headers: {\r\n//         'Content-Type': 'application/json'\r\n//       }\r\n//     });\r\n    \r\n//     this.hardwareClient = axios.create({\r\n//       baseURL: this.hardwareBridgeURL,\r\n//       timeout: this.timeout,\r\n//       headers: {\r\n//         'Content-Type': 'application/json'\r\n//       }\r\n//     });\r\n    \r\n//     // Request interceptors for authentication\r\n//     this.apiClient.interceptors.request.use(\r\n//       (config) => {\r\n//         const token = localStorage.getItem('auth_token');\r\n//         if (token) {\r\n//           config.headers.Authorization = `Bearer ${token}`;\r\n//         }\r\n//         return config;\r\n//       },\r\n//       (error) => Promise.reject(error)\r\n//     );\r\n    \r\n//     // Response interceptors for error handling\r\n//     this.apiClient.interceptors.response.use(\r\n//       (response) => response,\r\n//       (error) => {\r\n//         if (error.response?.status === 401) {\r\n//           // Handle authentication errors\r\n//           localStorage.removeItem('auth_token');\r\n//           window.location.href = '/login';\r\n//         }\r\n//         return Promise.reject(error);\r\n//       }\r\n//     );\r\n    \r\n//     this.hardwareClient.interceptors.response.use(\r\n//       (response) => response,\r\n//       (error) => {\r\n//         console.error('Hardware bridge error:', error);\r\n//         return Promise.reject(error);\r\n//       }\r\n//     );\r\n//   }\r\n\r\n//   /**\r\n//    * Connect to robot hardware\r\n//    * @returns {Promise<Object>} Connection result\r\n//    */\r\n//   async connect() {\r\n//     try {\r\n//       // First check if hardware bridge is available\r\n//       const bridgeStatus = await this.getHardwareBridgeStatus();\r\n      \r\n//       if (!bridgeStatus.available) {\r\n//         throw new Error('Hardware bridge not available');\r\n//       }\r\n      \r\n//       // Request connection through backend API\r\n//       const response = await this.apiClient.post('/robot/connect', {\r\n//         hardwareBridgeUrl: this.hardwareBridgeURL,\r\n//         timeout: this.timeout\r\n//       });\r\n      \r\n//       if (response.data.success) {\r\n//         // Verify connection with direct hardware bridge call\r\n//         const hardwareResponse = await this.hardwareClient.post('/robot/connect');\r\n        \r\n//         return {\r\n//           success: true,\r\n//           robotId: response.data.robotId,\r\n//           hardwareConnected: hardwareResponse.data.connected,\r\n//           capabilities: response.data.capabilities,\r\n//           timestamp: new Date().toISOString()\r\n//         };\r\n//       } else {\r\n//         throw new Error(response.data.error || 'Connection failed');\r\n//       }\r\n//     } catch (error) {\r\n//       console.error('Robot connection failed:', error);\r\n//       return {\r\n//         success: false,\r\n//         error: error.message || 'Connection failed',\r\n//         timestamp: new Date().toISOString()\r\n//       };\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Disconnect from robot hardware\r\n//    * @returns {Promise<Object>} Disconnection result\r\n//    */\r\n//   async disconnect() {\r\n//     try {\r\n//       // Disconnect through both backend and hardware bridge\r\n//       const [apiResponse, hardwareResponse] = await Promise.allSettled([\r\n//         this.apiClient.post('/robot/disconnect'),\r\n//         this.hardwareClient.post('/robot/disconnect')\r\n//       ]);\r\n      \r\n//       return {\r\n//         success: true,\r\n//         apiDisconnected: apiResponse.status === 'fulfilled',\r\n//         hardwareDisconnected: hardwareResponse.status === 'fulfilled',\r\n//         timestamp: new Date().toISOString()\r\n//       };\r\n//     } catch (error) {\r\n//       console.error('Robot disconnection error:', error);\r\n//       return {\r\n//         success: false,\r\n//         error: error.message,\r\n//         timestamp: new Date().toISOString()\r\n//       };\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Get current robot status\r\n//    * @returns {Promise<Object>} Robot status\r\n//    */\r\n//   async getStatus() {\r\n//     try {\r\n//       const response = await this.apiClient.get('/robot/status');\r\n//       return response.data;\r\n//     } catch (error) {\r\n//       console.error('Failed to get robot status:', error);\r\n//       throw new Error('Failed to get robot status');\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Get hardware bridge status\r\n//    * @returns {Promise<Object>} Hardware bridge status\r\n//    */\r\n//   async getHardwareBridgeStatus() {\r\n//     try {\r\n//       const response = await this.hardwareClient.get('/status');\r\n//       return {\r\n//         available: true,\r\n//         ...response.data\r\n//       };\r\n//     } catch (error) {\r\n//       return {\r\n//         available: false,\r\n//         error: error.message,\r\n//         timestamp: new Date().toISOString()\r\n//       };\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Execute Python code on robot\r\n//    * @param {string} code Python code to execute\r\n//    * @param {Object} options Execution options\r\n//    * @returns {Promise<Object>} Execution result\r\n//    */\r\n//   async executeCode(code, options = {}) {\r\n//     try {\r\n//       const requestData = {\r\n//         code,\r\n//         language: 'python',\r\n//         options: {\r\n//           challengeId: options.challengeId,\r\n//           targetPosition: options.targetPosition,\r\n//           safetyEnabled: options.safetyEnabled !== false,\r\n//           maxExecutionTime: options.maxExecutionTime || 30000,\r\n//           ...options\r\n//         },\r\n//         timestamp: new Date().toISOString()\r\n//       };\r\n\r\n//       // Send through backend API for logging and challenge tracking\r\n//       const apiResponse = await this.apiClient.post('/robot/execute', requestData);\r\n      \r\n//       // If backend allows execution, send to hardware bridge for actual execution\r\n//       if (apiResponse.data.approved) {\r\n//         const hardwareResponse = await this.hardwareClient.post('/robot/execute', {\r\n//           ...requestData,\r\n//           executionId: apiResponse.data.executionId\r\n//         });\r\n        \r\n//         // Calculate position error if target provided\r\n//         let positionError = 0;\r\n//         if (options.targetPosition && hardwareResponse.data.finalPosition) {\r\n//           positionError = this.calculatePositionError(\r\n//             hardwareResponse.data.finalPosition,\r\n//             options.targetPosition\r\n//           );\r\n//         }\r\n        \r\n//         return {\r\n//           success: true,\r\n//           executionId: apiResponse.data.executionId,\r\n//           finalPosition: hardwareResponse.data.finalPosition,\r\n//           positionError,\r\n//           executionTime: hardwareResponse.data.executionTime,\r\n//           logs: hardwareResponse.data.logs,\r\n//           timestamp: new Date().toISOString()\r\n//         };\r\n//       } else {\r\n//         throw new Error(apiResponse.data.reason || 'Code execution not approved');\r\n//       }\r\n//     } catch (error) {\r\n//       console.error('Code execution failed:', error);\r\n//       return {\r\n//         success: false,\r\n//         error: error.message,\r\n//         timestamp: new Date().toISOString()\r\n//       };\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Get current robot position\r\n//    * @returns {Promise<Array<number>]} Joint angles in degrees\r\n//    */\r\n//   async getCurrentPosition() {\r\n//     try {\r\n//       const response = await this.hardwareClient.get('/robot/position');\r\n//       return response.data.joint_angles || [0, 0, 0];\r\n//     } catch (error) {\r\n//       console.error('Failed to get current position:', error);\r\n//       throw new Error('Failed to get current position');\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Get real-time telemetry data\r\n//    * @returns {Promise<Object>} Telemetry data\r\n//    */\r\n//   async getTelemetry() {\r\n//     try {\r\n//       const response = await this.hardwareClient.get('/robot/telemetry');\r\n//       return response.data;\r\n//     } catch (error) {\r\n//       console.error('Failed to get telemetry:', error);\r\n//       throw new Error('Failed to get telemetry');\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Move individual joint\r\n//    * @param {number} jointId Joint ID (1-3)\r\n//    * @param {number} angle Target angle in degrees\r\n//    * @param {Object} options Movement options\r\n//    * @returns {Promise<Object>} Movement result\r\n//    */\r\n//   async moveJoint(jointId, angle, options = {}) {\r\n//     try {\r\n//       // Validate joint parameters\r\n//       this.validateJointParameters(jointId, angle);\r\n      \r\n//       const requestData = {\r\n//         jointId,\r\n//         angle,\r\n//         speed: options.speed || 50,\r\n//         acceleration: options.acceleration || 50,\r\n//         safetyEnabled: options.safetyEnabled !== false\r\n//       };\r\n\r\n//       // Send through backend for safety validation\r\n//       const apiResponse = await this.apiClient.post('/robot/move-joint', requestData);\r\n      \r\n//       if (apiResponse.data.approved) {\r\n//         // Execute movement through hardware bridge\r\n//         const hardwareResponse = await this.hardwareClient.post('/robot/move-joint', {\r\n//           ...requestData,\r\n//           movementId: apiResponse.data.movementId\r\n//         });\r\n        \r\n//         return {\r\n//           success: true,\r\n//           movementId: apiResponse.data.movementId,\r\n//           ...hardwareResponse.data\r\n//         };\r\n//       } else {\r\n//         throw new Error(apiResponse.data.reason || 'Movement not approved');\r\n//       }\r\n//     } catch (error) {\r\n//       console.error('Joint movement failed:', error);\r\n//       throw new Error(`Joint movement failed: ${error.message}`);\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Move to target position\r\n//    * @param {Array<number>} targetAngles Target joint angles\r\n//    * @param {Object} options Movement options\r\n//    * @returns {Promise<Object>} Movement result\r\n//    */\r\n//   async moveToPosition(targetAngles, options = {}) {\r\n//     try {\r\n//       // Validate target angles\r\n//       if (!Array.isArray(targetAngles) || targetAngles.length !== 3) {\r\n//         throw new Error('Target angles must be an array of 3 values');\r\n//       }\r\n      \r\n//       targetAngles.forEach((angle, index) => {\r\n//         this.validateJointParameters(index + 1, angle);\r\n//       });\r\n      \r\n//       const requestData = {\r\n//         targetAngles,\r\n//         speed: options.speed || 50,\r\n//         acceleration: options.acceleration || 50,\r\n//         trajectory: options.trajectory || 'linear',\r\n//         safetyEnabled: options.safetyEnabled !== false\r\n//       };\r\n\r\n//       // Send through backend for safety validation\r\n//       const apiResponse = await this.apiClient.post('/robot/move-to-position', requestData);\r\n      \r\n//       if (apiResponse.data.approved) {\r\n//         // Execute movement through hardware bridge\r\n//         const hardwareResponse = await this.hardwareClient.post('/robot/move-to-position', {\r\n//           ...requestData,\r\n//           movementId: apiResponse.data.movementId\r\n//         });\r\n        \r\n//         return {\r\n//           success: true,\r\n//           movementId: apiResponse.data.movementId,\r\n//           ...hardwareResponse.data\r\n//         };\r\n//       } else {\r\n//         throw new Error(apiResponse.data.reason || 'Movement not approved');\r\n//       }\r\n//     } catch (error) {\r\n//       console.error('Position movement failed:', error);\r\n//       throw new Error(`Position movement failed: ${error.message}`);\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Emergency stop\r\n//    * @returns {Promise<Object>} Emergency stop result\r\n//    */\r\n//   async emergencyStop() {\r\n//     try {\r\n//       // Send emergency stop to both backend and hardware bridge simultaneously\r\n//       const [apiResponse, hardwareResponse] = await Promise.allSettled([\r\n//         this.apiClient.post('/robot/emergency-stop'),\r\n//         this.hardwareClient.post('/robot/emergency-stop')\r\n//       ]);\r\n      \r\n//       return {\r\n//         success: true,\r\n//         apiStopped: apiResponse.status === 'fulfilled',\r\n//         hardwareStopped: hardwareResponse.status === 'fulfilled',\r\n//         timestamp: new Date().toISOString()\r\n//       };\r\n//     } catch (error) {\r\n//       console.error('Emergency stop failed:', error);\r\n//       // Emergency stop should always succeed at hardware level\r\n//       try {\r\n//         await this.hardwareClient.post('/robot/emergency-stop');\r\n//         return {\r\n//           success: true,\r\n//           hardwareStopped: true,\r\n//           apiStopped: false,\r\n//           timestamp: new Date().toISOString()\r\n//         };\r\n//       } catch (hardwareError) {\r\n//         throw new Error('Critical: Emergency stop failed at hardware level');\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Calibrate robot\r\n//    * @param {Object} options Calibration options\r\n//    * @returns {Promise<Object>} Calibration result\r\n//    */\r\n//   async calibrate(options = {}) {\r\n//     try {\r\n//       const requestData = {\r\n//         calibrationType: options.type || 'home',\r\n//         joints: options.joints || [1, 2, 3],\r\n//         speed: options.speed || 25, // Slow for safety\r\n//         ...options\r\n//       };\r\n\r\n//       // Send through backend for approval\r\n//       const apiResponse = await this.apiClient.post('/robot/calibrate', requestData);\r\n      \r\n//       if (apiResponse.data.approved) {\r\n//         // Execute calibration through hardware bridge\r\n//         const hardwareResponse = await this.hardwareClient.post('/robot/calibrate', {\r\n//           ...requestData,\r\n//           calibrationId: apiResponse.data.calibrationId\r\n//         });\r\n        \r\n//         return {\r\n//           success: true,\r\n//           calibrationId: apiResponse.data.calibrationId,\r\n//           ...hardwareResponse.data\r\n//         };\r\n//       } else {\r\n//         throw new Error(apiResponse.data.reason || 'Calibration not approved');\r\n//       }\r\n//     } catch (error) {\r\n//       console.error('Calibration failed:', error);\r\n//       throw new Error(`Calibration failed: ${error.message}`);\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Reset robot to home position\r\n//    * @returns {Promise<Object>} Reset result\r\n//    */\r\n//   async resetToHome() {\r\n//     try {\r\n//       return await this.moveToPosition([0, 0, 0], {\r\n//         speed: 25,\r\n//         trajectory: 'linear',\r\n//         safetyEnabled: true\r\n//       });\r\n//     } catch (error) {\r\n//       console.error('Reset to home failed:', error);\r\n//       throw new Error(`Reset to home failed: ${error.message}`);\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Get robot workspace boundaries\r\n//    * @returns {Promise<Object>} Workspace boundaries\r\n//    */\r\n//   async getWorkspaceBoundaries() {\r\n//     try {\r\n//       const response = await this.apiClient.get('/robot/workspace');\r\n//       return response.data;\r\n//     } catch (error) {\r\n//       // Return default values if API not available\r\n//       return {\r\n//         maxReach: 360, // mm\r\n//         minReach: 0,\r\n//         jointLimits: [\r\n//           { min: -150, max: 150 }, // Joint 1\r\n//           { min: -120, max: 120 }, // Joint 2\r\n//           { min: -90, max: 90 }    // Joint 3\r\n//         ]\r\n//       };\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Get robot configuration\r\n//    * @returns {Promise<Object>} Robot configuration\r\n//    */\r\n//   async getRobotConfig() {\r\n//     try {\r\n//       const response = await this.apiClient.get('/robot/config');\r\n//       return response.data;\r\n//     } catch (error) {\r\n//       // Return default configuration\r\n//       return {\r\n//         dof: 3,\r\n//         linkLengths: [140, 120, 100], // mm\r\n//         jointTypes: ['revolute', 'revolute', 'revolute'],\r\n//         baseHeight: 50, // mm\r\n//         endEffectorLength: 20 // mm\r\n//       };\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Save robot configuration\r\n//    * @param {Object} config Configuration to save\r\n//    * @returns {Promise<Object>} Save result\r\n//    */\r\n//   async saveRobotConfig(config) {\r\n//     try {\r\n//       const response = await this.apiClient.post('/robot/config', config);\r\n//       return response.data;\r\n//     } catch (error) {\r\n//       console.error('Failed to save robot config:', error);\r\n//       throw new Error('Failed to save robot configuration');\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Get challenge-specific robot data\r\n//    * @param {string} challengeId Challenge ID\r\n//    * @returns {Promise<Object>} Challenge robot data\r\n//    */\r\n//   async getChallengeRobotData(challengeId) {\r\n//     try {\r\n//       const response = await this.apiClient.get(`/challenges/${challengeId}/robot-data`);\r\n//       return response.data;\r\n//     } catch (error) {\r\n//       console.error('Failed to get challenge robot data:', error);\r\n//       return null;\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Submit challenge robot results\r\n//    * @param {string} challengeId Challenge ID\r\n//    * @param {Object} results Challenge results\r\n//    * @returns {Promise<Object>} Submission result\r\n//    */\r\n//   async submitChallengeResults(challengeId, results) {\r\n//     try {\r\n//       const response = await this.apiClient.post(`/challenges/${challengeId}/submit-robot-results`, results);\r\n//       return response.data;\r\n//     } catch (error) {\r\n//       console.error('Failed to submit challenge results:', error);\r\n//       throw new Error('Failed to submit challenge results');\r\n//     }\r\n//   }\r\n\r\n//   // Utility methods\r\n\r\n//   /**\r\n//    * Validate joint parameters\r\n//    * @param {number} jointId Joint ID\r\n//    * @param {number} angle Angle in degrees\r\n//    */\r\n//   validateJointParameters(jointId, angle) {\r\n//     const jointLimits = {\r\n//       1: { min: -150, max: 150 },\r\n//       2: { min: -120, max: 120 },\r\n//       3: { min: -90, max: 90 }\r\n//     };\r\n    \r\n//     if (!jointLimits[jointId]) {\r\n//       throw new Error(`Invalid joint ID: ${jointId}`);\r\n//     }\r\n    \r\n//     const limits = jointLimits[jointId];\r\n//     if (angle < limits.min || angle > limits.max) {\r\n//       throw new Error(`Joint ${jointId} angle ${angle}° outside safe range [${limits.min}°, ${limits.max}°]`);\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Calculate position error between current and target\r\n//    * @param {Array<number>} currentAngles Current joint angles\r\n//    * @param {Array<number>} targetAngles Target joint angles\r\n//    * @returns {number} Maximum angular error in degrees\r\n//    */\r\n//   calculatePositionError(currentAngles, targetAngles) {\r\n//     if (!currentAngles || !targetAngles || currentAngles.length !== targetAngles.length) {\r\n//       return 0;\r\n//     }\r\n    \r\n//     const errors = currentAngles.map((current, index) => \r\n//       Math.abs(current - targetAngles[index])\r\n//     );\r\n    \r\n//     return Math.max(...errors);\r\n//   }\r\n\r\n//   /**\r\n//    * Calculate forward kinematics\r\n//    * @param {Array<number>} jointAngles Joint angles in degrees\r\n//    * @returns {Object} End effector position\r\n//    */\r\n//   calculateForwardKinematics(jointAngles) {\r\n//     const [θ1, θ2, θ3] = jointAngles.map(angle => angle * Math.PI / 180);\r\n//     const [L1, L2, L3] = [140, 120, 100]; // Link lengths in mm\r\n    \r\n//     const x = L1 * Math.cos(θ1) + L2 * Math.cos(θ1 + θ2) + L3 * Math.cos(θ1 + θ2 + θ3);\r\n//     const y = L1 * Math.sin(θ1) + L2 * Math.sin(θ1 + θ2) + L3 * Math.sin(θ1 + θ2 + θ3);\r\n//     const z = 0; // Planar robot\r\n    \r\n//     return { x, y, z };\r\n//   }\r\n\r\n//   /**\r\n//    * Check if position is within workspace\r\n//    * @param {Object} position Position to check\r\n//    * @param {Object} workspace Workspace boundaries\r\n//    * @returns {boolean} True if position is reachable\r\n//    */\r\n//   isPositionReachable(position, workspace) {\r\n//     const distance = Math.sqrt(position.x ** 2 + position.y ** 2);\r\n//     return distance >= workspace.minReach && distance <= workspace.maxReach;\r\n//   }\r\n\r\n//   /**\r\n//    * Get service health status\r\n//    * @returns {Promise<Object>} Service health\r\n//    */\r\n//   async getHealthStatus() {\r\n//     try {\r\n//       const [apiHealth, hardwareHealth] = await Promise.allSettled([\r\n//         this.apiClient.get('/health'),\r\n//         this.hardwareClient.get('/health')\r\n//       ]);\r\n      \r\n//       return {\r\n//         api: {\r\n//           available: apiHealth.status === 'fulfilled',\r\n//           status: apiHealth.status === 'fulfilled' ? apiHealth.value.data : null,\r\n//           error: apiHealth.status === 'rejected' ? apiHealth.reason.message : null\r\n//         },\r\n//         hardware: {\r\n//           available: hardwareHealth.status === 'fulfilled',\r\n//           status: hardwareHealth.status === 'fulfilled' ? hardwareHealth.value.data : null,\r\n//           error: hardwareHealth.status === 'rejected' ? hardwareHealth.reason.message : null\r\n//         },\r\n//         timestamp: new Date().toISOString()\r\n//       };\r\n//     } catch (error) {\r\n//       return {\r\n//         api: { available: false, error: error.message },\r\n//         hardware: { available: false, error: error.message },\r\n//         timestamp: new Date().toISOString()\r\n//       };\r\n//     }\r\n//   }\r\n// }\r\n\r\n// // Create and export singleton instance\r\n// export const robotService = new RobotService();\r\n// export default robotService;\r\n// src/services/websocketService.js\r\n\r\nclass WebSocketService {\r\n  constructor() {\r\n    this.socket = null;\r\n    this.listeners = new Map();\r\n    this.connected = false;\r\n    this.reconnectAttempts = 0;\r\n    this.maxReconnectAttempts = 5;\r\n    this.reconnectTimeout = null;\r\n    this.heartbeatInterval = null;\r\n    this.token = null;\r\n  }\r\n\r\n  connect(token) {\r\n    this.token = token;\r\n    // Use the correct WebSocket URL from environment variables\r\n    const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';\r\n    \r\n    try {\r\n      // Close existing connection if any\r\n      if (this.socket) {\r\n        this.socket.close();\r\n      }\r\n\r\n      // Create new WebSocket connection\r\n      this.socket = new WebSocket(`${WS_URL}?token=${token}`);\r\n\r\n      this.socket.onopen = () => {\r\n        console.log('✅ WebSocket connected successfully');\r\n        this.connected = true;\r\n        this.reconnectAttempts = 0;\r\n        this.emit('connection_status', { connected: true });\r\n        this.startHeartbeat();\r\n      };\r\n\r\n      this.socket.onclose = (event) => {\r\n        console.log('🔌 WebSocket disconnected:', event.code, event.reason);\r\n        this.connected = false;\r\n        this.stopHeartbeat();\r\n        this.emit('connection_status', { connected: false });\r\n        \r\n        // Attempt to reconnect if not manually closed\r\n        if (event.code !== 1000) {\r\n          this.attemptReconnect();\r\n        }\r\n      };\r\n\r\n      this.socket.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          this.handleMessage(data);\r\n        } catch (error) {\r\n          console.error('❌ Failed to parse WebSocket message:', error);\r\n          this.emit('error', { type: 'parse_error', message: error.message });\r\n        }\r\n      };\r\n\r\n      this.socket.onerror = (error) => {\r\n        console.error('❌ WebSocket error:', error);\r\n        this.emit('error', { type: 'connection_error', message: 'WebSocket connection failed' });\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to create WebSocket connection:', error);\r\n      this.emit('error', { type: 'creation_error', message: error.message });\r\n    }\r\n  }\r\n\r\n  disconnect() {\r\n    console.log('🔌 Manually disconnecting WebSocket...');\r\n    \r\n    // Clear reconnection attempts\r\n    this.reconnectAttempts = this.maxReconnectAttempts;\r\n    \r\n    // Clear timeouts\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    \r\n    this.stopHeartbeat();\r\n    \r\n    // Close WebSocket connection\r\n    if (this.socket) {\r\n      this.socket.close(1000, 'Manual disconnect');\r\n      this.socket = null;\r\n    }\r\n    \r\n    this.connected = false;\r\n    this.token = null;\r\n  }\r\n\r\n  attemptReconnect() {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts && this.token) {\r\n      this.reconnectAttempts++;\r\n      const delay = Math.min(Math.pow(2, this.reconnectAttempts) * 1000, 30000); // Max 30 seconds\r\n      \r\n      console.log(`🔄 Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms`);\r\n      \r\n      this.reconnectTimeout = setTimeout(() => {\r\n        this.connect(this.token);\r\n      }, delay);\r\n    } else {\r\n      console.error('❌ Max reconnection attempts reached or no token available');\r\n      this.emit('max_reconnect_attempts');\r\n    }\r\n  }\r\n\r\n  startHeartbeat() {\r\n    // Send ping every 30 seconds to keep connection alive\r\n    this.heartbeatInterval = setInterval(() => {\r\n      if (this.isConnected()) {\r\n        this.send({ type: 'ping', timestamp: Date.now() });\r\n      }\r\n    }, 30000);\r\n  }\r\n\r\n  stopHeartbeat() {\r\n    if (this.heartbeatInterval) {\r\n      clearInterval(this.heartbeatInterval);\r\n      this.heartbeatInterval = null;\r\n    }\r\n  }\r\n\r\n  handleMessage(data) {\r\n    const { type, payload } = data;\r\n    \r\n    switch (type) {\r\n      case 'robot_status':\r\n        this.emit('robot_status', payload);\r\n        break;\r\n      case 'challenge_update':\r\n        this.emit('challenge_update', payload);\r\n        break;\r\n      case 'system_status':\r\n        this.emit('system_status', payload);\r\n        break;\r\n      case 'error':\r\n        this.emit('error', payload);\r\n        break;\r\n      case 'ping':\r\n        // Respond to ping with pong\r\n        this.send({ type: 'pong', timestamp: Date.now() });\r\n        break;\r\n      case 'pong':\r\n        // Handle pong response\r\n        console.log('📡 Received pong from server');\r\n        break;\r\n      case 'auth_error':\r\n        console.error('🚫 Authentication error:', payload);\r\n        this.emit('auth_error', payload);\r\n        break;\r\n      case 'command_response':\r\n        this.emit('command_response', payload);\r\n        break;\r\n      default:\r\n        console.warn('⚠️ Unknown message type:', type);\r\n        this.emit('unknown_message', data);\r\n    }\r\n  }\r\n\r\n  send(data) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      try {\r\n        const message = JSON.stringify(data);\r\n        this.socket.send(message);\r\n        return true;\r\n      } catch (error) {\r\n        console.error('❌ Failed to send WebSocket message:', error);\r\n        this.emit('error', { type: 'send_error', message: error.message });\r\n        return false;\r\n      }\r\n    } else {\r\n      console.warn('⚠️ WebSocket is not connected. Current state:', this.getConnectionState());\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Event listener management\r\n  on(event, callback) {\r\n    if (!this.listeners.has(event)) {\r\n      this.listeners.set(event, []);\r\n    }\r\n    this.listeners.get(event).push(callback);\r\n  }\r\n\r\n  off(event, callback) {\r\n    if (this.listeners.has(event)) {\r\n      const callbacks = this.listeners.get(event);\r\n      const index = callbacks.indexOf(callback);\r\n      if (index > -1) {\r\n        callbacks.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  emit(event, data) {\r\n    if (this.listeners.has(event)) {\r\n      this.listeners.get(event).forEach(callback => {\r\n        try {\r\n          callback(data);\r\n        } catch (error) {\r\n          console.error(`❌ Error in WebSocket event callback for ${event}:`, error);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // Robot-specific methods\r\n  sendRobotCommand(command, parameters = {}) {\r\n    const commandData = {\r\n      type: 'robot_command',\r\n      payload: { \r\n        command, \r\n        parameters,\r\n        timestamp: Date.now(),\r\n        id: Math.random().toString(36).substr(2, 9)\r\n      }\r\n    };\r\n    \r\n    const success = this.send(commandData);\r\n    if (success) {\r\n      console.log(`🤖 Sent robot command: ${command}`, parameters);\r\n    }\r\n    return success;\r\n  }\r\n\r\n  subscribeToRobotUpdates(callback) {\r\n    this.on('robot_status', callback);\r\n  }\r\n\r\n  subscribeToChallengeUpdates(callback) {\r\n    this.on('challenge_update', callback);\r\n  }\r\n\r\n  subscribeToSystemUpdates(callback) {\r\n    this.on('system_status', callback);\r\n  }\r\n\r\n  subscribeToErrors(callback) {\r\n    this.on('error', callback);\r\n  }\r\n\r\n  // Utility methods\r\n  isConnected() {\r\n    return this.connected && this.socket && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  getConnectionState() {\r\n    if (!this.socket) return 'disconnected';\r\n    \r\n    switch (this.socket.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return 'connecting';\r\n      case WebSocket.OPEN:\r\n        return 'connected';\r\n      case WebSocket.CLOSING:\r\n        return 'disconnecting';\r\n      case WebSocket.CLOSED:\r\n        return 'disconnected';\r\n      default:\r\n        return 'unknown';\r\n    }\r\n  }\r\n\r\n  getConnectionInfo() {\r\n    return {\r\n      connected: this.connected,\r\n      state: this.getConnectionState(),\r\n      reconnectAttempts: this.reconnectAttempts,\r\n      maxReconnectAttempts: this.maxReconnectAttempts,\r\n      hasToken: !!this.token\r\n    };\r\n  }\r\n\r\n  // Clear all listeners (useful for cleanup)\r\n  clearAllListeners() {\r\n    this.listeners.clear();\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst websocketService = new WebSocketService();\r\n\r\n// Mock robot service for development/testing\r\nconst robotService = {\r\n  connect: () => Promise.resolve({ connected: true }),\r\n  disconnect: () => Promise.resolve({ connected: false }),\r\n  getStatus: () => Promise.resolve({ status: 'ok' }),\r\n  sendCommand: (command, params) => Promise.resolve({ success: true, command, params })\r\n};\r\n\r\n// Export both the service instance and the class\r\nexport { WebSocketService };\r\nexport { websocketService };\r\nexport { robotService };\r\nexport default websocketService;"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAMA,gBAAgB,CAAC;EACrBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC1B,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,oBAAoB,GAAG,CAAC;IAC7B,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACC,KAAK,GAAG,IAAI;EACnB;EAEAC,OAAOA,CAACD,KAAK,EAAE;IACb,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB;IACA,MAAME,MAAM,GAAGC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAAI,wBAAwB;IAEvE,IAAI;MACF;MACA,IAAI,IAAI,CAACb,MAAM,EAAE;QACf,IAAI,CAACA,MAAM,CAACc,KAAK,CAAC,CAAC;MACrB;;MAEA;MACA,IAAI,CAACd,MAAM,GAAG,IAAIe,SAAS,CAAC,GAAGL,MAAM,UAAUF,KAAK,EAAE,CAAC;MAEvD,IAAI,CAACR,MAAM,CAACgB,MAAM,GAAG,MAAM;QACzBC,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;QACjD,IAAI,CAACf,SAAS,GAAG,IAAI;QACrB,IAAI,CAACC,iBAAiB,GAAG,CAAC;QAC1B,IAAI,CAACe,IAAI,CAAC,mBAAmB,EAAE;UAAEhB,SAAS,EAAE;QAAK,CAAC,CAAC;QACnD,IAAI,CAACiB,cAAc,CAAC,CAAC;MACvB,CAAC;MAED,IAAI,CAACpB,MAAM,CAACqB,OAAO,GAAIC,KAAK,IAAK;QAC/BL,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAEI,KAAK,CAACC,IAAI,EAAED,KAAK,CAACE,MAAM,CAAC;QACnE,IAAI,CAACrB,SAAS,GAAG,KAAK;QACtB,IAAI,CAACsB,aAAa,CAAC,CAAC;QACpB,IAAI,CAACN,IAAI,CAAC,mBAAmB,EAAE;UAAEhB,SAAS,EAAE;QAAM,CAAC,CAAC;;QAEpD;QACA,IAAImB,KAAK,CAACC,IAAI,KAAK,IAAI,EAAE;UACvB,IAAI,CAACG,gBAAgB,CAAC,CAAC;QACzB;MACF,CAAC;MAED,IAAI,CAAC1B,MAAM,CAAC2B,SAAS,GAAIL,KAAK,IAAK;QACjC,IAAI;UACF,MAAMM,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACR,KAAK,CAACM,IAAI,CAAC;UACnC,IAAI,CAACG,aAAa,CAACH,IAAI,CAAC;QAC1B,CAAC,CAAC,OAAOI,KAAK,EAAE;UACdf,OAAO,CAACe,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;UAC5D,IAAI,CAACb,IAAI,CAAC,OAAO,EAAE;YAAEc,IAAI,EAAE,aAAa;YAAEC,OAAO,EAAEF,KAAK,CAACE;UAAQ,CAAC,CAAC;QACrE;MACF,CAAC;MAED,IAAI,CAAClC,MAAM,CAACmC,OAAO,GAAIH,KAAK,IAAK;QAC/Bf,OAAO,CAACe,KAAK,CAAC,oBAAoB,EAAEA,KAAK,CAAC;QAC1C,IAAI,CAACb,IAAI,CAAC,OAAO,EAAE;UAAEc,IAAI,EAAE,kBAAkB;UAAEC,OAAO,EAAE;QAA8B,CAAC,CAAC;MAC1F,CAAC;IAEH,CAAC,CAAC,OAAOF,KAAK,EAAE;MACdf,OAAO,CAACe,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;MAChE,IAAI,CAACb,IAAI,CAAC,OAAO,EAAE;QAAEc,IAAI,EAAE,gBAAgB;QAAEC,OAAO,EAAEF,KAAK,CAACE;MAAQ,CAAC,CAAC;IACxE;EACF;EAEAE,UAAUA,CAAA,EAAG;IACXnB,OAAO,CAACC,GAAG,CAAC,wCAAwC,CAAC;;IAErD;IACA,IAAI,CAACd,iBAAiB,GAAG,IAAI,CAACC,oBAAoB;;IAElD;IACA,IAAI,IAAI,CAACC,gBAAgB,EAAE;MACzB+B,YAAY,CAAC,IAAI,CAAC/B,gBAAgB,CAAC;MACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;IAC9B;IAEA,IAAI,CAACmB,aAAa,CAAC,CAAC;;IAEpB;IACA,IAAI,IAAI,CAACzB,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAACc,KAAK,CAAC,IAAI,EAAE,mBAAmB,CAAC;MAC5C,IAAI,CAACd,MAAM,GAAG,IAAI;IACpB;IAEA,IAAI,CAACG,SAAS,GAAG,KAAK;IACtB,IAAI,CAACK,KAAK,GAAG,IAAI;EACnB;EAEAkB,gBAAgBA,CAAA,EAAG;IACjB,IAAI,IAAI,CAACtB,iBAAiB,GAAG,IAAI,CAACC,oBAAoB,IAAI,IAAI,CAACG,KAAK,EAAE;MACpE,IAAI,CAACJ,iBAAiB,EAAE;MACxB,MAAMkC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE,IAAI,CAACrC,iBAAiB,CAAC,GAAG,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;;MAE3Ea,OAAO,CAACC,GAAG,CAAC,+BAA+B,IAAI,CAACd,iBAAiB,IAAI,IAAI,CAACC,oBAAoB,QAAQiC,KAAK,IAAI,CAAC;MAEhH,IAAI,CAAChC,gBAAgB,GAAGoC,UAAU,CAAC,MAAM;QACvC,IAAI,CAACjC,OAAO,CAAC,IAAI,CAACD,KAAK,CAAC;MAC1B,CAAC,EAAE8B,KAAK,CAAC;IACX,CAAC,MAAM;MACLrB,OAAO,CAACe,KAAK,CAAC,2DAA2D,CAAC;MAC1E,IAAI,CAACb,IAAI,CAAC,wBAAwB,CAAC;IACrC;EACF;EAEAC,cAAcA,CAAA,EAAG;IACf;IACA,IAAI,CAACb,iBAAiB,GAAGoC,WAAW,CAAC,MAAM;MACzC,IAAI,IAAI,CAACC,WAAW,CAAC,CAAC,EAAE;QACtB,IAAI,CAACC,IAAI,CAAC;UAAEZ,IAAI,EAAE,MAAM;UAAEa,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;QAAE,CAAC,CAAC;MACpD;IACF,CAAC,EAAE,KAAK,CAAC;EACX;EAEAvB,aAAaA,CAAA,EAAG;IACd,IAAI,IAAI,CAAClB,iBAAiB,EAAE;MAC1B0C,aAAa,CAAC,IAAI,CAAC1C,iBAAiB,CAAC;MACrC,IAAI,CAACA,iBAAiB,GAAG,IAAI;IAC/B;EACF;EAEAwB,aAAaA,CAACH,IAAI,EAAE;IAClB,MAAM;MAAEK,IAAI;MAAEiB;IAAQ,CAAC,GAAGtB,IAAI;IAE9B,QAAQK,IAAI;MACV,KAAK,cAAc;QACjB,IAAI,CAACd,IAAI,CAAC,cAAc,EAAE+B,OAAO,CAAC;QAClC;MACF,KAAK,kBAAkB;QACrB,IAAI,CAAC/B,IAAI,CAAC,kBAAkB,EAAE+B,OAAO,CAAC;QACtC;MACF,KAAK,eAAe;QAClB,IAAI,CAAC/B,IAAI,CAAC,eAAe,EAAE+B,OAAO,CAAC;QACnC;MACF,KAAK,OAAO;QACV,IAAI,CAAC/B,IAAI,CAAC,OAAO,EAAE+B,OAAO,CAAC;QAC3B;MACF,KAAK,MAAM;QACT;QACA,IAAI,CAACL,IAAI,CAAC;UAAEZ,IAAI,EAAE,MAAM;UAAEa,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;QAAE,CAAC,CAAC;QAClD;MACF,KAAK,MAAM;QACT;QACA/B,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC;QAC3C;MACF,KAAK,YAAY;QACfD,OAAO,CAACe,KAAK,CAAC,0BAA0B,EAAEkB,OAAO,CAAC;QAClD,IAAI,CAAC/B,IAAI,CAAC,YAAY,EAAE+B,OAAO,CAAC;QAChC;MACF,KAAK,kBAAkB;QACrB,IAAI,CAAC/B,IAAI,CAAC,kBAAkB,EAAE+B,OAAO,CAAC;QACtC;MACF;QACEjC,OAAO,CAACkC,IAAI,CAAC,0BAA0B,EAAElB,IAAI,CAAC;QAC9C,IAAI,CAACd,IAAI,CAAC,iBAAiB,EAAES,IAAI,CAAC;IACtC;EACF;EAEAiB,IAAIA,CAACjB,IAAI,EAAE;IACT,IAAI,IAAI,CAAC5B,MAAM,IAAI,IAAI,CAACA,MAAM,CAACoD,UAAU,KAAKrC,SAAS,CAACsC,IAAI,EAAE;MAC5D,IAAI;QACF,MAAMnB,OAAO,GAAGL,IAAI,CAACyB,SAAS,CAAC1B,IAAI,CAAC;QACpC,IAAI,CAAC5B,MAAM,CAAC6C,IAAI,CAACX,OAAO,CAAC;QACzB,OAAO,IAAI;MACb,CAAC,CAAC,OAAOF,KAAK,EAAE;QACdf,OAAO,CAACe,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;QAC3D,IAAI,CAACb,IAAI,CAAC,OAAO,EAAE;UAAEc,IAAI,EAAE,YAAY;UAAEC,OAAO,EAAEF,KAAK,CAACE;QAAQ,CAAC,CAAC;QAClE,OAAO,KAAK;MACd;IACF,CAAC,MAAM;MACLjB,OAAO,CAACkC,IAAI,CAAC,+CAA+C,EAAE,IAAI,CAACI,kBAAkB,CAAC,CAAC,CAAC;MACxF,OAAO,KAAK;IACd;EACF;;EAEA;EACAC,EAAEA,CAAClC,KAAK,EAAEmC,QAAQ,EAAE;IAClB,IAAI,CAAC,IAAI,CAACxD,SAAS,CAACyD,GAAG,CAACpC,KAAK,CAAC,EAAE;MAC9B,IAAI,CAACrB,SAAS,CAAC0D,GAAG,CAACrC,KAAK,EAAE,EAAE,CAAC;IAC/B;IACA,IAAI,CAACrB,SAAS,CAAC2D,GAAG,CAACtC,KAAK,CAAC,CAACuC,IAAI,CAACJ,QAAQ,CAAC;EAC1C;EAEAK,GAAGA,CAACxC,KAAK,EAAEmC,QAAQ,EAAE;IACnB,IAAI,IAAI,CAACxD,SAAS,CAACyD,GAAG,CAACpC,KAAK,CAAC,EAAE;MAC7B,MAAMyC,SAAS,GAAG,IAAI,CAAC9D,SAAS,CAAC2D,GAAG,CAACtC,KAAK,CAAC;MAC3C,MAAM0C,KAAK,GAAGD,SAAS,CAACE,OAAO,CAACR,QAAQ,CAAC;MACzC,IAAIO,KAAK,GAAG,CAAC,CAAC,EAAE;QACdD,SAAS,CAACG,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;MAC5B;IACF;EACF;EAEA7C,IAAIA,CAACG,KAAK,EAAEM,IAAI,EAAE;IAChB,IAAI,IAAI,CAAC3B,SAAS,CAACyD,GAAG,CAACpC,KAAK,CAAC,EAAE;MAC7B,IAAI,CAACrB,SAAS,CAAC2D,GAAG,CAACtC,KAAK,CAAC,CAAC6C,OAAO,CAACV,QAAQ,IAAI;QAC5C,IAAI;UACFA,QAAQ,CAAC7B,IAAI,CAAC;QAChB,CAAC,CAAC,OAAOI,KAAK,EAAE;UACdf,OAAO,CAACe,KAAK,CAAC,2CAA2CV,KAAK,GAAG,EAAEU,KAAK,CAAC;QAC3E;MACF,CAAC,CAAC;IACJ;EACF;;EAEA;EACAoC,gBAAgBA,CAACC,OAAO,EAAEC,UAAU,GAAG,CAAC,CAAC,EAAE;IACzC,MAAMC,WAAW,GAAG;MAClBtC,IAAI,EAAE,eAAe;MACrBiB,OAAO,EAAE;QACPmB,OAAO;QACPC,UAAU;QACVxB,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;QACrBwB,EAAE,EAAEjC,IAAI,CAACkC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC;MAC5C;IACF,CAAC;IAED,MAAMC,OAAO,GAAG,IAAI,CAAC/B,IAAI,CAAC0B,WAAW,CAAC;IACtC,IAAIK,OAAO,EAAE;MACX3D,OAAO,CAACC,GAAG,CAAC,0BAA0BmD,OAAO,EAAE,EAAEC,UAAU,CAAC;IAC9D;IACA,OAAOM,OAAO;EAChB;EAEAC,uBAAuBA,CAACpB,QAAQ,EAAE;IAChC,IAAI,CAACD,EAAE,CAAC,cAAc,EAAEC,QAAQ,CAAC;EACnC;EAEAqB,2BAA2BA,CAACrB,QAAQ,EAAE;IACpC,IAAI,CAACD,EAAE,CAAC,kBAAkB,EAAEC,QAAQ,CAAC;EACvC;EAEAsB,wBAAwBA,CAACtB,QAAQ,EAAE;IACjC,IAAI,CAACD,EAAE,CAAC,eAAe,EAAEC,QAAQ,CAAC;EACpC;EAEAuB,iBAAiBA,CAACvB,QAAQ,EAAE;IAC1B,IAAI,CAACD,EAAE,CAAC,OAAO,EAAEC,QAAQ,CAAC;EAC5B;;EAEA;EACAb,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACzC,SAAS,IAAI,IAAI,CAACH,MAAM,IAAI,IAAI,CAACA,MAAM,CAACoD,UAAU,KAAKrC,SAAS,CAACsC,IAAI;EACnF;EAEAE,kBAAkBA,CAAA,EAAG;IACnB,IAAI,CAAC,IAAI,CAACvD,MAAM,EAAE,OAAO,cAAc;IAEvC,QAAQ,IAAI,CAACA,MAAM,CAACoD,UAAU;MAC5B,KAAKrC,SAAS,CAACkE,UAAU;QACvB,OAAO,YAAY;MACrB,KAAKlE,SAAS,CAACsC,IAAI;QACjB,OAAO,WAAW;MACpB,KAAKtC,SAAS,CAACmE,OAAO;QACpB,OAAO,eAAe;MACxB,KAAKnE,SAAS,CAACoE,MAAM;QACnB,OAAO,cAAc;MACvB;QACE,OAAO,SAAS;IACpB;EACF;EAEAC,iBAAiBA,CAAA,EAAG;IAClB,OAAO;MACLjF,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBkF,KAAK,EAAE,IAAI,CAAC9B,kBAAkB,CAAC,CAAC;MAChCnD,iBAAiB,EAAE,IAAI,CAACA,iBAAiB;MACzCC,oBAAoB,EAAE,IAAI,CAACA,oBAAoB;MAC/CiF,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC9E;IACnB,CAAC;EACH;;EAEA;EACA+E,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAACtF,SAAS,CAACuF,KAAK,CAAC,CAAC;EACxB;AACF;;AAEA;AACA,MAAMC,gBAAgB,GAAG,IAAI3F,gBAAgB,CAAC,CAAC;;AAE/C;AACA,MAAM4F,YAAY,GAAG;EACnBjF,OAAO,EAAEA,CAAA,KAAMkF,OAAO,CAACC,OAAO,CAAC;IAAEzF,SAAS,EAAE;EAAK,CAAC,CAAC;EACnDiC,UAAU,EAAEA,CAAA,KAAMuD,OAAO,CAACC,OAAO,CAAC;IAAEzF,SAAS,EAAE;EAAM,CAAC,CAAC;EACvD0F,SAAS,EAAEA,CAAA,KAAMF,OAAO,CAACC,OAAO,CAAC;IAAEE,MAAM,EAAE;EAAK,CAAC,CAAC;EAClDC,WAAW,EAAEA,CAAC1B,OAAO,EAAE2B,MAAM,KAAKL,OAAO,CAACC,OAAO,CAAC;IAAEhB,OAAO,EAAE,IAAI;IAAEP,OAAO;IAAE2B;EAAO,CAAC;AACtF,CAAC;;AAED;AACA,SAASlG,gBAAgB;AACzB,SAAS2F,gBAAgB;AACzB,SAASC,YAAY;AACrB,eAAeD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}