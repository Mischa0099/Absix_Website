{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { setConnectionStatus, setRobotError, clearRobotError, updateRobotState } from '../store/robotSlice';\n\n// Constants for serial configuration\nconst SERIAL_CONFIG = {\n  BAUDRATE: 115200,\n  DATA_BITS: 8,\n  STOP_BITS: 1,\n  PARITY: 'none',\n  FLOW_CONTROL: 'none',\n  COMMAND_DELAY: 50,\n  TIMEOUT: 5000\n};\nconst COMMANDS = {\n  PING: 'PING',\n  GET_POSITION: 'GET_POS',\n  SET_POSITION: 'SET_POS',\n  GET_VELOCITY: 'GET_VEL',\n  SET_VELOCITY: 'SET_VEL',\n  EMERGENCY_STOP: 'ESTOP',\n  ENABLE_TORQUE: 'ENABLE',\n  DISABLE_TORQUE: 'DISABLE'\n};\n\n// Simple toast replacement since react-hot-toast might not be installed\nconst toast = {\n  success: message => console.log(`✅ ${message}`),\n  error: message => console.error(`❌ ${message}`)\n};\nexport const useWebSerial = () => {\n  _s();\n  const [port, setPort] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isReading, setIsReading] = useState(false);\n  const readerRef = useRef(null);\n  const writerRef = useRef(null);\n  const dataBufferRef = useRef('');\n  const commandQueueRef = useRef([]);\n  const processingCommandRef = useRef(false);\n  const dispatch = useDispatch();\n\n  // Check WebSerial support\n  const isSupported = 'serial' in navigator;\n\n  // Helper functions\n  const now = () => Date.now();\n  const debugLog = (message, data) => console.log(`[DEBUG] ${message}`, data);\n  const errorLog = (message, error) => console.error(`[ERROR] ${message}`, error);\n\n  // Log function\n  const log = useCallback((message, type = 'info') => {\n    console.log(`[${type.toUpperCase()}] ${message}`);\n  }, []);\n\n  // Process command queue\n  const processCommandQueue = useCallback(async () => {\n    if (processingCommandRef.current || commandQueueRef.current.length === 0) {\n      return;\n    }\n    processingCommandRef.current = true;\n    while (commandQueueRef.current.length > 0) {\n      const {\n        command,\n        resolve,\n        reject\n      } = commandQueueRef.current.shift();\n      try {\n        if (!writerRef.current || !isConnected) {\n          throw new Error('Serial port not available');\n        }\n        const commandWithTerminator = command.endsWith(';') ? command : command + ';';\n        log(`→ ${commandWithTerminator}`, 'command');\n        const encoder = new TextEncoder();\n        await writerRef.current.write(encoder.encode(commandWithTerminator));\n\n        // Small delay between commands\n        await new Promise(resolve => setTimeout(resolve, SERIAL_CONFIG.COMMAND_DELAY));\n        resolve(true);\n      } catch (error) {\n        errorLog(`Command failed: ${command}`, error);\n        log(`Command error: ${error.message}`, 'error');\n        reject(error);\n      }\n    }\n    processingCommandRef.current = false;\n  }, [isConnected, log]);\n\n  // Connect to serial port\n  const connect = useCallback(async () => {\n    if (!isSupported) {\n      const message = 'WebSerial API not supported in this browser';\n      toast.error(message);\n      dispatch(setRobotError(message));\n      return false;\n    }\n    try {\n      dispatch(setConnectionStatus('connecting'));\n      dispatch(clearRobotError());\n      log('Requesting serial port...', 'info');\n      const selectedPort = await navigator.serial.requestPort();\n      await selectedPort.open({\n        baudRate: SERIAL_CONFIG.BAUDRATE,\n        dataBits: SERIAL_CONFIG.DATA_BITS,\n        stopBits: SERIAL_CONFIG.STOP_BITS,\n        parity: SERIAL_CONFIG.PARITY,\n        flowControl: SERIAL_CONFIG.FLOW_CONTROL\n      });\n      setPort(selectedPort);\n      const reader = selectedPort.readable.getReader();\n      const writer = selectedPort.writable.getWriter();\n      readerRef.current = reader;\n      writerRef.current = writer;\n      setIsConnected(true);\n      dispatch(setConnectionStatus('connected'));\n      log('Connected to ESP32 successfully', 'info');\n      toast.success('Connected to ESP32');\n\n      // Start reading data\n      startReading();\n      return true;\n    } catch (error) {\n      errorLog('Connection failed', error);\n      log(`Connection failed: ${error.message}`, 'error');\n      dispatch(setConnectionStatus('disconnected'));\n      dispatch(setRobotError(error.message));\n      toast.error('Connection failed');\n      return false;\n    }\n  }, [isSupported, dispatch, log]);\n\n  // Disconnect from serial port\n  const disconnect = useCallback(async () => {\n    try {\n      setIsReading(false);\n\n      // Clear command queue\n      commandQueueRef.current = [];\n      processingCommandRef.current = false;\n      if (readerRef.current) {\n        await readerRef.current.cancel();\n        await readerRef.current.releaseLock();\n        readerRef.current = null;\n      }\n      if (writerRef.current) {\n        await writerRef.current.releaseLock();\n        writerRef.current = null;\n      }\n      if (port) {\n        await port.close();\n        setPort(null);\n      }\n      setIsConnected(false);\n      dispatch(setConnectionStatus('disconnected'));\n      dispatch(clearRobotError());\n      log('Disconnected from ESP32', 'info');\n      toast.success('Disconnected');\n    } catch (error) {\n      errorLog('Disconnection error', error);\n      log(`Disconnection error: ${error.message}`, 'error');\n      toast.error('Disconnection error');\n    }\n  }, [port, dispatch, log]);\n\n  // Start reading serial data\n  const startReading = useCallback(async () => {\n    if (!readerRef.current || isReading) return;\n    setIsReading(true);\n    try {\n      while (isConnected && readerRef.current) {\n        const {\n          value,\n          done\n        } = await readerRef.current.read();\n        if (done) break;\n        const text = new TextDecoder().decode(value);\n        handleSerialData(text);\n      }\n    } catch (error) {\n      if (isConnected) {\n        errorLog('Read error', error);\n        log(`Read error: ${error.message}`, 'error');\n      }\n    } finally {\n      setIsReading(false);\n    }\n  }, [isConnected, isReading, log]);\n\n  // Handle incoming serial data\n  const handleSerialData = useCallback(text => {\n    dataBufferRef.current += text;\n    const lines = dataBufferRef.current.split('\\n');\n    dataBufferRef.current = lines.pop() || '';\n    for (let line of lines) {\n      line = line.trim();\n      if (line) {\n        log(`← ${line}`, 'response');\n        processSerialResponse(line);\n      }\n    }\n  }, [log]);\n\n  // Process serial responses\n  const processSerialResponse = useCallback(response => {\n    try {\n      if (response === 'PING_OK') {\n        window.dispatchEvent(new CustomEvent('pingResponse', {\n          detail: {\n            success: true\n          }\n        }));\n      } else if (response === 'PING_FAIL') {\n        window.dispatchEvent(new CustomEvent('pingResponse', {\n          detail: {\n            success: false\n          }\n        }));\n      } else if (response === 'OK') {\n        log('Command executed successfully', 'info');\n      } else if (response.startsWith('POS:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const position = parseInt(parts[2]);\n          dispatch(updateRobotState({\n            jointAngles: {\n              [motorId]: position\n            }\n          }));\n          window.dispatchEvent(new CustomEvent('positionUpdate', {\n            detail: {\n              motorId,\n              position\n            }\n          }));\n        }\n      } else if (response.startsWith('VEL:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const velocity = parseInt(parts[2]);\n          window.dispatchEvent(new CustomEvent('velocityUpdate', {\n            detail: {\n              motorId,\n              velocity\n            }\n          }));\n        }\n      } else if (response.startsWith('TEMP:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const temperature = parseInt(parts[2]);\n          window.dispatchEvent(new CustomEvent('temperatureUpdate', {\n            detail: {\n              motorId,\n              temperature\n            }\n          }));\n        }\n      } else if (response.startsWith('ERROR:')) {\n        const errorMsg = response.substring(6);\n        log(`Hardware error: ${errorMsg}`, 'error');\n        toast.error(`Hardware error: ${errorMsg}`);\n        dispatch(setRobotError(errorMsg));\n      } else if (response === 'ESP32_DYNAMIXEL_CONTROLLER_READY') {\n        log('ESP32 controller ready!', 'info');\n        toast.success('ESP32 ready!');\n        window.dispatchEvent(new CustomEvent('controllerReady'));\n      } else if (response.includes('Motor ID')) {\n        log(response, 'info');\n        const match = response.match(/Motor ID (\\d+):/);\n        if (match && response.includes('Connected')) {\n          const motorId = parseInt(match[1]);\n          window.dispatchEvent(new CustomEvent('motorDetected', {\n            detail: {\n              motorId\n            }\n          }));\n        }\n      } else {\n        debugLog('Unknown response:', response);\n      }\n    } catch (error) {\n      errorLog('Error processing serial response', error);\n    }\n  }, [log, dispatch]);\n\n  // Send command to serial port\n  const sendCommand = useCallback(async command => {\n    if (!isConnected) {\n      const error = new Error('Not connected to send command');\n      log(error.message, 'error');\n      throw error;\n    }\n    return new Promise((resolve, reject) => {\n      commandQueueRef.current.push({\n        command,\n        resolve,\n        reject\n      });\n      processCommandQueue();\n    });\n  }, [isConnected, log, processCommandQueue]);\n\n  // Ping a motor\n  const pingMotor = useCallback(async motorId => {\n    if (!isConnected) return false;\n    return new Promise(resolve => {\n      const timeout = setTimeout(() => {\n        resolve(false);\n      }, SERIAL_CONFIG.TIMEOUT);\n      const handlePingResponse = event => {\n        clearTimeout(timeout);\n        window.removeEventListener('pingResponse', handlePingResponse);\n        resolve(event.detail.success);\n      };\n      window.addEventListener('pingResponse', handlePingResponse);\n      sendCommand(`${COMMANDS.PING}:${motorId}`).catch(() => {\n        clearTimeout(timeout);\n        window.removeEventListener('pingResponse', handlePingResponse);\n        resolve(false);\n      });\n    });\n  }, [isConnected, sendCommand]);\n\n  // Get motor position\n  const getMotorPosition = useCallback(async motorId => {\n    if (!isConnected) return null;\n    return new Promise(resolve => {\n      const timeout = setTimeout(() => {\n        resolve(null);\n      }, SERIAL_CONFIG.TIMEOUT);\n      const handlePositionUpdate = event => {\n        if (event.detail.motorId === motorId) {\n          clearTimeout(timeout);\n          window.removeEventListener('positionUpdate', handlePositionUpdate);\n          resolve(event.detail.position);\n        }\n      };\n      window.addEventListener('positionUpdate', handlePositionUpdate);\n      sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`).catch(() => {\n        clearTimeout(timeout);\n        window.removeEventListener('positionUpdate', handlePositionUpdate);\n        resolve(null);\n      });\n    });\n  }, [isConnected, sendCommand]);\n\n  // Emergency stop all motors\n  const emergencyStop = useCallback(async () => {\n    if (!isConnected) return;\n    try {\n      await sendCommand(COMMANDS.EMERGENCY_STOP);\n      log('Emergency stop executed', 'warning');\n      toast.error('Emergency stop activated!');\n    } catch (error) {\n      errorLog('Emergency stop failed', error);\n    }\n  }, [isConnected, sendCommand, log]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (isConnected) {\n        disconnect();\n      }\n    };\n  }, [isConnected, disconnect]);\n\n  // Auto-reconnect functionality\n  const autoReconnect = useCallback(async () => {\n    if (!isConnected && port) {\n      log('Attempting auto-reconnect...', 'info');\n      try {\n        await connect();\n      } catch (error) {\n        errorLog('Auto-reconnect failed', error);\n      }\n    }\n  }, [isConnected, port, connect, log]);\n  return {\n    // State\n    isSupported,\n    isConnected,\n    isReading,\n    port,\n    // Actions\n    connect,\n    disconnect,\n    sendCommand,\n    // Utilities\n    pingMotor,\n    getMotorPosition,\n    emergencyStop,\n    autoReconnect\n  };\n};\n_s(useWebSerial, \"PA25OOUg+wtEWBDxtvtOwVMYacc=\", false, function () {\n  return [useDispatch];\n});\nexport default useWebSerial;","map":{"version":3,"names":["useState","useCallback","useRef","useEffect","useDispatch","setConnectionStatus","setRobotError","clearRobotError","updateRobotState","SERIAL_CONFIG","BAUDRATE","DATA_BITS","STOP_BITS","PARITY","FLOW_CONTROL","COMMAND_DELAY","TIMEOUT","COMMANDS","PING","GET_POSITION","SET_POSITION","GET_VELOCITY","SET_VELOCITY","EMERGENCY_STOP","ENABLE_TORQUE","DISABLE_TORQUE","toast","success","message","console","log","error","useWebSerial","_s","port","setPort","isConnected","setIsConnected","isReading","setIsReading","readerRef","writerRef","dataBufferRef","commandQueueRef","processingCommandRef","dispatch","isSupported","navigator","now","Date","debugLog","data","errorLog","type","toUpperCase","processCommandQueue","current","length","command","resolve","reject","shift","Error","commandWithTerminator","endsWith","encoder","TextEncoder","write","encode","Promise","setTimeout","connect","selectedPort","serial","requestPort","open","baudRate","dataBits","stopBits","parity","flowControl","reader","readable","getReader","writer","writable","getWriter","startReading","disconnect","cancel","releaseLock","close","value","done","read","text","TextDecoder","decode","handleSerialData","lines","split","pop","line","trim","processSerialResponse","response","window","dispatchEvent","CustomEvent","detail","startsWith","parts","motorId","parseInt","position","jointAngles","velocity","temperature","errorMsg","substring","includes","match","sendCommand","push","pingMotor","timeout","handlePingResponse","event","clearTimeout","removeEventListener","addEventListener","catch","getMotorPosition","handlePositionUpdate","emergencyStop","autoReconnect"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/hooks/useWebSerial.js"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { \n  setConnectionStatus, \n  setRobotError,\n  clearRobotError,\n  updateRobotState \n} from '../store/robotSlice';\n\n// Constants for serial configuration\nconst SERIAL_CONFIG = {\n  BAUDRATE: 115200,\n  DATA_BITS: 8,\n  STOP_BITS: 1,\n  PARITY: 'none',\n  FLOW_CONTROL: 'none',\n  COMMAND_DELAY: 50,\n  TIMEOUT: 5000,\n};\n\nconst COMMANDS = {\n  PING: 'PING',\n  GET_POSITION: 'GET_POS',\n  SET_POSITION: 'SET_POS',\n  GET_VELOCITY: 'GET_VEL',\n  SET_VELOCITY: 'SET_VEL',\n  EMERGENCY_STOP: 'ESTOP',\n  ENABLE_TORQUE: 'ENABLE',\n  DISABLE_TORQUE: 'DISABLE',\n};\n\n// Simple toast replacement since react-hot-toast might not be installed\nconst toast = {\n  success: (message) => console.log(`✅ ${message}`),\n  error: (message) => console.error(`❌ ${message}`),\n};\n\nexport const useWebSerial = () => {\n  const [port, setPort] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isReading, setIsReading] = useState(false);\n  \n  const readerRef = useRef(null);\n  const writerRef = useRef(null);\n  const dataBufferRef = useRef('');\n  const commandQueueRef = useRef([]);\n  const processingCommandRef = useRef(false);\n  \n  const dispatch = useDispatch();\n\n  // Check WebSerial support\n  const isSupported = 'serial' in navigator;\n\n  // Helper functions\n  const now = () => Date.now();\n  const debugLog = (message, data) => console.log(`[DEBUG] ${message}`, data);\n  const errorLog = (message, error) => console.error(`[ERROR] ${message}`, error);\n\n  // Log function\n  const log = useCallback((message, type = 'info') => {\n    console.log(`[${type.toUpperCase()}] ${message}`);\n  }, []);\n\n  // Process command queue\n  const processCommandQueue = useCallback(async () => {\n    if (processingCommandRef.current || commandQueueRef.current.length === 0) {\n      return;\n    }\n\n    processingCommandRef.current = true;\n\n    while (commandQueueRef.current.length > 0) {\n      const { command, resolve, reject } = commandQueueRef.current.shift();\n      \n      try {\n        if (!writerRef.current || !isConnected) {\n          throw new Error('Serial port not available');\n        }\n\n        const commandWithTerminator = command.endsWith(';') ? command : command + ';';\n        log(`→ ${commandWithTerminator}`, 'command');\n        \n        const encoder = new TextEncoder();\n        await writerRef.current.write(encoder.encode(commandWithTerminator));\n        \n        // Small delay between commands\n        await new Promise(resolve => setTimeout(resolve, SERIAL_CONFIG.COMMAND_DELAY));\n        \n        resolve(true);\n      } catch (error) {\n        errorLog(`Command failed: ${command}`, error);\n        log(`Command error: ${error.message}`, 'error');\n        reject(error);\n      }\n    }\n\n    processingCommandRef.current = false;\n  }, [isConnected, log]);\n\n  // Connect to serial port\n  const connect = useCallback(async () => {\n    if (!isSupported) {\n      const message = 'WebSerial API not supported in this browser';\n      toast.error(message);\n      dispatch(setRobotError(message));\n      return false;\n    }\n\n    try {\n      dispatch(setConnectionStatus('connecting'));\n      dispatch(clearRobotError());\n      log('Requesting serial port...', 'info');\n\n      const selectedPort = await navigator.serial.requestPort();\n      \n      await selectedPort.open({\n        baudRate: SERIAL_CONFIG.BAUDRATE,\n        dataBits: SERIAL_CONFIG.DATA_BITS,\n        stopBits: SERIAL_CONFIG.STOP_BITS,\n        parity: SERIAL_CONFIG.PARITY,\n        flowControl: SERIAL_CONFIG.FLOW_CONTROL,\n      });\n\n      setPort(selectedPort);\n      \n      const reader = selectedPort.readable.getReader();\n      const writer = selectedPort.writable.getWriter();\n      \n      readerRef.current = reader;\n      writerRef.current = writer;\n      \n      setIsConnected(true);\n      dispatch(setConnectionStatus('connected'));\n      \n      log('Connected to ESP32 successfully', 'info');\n      toast.success('Connected to ESP32');\n\n      // Start reading data\n      startReading();\n      \n      return true;\n    } catch (error) {\n      errorLog('Connection failed', error);\n      log(`Connection failed: ${error.message}`, 'error');\n      dispatch(setConnectionStatus('disconnected'));\n      dispatch(setRobotError(error.message));\n      toast.error('Connection failed');\n      return false;\n    }\n  }, [isSupported, dispatch, log]);\n\n  // Disconnect from serial port\n  const disconnect = useCallback(async () => {\n    try {\n      setIsReading(false);\n      \n      // Clear command queue\n      commandQueueRef.current = [];\n      processingCommandRef.current = false;\n      \n      if (readerRef.current) {\n        await readerRef.current.cancel();\n        await readerRef.current.releaseLock();\n        readerRef.current = null;\n      }\n      \n      if (writerRef.current) {\n        await writerRef.current.releaseLock();\n        writerRef.current = null;\n      }\n      \n      if (port) {\n        await port.close();\n        setPort(null);\n      }\n      \n      setIsConnected(false);\n      dispatch(setConnectionStatus('disconnected'));\n      dispatch(clearRobotError());\n      \n      log('Disconnected from ESP32', 'info');\n      toast.success('Disconnected');\n      \n    } catch (error) {\n      errorLog('Disconnection error', error);\n      log(`Disconnection error: ${error.message}`, 'error');\n      toast.error('Disconnection error');\n    }\n  }, [port, dispatch, log]);\n\n  // Start reading serial data\n  const startReading = useCallback(async () => {\n    if (!readerRef.current || isReading) return;\n    \n    setIsReading(true);\n    \n    try {\n      while (isConnected && readerRef.current) {\n        const { value, done } = await readerRef.current.read();\n        if (done) break;\n        \n        const text = new TextDecoder().decode(value);\n        handleSerialData(text);\n      }\n    } catch (error) {\n      if (isConnected) {\n        errorLog('Read error', error);\n        log(`Read error: ${error.message}`, 'error');\n      }\n    } finally {\n      setIsReading(false);\n    }\n  }, [isConnected, isReading, log]);\n\n  // Handle incoming serial data\n  const handleSerialData = useCallback((text) => {\n    dataBufferRef.current += text;\n    const lines = dataBufferRef.current.split('\\n');\n    dataBufferRef.current = lines.pop() || '';\n    \n    for (let line of lines) {\n      line = line.trim();\n      if (line) {\n        log(`← ${line}`, 'response');\n        processSerialResponse(line);\n      }\n    }\n  }, [log]);\n\n  // Process serial responses\n  const processSerialResponse = useCallback((response) => {\n    try {\n      if (response === 'PING_OK') {\n        window.dispatchEvent(new CustomEvent('pingResponse', { \n          detail: { success: true } \n        }));\n      } else if (response === 'PING_FAIL') {\n        window.dispatchEvent(new CustomEvent('pingResponse', { \n          detail: { success: false } \n        }));\n      } else if (response === 'OK') {\n        log('Command executed successfully', 'info');\n      } else if (response.startsWith('POS:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const position = parseInt(parts[2]);\n          dispatch(updateRobotState({\n            jointAngles: { [motorId]: position }\n          }));\n          window.dispatchEvent(new CustomEvent('positionUpdate', { \n            detail: { motorId, position } \n          }));\n        }\n      } else if (response.startsWith('VEL:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const velocity = parseInt(parts[2]);\n          window.dispatchEvent(new CustomEvent('velocityUpdate', { \n            detail: { motorId, velocity } \n          }));\n        }\n      } else if (response.startsWith('TEMP:')) {\n        const parts = response.split(':');\n        if (parts.length >= 3) {\n          const motorId = parseInt(parts[1]);\n          const temperature = parseInt(parts[2]);\n          window.dispatchEvent(new CustomEvent('temperatureUpdate', { \n            detail: { motorId, temperature } \n          }));\n        }\n      } else if (response.startsWith('ERROR:')) {\n        const errorMsg = response.substring(6);\n        log(`Hardware error: ${errorMsg}`, 'error');\n        toast.error(`Hardware error: ${errorMsg}`);\n        dispatch(setRobotError(errorMsg));\n      } else if (response === 'ESP32_DYNAMIXEL_CONTROLLER_READY') {\n        log('ESP32 controller ready!', 'info');\n        toast.success('ESP32 ready!');\n        window.dispatchEvent(new CustomEvent('controllerReady'));\n      } else if (response.includes('Motor ID')) {\n        log(response, 'info');\n        const match = response.match(/Motor ID (\\d+):/);\n        if (match && response.includes('Connected')) {\n          const motorId = parseInt(match[1]);\n          window.dispatchEvent(new CustomEvent('motorDetected', { \n            detail: { motorId } \n          }));\n        }\n      } else {\n        debugLog('Unknown response:', response);\n      }\n    } catch (error) {\n      errorLog('Error processing serial response', error);\n    }\n  }, [log, dispatch]);\n\n  // Send command to serial port\n  const sendCommand = useCallback(async (command) => {\n    if (!isConnected) {\n      const error = new Error('Not connected to send command');\n      log(error.message, 'error');\n      throw error;\n    }\n\n    return new Promise((resolve, reject) => {\n      commandQueueRef.current.push({ command, resolve, reject });\n      processCommandQueue();\n    });\n  }, [isConnected, log, processCommandQueue]);\n\n  // Ping a motor\n  const pingMotor = useCallback(async (motorId) => {\n    if (!isConnected) return false;\n\n    return new Promise((resolve) => {\n      const timeout = setTimeout(() => {\n        resolve(false);\n      }, SERIAL_CONFIG.TIMEOUT);\n      \n      const handlePingResponse = (event) => {\n        clearTimeout(timeout);\n        window.removeEventListener('pingResponse', handlePingResponse);\n        resolve(event.detail.success);\n      };\n      \n      window.addEventListener('pingResponse', handlePingResponse);\n      \n      sendCommand(`${COMMANDS.PING}:${motorId}`).catch(() => {\n        clearTimeout(timeout);\n        window.removeEventListener('pingResponse', handlePingResponse);\n        resolve(false);\n      });\n    });\n  }, [isConnected, sendCommand]);\n\n  // Get motor position\n  const getMotorPosition = useCallback(async (motorId) => {\n    if (!isConnected) return null;\n\n    return new Promise((resolve) => {\n      const timeout = setTimeout(() => {\n        resolve(null);\n      }, SERIAL_CONFIG.TIMEOUT);\n      \n      const handlePositionUpdate = (event) => {\n        if (event.detail.motorId === motorId) {\n          clearTimeout(timeout);\n          window.removeEventListener('positionUpdate', handlePositionUpdate);\n          resolve(event.detail.position);\n        }\n      };\n      \n      window.addEventListener('positionUpdate', handlePositionUpdate);\n      \n      sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`).catch(() => {\n        clearTimeout(timeout);\n        window.removeEventListener('positionUpdate', handlePositionUpdate);\n        resolve(null);\n      });\n    });\n  }, [isConnected, sendCommand]);\n\n  // Emergency stop all motors\n  const emergencyStop = useCallback(async () => {\n    if (!isConnected) return;\n\n    try {\n      await sendCommand(COMMANDS.EMERGENCY_STOP);\n      log('Emergency stop executed', 'warning');\n      toast.error('Emergency stop activated!');\n    } catch (error) {\n      errorLog('Emergency stop failed', error);\n    }\n  }, [isConnected, sendCommand, log]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (isConnected) {\n        disconnect();\n      }\n    };\n  }, [isConnected, disconnect]);\n\n  // Auto-reconnect functionality\n  const autoReconnect = useCallback(async () => {\n    if (!isConnected && port) {\n      log('Attempting auto-reconnect...', 'info');\n      try {\n        await connect();\n      } catch (error) {\n        errorLog('Auto-reconnect failed', error);\n      }\n    }\n  }, [isConnected, port, connect, log]);\n\n  return {\n    // State\n    isSupported,\n    isConnected,\n    isReading,\n    port,\n    \n    // Actions\n    connect,\n    disconnect,\n    sendCommand,\n    \n    // Utilities\n    pingMotor,\n    getMotorPosition,\n    emergencyStop,\n    autoReconnect,\n  };\n};\n\nexport default useWebSerial;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}