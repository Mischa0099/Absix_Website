{"ast":null,"code":"// import { useState, useEffect, useCallback, useRef } from 'react';\n// import { useDispatch, useSelector } from 'react-redux';\n// import { useWebSerial } from './useWebSerial';\n// import {\n//   updateConnectionStatus,\n//   setMotors,\n//   updateMotor,\n//   addMotor,\n//   removeMotor,\n//   updateChartData,\n//   addLogEntry,\n//   incrementCommandCount,\n//   updateUptime,\n//   startChallenge,\n//   stopChallenge as stopChallengeAction,\n//   updateChallengeProgress,\n//   updateHardwareStats,\n//   setEmergencyStop,\n//   selectRobot,\n//   selectIsConnected,\n//   selectMotors,\n//   selectChallengeStatus,\n// } from '../store/robotSlice';\n// import { \n//   rawToDegrees, \n//   degreesToPositionRaw, \n//   degreesToVelocityRaw \n// } from '../utils/robotUtils';\n// import { COMMANDS, ROBOT_SPECS, PERFORMANCE } from '../utils/constants';\n// import { now, clamp, throttle, debugLog, errorLog } from '../utils/helpers';\n// import toast from 'react-hot-toast';\n\n// export const useRobotController = () => {\n//   const dispatch = useDispatch();\n//   const robotState = useSelector(selectRobot);\n//   const isConnected = useSelector(selectIsConnected);\n//   const motors = useSelector(selectMotors);\n//   const challengeStatus = useSelector(selectChallengeStatus);\n\n//   const { \n//     isSupported, \n//     connect: connectSerial, \n//     disconnect: disconnectSerial, \n//     sendCommand, \n//     pingMotor: serialPingMotor,\n//     emergencyStop: serialEmergencyStop \n//   } = useWebSerial();\n\n//   const [connectionStartTime, setConnectionStartTime] = useState(null);\n//   const [challengeInterval, setChallengeInterval] = useState(null);\n//   const [uptimeInterval, setUptimeInterval] = useState(null);\n//   const [monitoringInterval, setMonitoringInterval] = useState(null);\n\n//   const performanceRef = useRef({\n//     commandsSent: 0,\n//     commandsSuccessful: 0,\n//     lastPerformanceUpdate: now(),\n//   });\n\n//   // Connection management\n//   useEffect(() => {\n//     if (isConnected && !connectionStartTime) {\n//       setConnectionStartTime(now());\n//       startUptimeCounter();\n//       startPeriodicMonitoring();\n\n//       // Auto-scan for motors after connection\n//       setTimeout(() => {\n//         scanMotors();\n//       }, 2000);\n\n//     } else if (!isConnected && connectionStartTime) {\n//       setConnectionStartTime(null);\n//       stopUptimeCounter();\n//       stopPeriodicMonitoring();\n//       stopChallenge();\n//     }\n//   }, [isConnected, connectionStartTime]);\n\n//   // Uptime counter\n//   const startUptimeCounter = useCallback(() => {\n//     const interval = setInterval(() => {\n//       if (connectionStartTime) {\n//         const uptime = now() - connectionStartTime;\n//         dispatch(updateUptime(uptime));\n//       }\n//     }, 1000);\n//     setUptimeInterval(interval);\n//   }, [connectionStartTime, dispatch]);\n\n//   const stopUptimeCounter = useCallback(() => {\n//     if (uptimeInterval) {\n//       clearInterval(uptimeInterval);\n//       setUptimeInterval(null);\n//     }\n//   }, [uptimeInterval]);\n\n//   // Periodic monitoring\n//   const startPeriodicMonitoring = useCallback(() => {\n//     const interval = setInterval(async () => {\n//       if (!isConnected || motors.length === 0) return;\n\n//       try {\n//         // Monitor each connected motor\n//         for (const motor of motors) {\n//           if (motor.online) {\n//             // Get current position and temperature\n//             await updateMotorData(motor.id);\n//           }\n//         }\n\n//         // Update performance metrics\n//         updatePerformanceMetrics();\n\n//       } catch (error) {\n//         debugLog('Monitoring error:', error);\n//       }\n//     }, robotState.settings.updateRate || 1000);\n\n//     setMonitoringInterval(interval);\n//   }, [isConnected, motors, robotState.settings.updateRate]);\n\n//   const stopPeriodicMonitoring = useCallback(() => {\n//     if (monitoringInterval) {\n//       clearInterval(monitoringInterval);\n//       setMonitoringInterval(null);\n//     }\n//   }, [monitoringInterval]);\n\n//   // Update motor data\n//   const updateMotorData = useCallback(async (motorId) => {\n//     try {\n//       // This would be implemented with actual sensor reading\n//       // For now, we'll simulate or use cached values\n\n//       const motor = motors.find(m => m.id === motorId);\n//       if (!motor) return;\n\n//       // Simulate data updates (in real implementation, this would read from hardware)\n//       const currentTime = now();\n//       const timeDiff = currentTime - motor.lastUpdate;\n\n//       if (timeDiff > 100) { // Update every 100ms\n//         const simulatedData = {\n//           position: motor.position + (Math.random() - 0.5) * 2, // Small random variation\n//           velocity: motor.velocity + (Math.random() - 0.5) * 5,\n//           temperature: 25 + Math.random() * 10,\n//           current: Math.random() * 0.5,\n//         };\n\n//         dispatch(updateMotor({\n//           motorId,\n//           updates: {\n//             ...simulatedData,\n//             lastUpdate: currentTime,\n//           },\n//         }));\n\n//         // Update chart data\n//         dispatch(updateChartData({\n//           time: currentTime,\n//           motorId,\n//           position: simulatedData.position,\n//           velocity: simulatedData.velocity,\n//           temperature: simulatedData.temperature,\n//           current: simulatedData.current,\n//         }));\n//       }\n\n//     } catch (error) {\n//       errorLog(`Failed to update motor ${motorId} data`, error);\n//     }\n//   }, [motors, dispatch]);\n\n//   // Performance metrics update (throttled)\n//   const updatePerformanceMetrics = useCallback(\n//     throttle(() => {\n//       const now_time = now();\n//       const timeDiff = now_time - performanceRef.current.lastPerformanceUpdate;\n\n//       if (timeDiff > 0) {\n//         const commandsPerSecond = (performanceRef.current.commandsSent / timeDiff) * 1000;\n//         const successRate = performanceRef.current.commandsSuccessful / performanceRef.current.commandsSent;\n\n//         // Reset counters\n//         performanceRef.current.commandsSent = 0;\n//         performanceRef.current.commandsSuccessful = 0;\n//         performanceRef.current.lastPerformanceUpdate = now_time;\n\n//         // Dispatch performance update if needed\n//         debugLog('Performance metrics:', { commandsPerSecond, successRate });\n//       }\n//     }, 5000), // Update every 5 seconds\n//     []\n//   );\n\n//   // Connect to robot\n//   const connect = useCallback(async () => {\n//     try {\n//       dispatch(addLogEntry({\n//         message: 'Attempting to connect to robot...',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       const success = await connectSerial();\n\n//       if (success) {\n//         dispatch(addLogEntry({\n//           message: 'Successfully connected to robot',\n//           type: 'info',\n//           timestamp: now(),\n//         }));\n//         toast.success('Robot connected!');\n//       }\n\n//       return success;\n//     } catch (error) {\n//       errorLog('Robot connection failed', error);\n//       dispatch(addLogEntry({\n//         message: `Connection failed: ${error.message}`,\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n//       toast.error('Connection failed');\n//       return false;\n//     }\n//   }, [connectSerial, dispatch]);\n\n//   // Disconnect from robot\n//   const disconnect = useCallback(async () => {\n//     try {\n//       // Stop any running challenge\n//       if (challengeStatus.running) {\n//         await stopChallenge();\n//       }\n\n//       await disconnectSerial();\n\n//       dispatch(addLogEntry({\n//         message: 'Disconnected from robot',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       toast.success('Robot disconnected');\n//     } catch (error) {\n//       errorLog('Disconnect error', error);\n//       toast.error('Disconnect error');\n//     }\n//   }, [disconnectSerial, challengeStatus.running, dispatch]);\n\n//   // Motor scanning\n//   const scanMotors = useCallback(async () => {\n//     if (!isConnected) {\n//       toast.error('Robot not connected');\n//       return;\n//     }\n\n//     dispatch(addLogEntry({\n//       message: 'Scanning for motors (ID 1-10)...',\n//       type: 'info',\n//       timestamp: now(),\n//     }));\n\n//     const detectedMotors = [];\n\n//     try {\n//       for (let id = 1; id <= 10; id++) {\n//         try {\n//           const isOnline = await serialPingMotor(id);\n\n//           if (isOnline) {\n//             const motor = {\n//               id,\n//               model: ROBOT_SPECS.MODEL,\n//               status: 'online',\n//               online: true,\n//               torqueEnabled: false,\n//               position: ROBOT_SPECS.MAX_POSITION / 2,\n//               velocity: 0,\n//               goalPosition: ROBOT_SPECS.MAX_POSITION / 2,\n//               goalVelocity: 0,\n//               temperature: 25,\n//               voltage: 7.0,\n//               current: 0.0,\n//               load: 0,\n//               lastUpdate: now(),\n//               operatingMode: 3, // Position mode\n//             };\n\n//             detectedMotors.push(motor);\n\n//             dispatch(addLogEntry({\n//               message: `✅ Motor ${id} detected`,\n//               type: 'info',\n//               timestamp: now(),\n//             }));\n//           }\n\n//           // Small delay between pings\n//           await new Promise(resolve => setTimeout(resolve, 200));\n\n//         } catch (error) {\n//           debugLog(`Motor ${id} scan failed:`, error);\n//         }\n//       }\n\n//       dispatch(setMotors(detectedMotors));\n\n//       const message = `Scan complete. Found ${detectedMotors.length} motors.`;\n//       dispatch(addLogEntry({\n//         message,\n//         type: detectedMotors.length > 0 ? 'info' : 'warning',\n//         timestamp: now(),\n//       }));\n\n//       if (detectedMotors.length === 0) {\n//         toast.error('No motors detected. Check connections and power.');\n//       } else {\n//         toast.success(`Found ${detectedMotors.length} motors`);\n//       }\n\n//     } catch (error) {\n//       errorLog('Motor scan failed', error);\n//       dispatch(addLogEntry({\n//         message: `Motor scan failed: ${error.message}`,\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n//       toast.error('Motor scan failed');\n//     }\n//   }, [isConnected, serialPingMotor, dispatch]);\n\n//   // Motor control functions\n//   const enableTorque = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.ENABLE_TORQUE}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { torqueEnabled: true }\n//       }));\n\n//       dispatch(addLogEntry({\n//         message: `Torque enabled for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to enable torque for motor ${motorId}`, error);\n//       toast.error(`Failed to enable motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const disableTorque = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.DISABLE_TORQUE}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { torqueEnabled: false }\n//       }));\n\n//       dispatch(addLogEntry({\n//         message: `Torque disabled for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to disable torque for motor ${motorId}`, error);\n//       toast.error(`Failed to disable motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const setMotorPosition = useCallback(async (motorId, degrees) => {\n//     try {\n//       const positionRaw = degreesToPositionRaw(degrees);\n//       const clampedPosition = clamp(positionRaw, 0, ROBOT_SPECS.MAX_POSITION);\n\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.SET_POSITION}:${motorId}:${clampedPosition}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { \n//           goalPosition: rawToDegrees(clampedPosition),\n//           position: rawToDegrees(clampedPosition) // Immediate update for UI responsiveness\n//         }\n//       }));\n\n//       dispatch(addLogEntry({\n//         message: `Motor ${motorId} position set to ${degrees.toFixed(1)}° (raw: ${clampedPosition})`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to set position for motor ${motorId}`, error);\n//       toast.error(`Failed to move motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const setMotorVelocity = useCallback(async (motorId, degreesPerSec) => {\n//     try {\n//       const velocityRaw = degreesToVelocityRaw(degreesPerSec);\n//       const clampedVelocity = clamp(velocityRaw, ROBOT_SPECS.MIN_VELOCITY, ROBOT_SPECS.MAX_VELOCITY);\n\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.SET_VELOCITY}:${motorId}:${clampedVelocity}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { \n//           goalVelocity: degreesPerSec,\n//           velocity: degreesPerSec // Immediate update\n//         }\n//       }));\n\n//       dispatch(addLogEntry({\n//         message: `Motor ${motorId} velocity set to ${degreesPerSec.toFixed(1)}°/s (raw: ${clampedVelocity})`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to set velocity for motor ${motorId}`, error);\n//       toast.error(`Failed to set velocity for motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const homeMotor = useCallback(async (motorId) => {\n//     const homePosition = 180; // Center position in degrees\n//     return await setMotorPosition(motorId, homePosition);\n//   }, [setMotorPosition]);\n\n//   const stopMotor = useCallback(async (motorId) => {\n//     return await setMotorVelocity(motorId, 0);\n//   }, [setMotorVelocity]);\n\n//   const getMotorPosition = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n\n//       dispatch(addLogEntry({\n//         message: `Reading position for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to get position for motor ${motorId}`, error);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   // Global control functions\n//   const enableAllTorque = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n//     let successCount = 0;\n\n//     for (const motor of onlineMotors) {\n//       const success = await enableTorque(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n\n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors enabled');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors enabled`);\n//     }\n//   }, [motors, enableTorque]);\n\n//   const disableAllTorque = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n//     let successCount = 0;\n\n//     for (const motor of onlineMotors) {\n//       const success = await disableTorque(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n\n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors disabled');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors disabled`);\n//     }\n//   }, [motors, disableTorque]);\n\n//   const homeAllMotors = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n\n//     dispatch(addLogEntry({\n//       message: 'Moving all motors to home position...',\n//       type: 'info',\n//       timestamp: now(),\n//     }));\n\n//     let successCount = 0;\n\n//     for (const motor of onlineMotors) {\n//       const success = await homeMotor(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n\n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors homed');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors homed`);\n//     }\n//   }, [motors, homeMotor, dispatch]);\n\n//   const emergencyStop = useCallback(async () => {\n//     try {\n//       dispatch(addLogEntry({\n//         message: '🛑 EMERGENCY STOP ACTIVATED',\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n\n//       dispatch(setEmergencyStop(true));\n\n//       // Stop serial communication emergency stop\n//       await serialEmergencyStop();\n\n//       // Stop any running challenge\n//       if (challengeStatus.running) {\n//         stopChallenge();\n//       }\n\n//       toast.error('Emergency stop activated!');\n\n//     } catch (error) {\n//       errorLog('Emergency stop failed', error);\n//       toast.error('Emergency stop failed!');\n//     }\n//   }, [serialEmergencyStop, challengeStatus.running, dispatch]);\n\n//   // Challenge execution\n//   const startChallengeExecution = useCallback(async (challengeParams) => {\n//     if (!isConnected || challengeStatus.running) {\n//       toast.error('Cannot start challenge: Robot not ready');\n//       return false;\n//     }\n\n//     const requiredMotors = challengeParams.requiredMotors || [1, 2];\n//     const availableMotors = motors.filter(m => \n//       requiredMotors.includes(m.id) && m.online\n//     );\n\n//     if (availableMotors.length < requiredMotors.length) {\n//       toast.error(`Challenge requires motors ${requiredMotors.join(', ')} to be connected`);\n//       return false;\n//     }\n\n//     try {\n//       dispatch(startChallenge(challengeParams));\n\n//       dispatch(addLogEntry({\n//         message: '🚀 Challenge started successfully',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       toast.success('Challenge started!');\n//       return true;\n\n//     } catch (error) {\n//       errorLog('Challenge start failed', error);\n//       toast.error('Failed to start challenge');\n//       return false;\n//     }\n//   }, [isConnected, challengeStatus.running, motors, dispatch]);\n\n//   const stopChallenge = useCallback(async () => {\n//     if (!challengeStatus.running) return;\n\n//     try {\n//       // Stop challenge interval if running\n//       if (challengeInterval) {\n//         clearInterval(challengeInterval);\n//         setChallengeInterval(null);\n//       }\n\n//       // Stop all motors\n//       const onlineMotors = motors.filter(m => m.online);\n//       for (const motor of onlineMotors) {\n//         await stopMotor(motor.id);\n//       }\n\n//       dispatch(stopChallengeAction());\n\n//       dispatch(addLogEntry({\n//         message: '🏁 Challenge stopped',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n\n//       toast.success('Challenge stopped');\n\n//     } catch (error) {\n//       errorLog('Challenge stop failed', error);\n//       toast.error('Error stopping challenge');\n//     }\n//   }, [challengeStatus.running, challengeInterval, motors, stopMotor, dispatch]);\n\n//   // Cleanup on unmount\n//   useEffect(() => {\n//     return () => {\n//       stopUptimeCounter();\n//       stopPeriodicMonitoring();\n//       if (challengeInterval) {\n//         clearInterval(challengeInterval);\n//       }\n//     };\n//   }, [stopUptimeCounter, stopPeriodicMonitoring, challengeInterval]);\n\n//   return {\n//     // Connection state\n//     isSupported,\n//     isConnected,\n//     connectionStatus: robotState.connectionStatus,\n\n//     // Motor state\n//     motors,\n//     connectedMotorCount: robotState.connectedMotorCount,\n\n//     // Challenge state\n//     challengeRunning: challengeStatus.running,\n//     challengeProgress: challengeStatus.progress,\n\n//     // Communication state\n//     logs: robotState.logs,\n//     commandCount: robotState.commandCount,\n//     uptime: robotState.uptime,\n\n//     // Control functions\n//     connect,\n//     disconnect,\n//     scanMotors,\n\n//     // Motor control\n//     enableTorque,\n//     disableTorque,\n//     setMotorPosition,\n//     setMotorVelocity,\n//     homeMotor,\n//     stopMotor,\n//     getMotorPosition,\n\n//     // Global control\n//     enableAllTorque,\n//     disableAllTorque,\n//     homeAllMotors,\n//     emergencyStop,\n\n//     // Challenge control\n//     startChallenge: startChallengeExecution,\n//     stopChallenge,\n//   };\n// };\\","map":{"version":3,"names":[],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/hooks/useRobotController.js"],"sourcesContent":["// import { useState, useEffect, useCallback, useRef } from 'react';\n// import { useDispatch, useSelector } from 'react-redux';\n// import { useWebSerial } from './useWebSerial';\n// import {\n//   updateConnectionStatus,\n//   setMotors,\n//   updateMotor,\n//   addMotor,\n//   removeMotor,\n//   updateChartData,\n//   addLogEntry,\n//   incrementCommandCount,\n//   updateUptime,\n//   startChallenge,\n//   stopChallenge as stopChallengeAction,\n//   updateChallengeProgress,\n//   updateHardwareStats,\n//   setEmergencyStop,\n//   selectRobot,\n//   selectIsConnected,\n//   selectMotors,\n//   selectChallengeStatus,\n// } from '../store/robotSlice';\n// import { \n//   rawToDegrees, \n//   degreesToPositionRaw, \n//   degreesToVelocityRaw \n// } from '../utils/robotUtils';\n// import { COMMANDS, ROBOT_SPECS, PERFORMANCE } from '../utils/constants';\n// import { now, clamp, throttle, debugLog, errorLog } from '../utils/helpers';\n// import toast from 'react-hot-toast';\n\n// export const useRobotController = () => {\n//   const dispatch = useDispatch();\n//   const robotState = useSelector(selectRobot);\n//   const isConnected = useSelector(selectIsConnected);\n//   const motors = useSelector(selectMotors);\n//   const challengeStatus = useSelector(selectChallengeStatus);\n  \n//   const { \n//     isSupported, \n//     connect: connectSerial, \n//     disconnect: disconnectSerial, \n//     sendCommand, \n//     pingMotor: serialPingMotor,\n//     emergencyStop: serialEmergencyStop \n//   } = useWebSerial();\n  \n//   const [connectionStartTime, setConnectionStartTime] = useState(null);\n//   const [challengeInterval, setChallengeInterval] = useState(null);\n//   const [uptimeInterval, setUptimeInterval] = useState(null);\n//   const [monitoringInterval, setMonitoringInterval] = useState(null);\n  \n//   const performanceRef = useRef({\n//     commandsSent: 0,\n//     commandsSuccessful: 0,\n//     lastPerformanceUpdate: now(),\n//   });\n\n//   // Connection management\n//   useEffect(() => {\n//     if (isConnected && !connectionStartTime) {\n//       setConnectionStartTime(now());\n//       startUptimeCounter();\n//       startPeriodicMonitoring();\n      \n//       // Auto-scan for motors after connection\n//       setTimeout(() => {\n//         scanMotors();\n//       }, 2000);\n      \n//     } else if (!isConnected && connectionStartTime) {\n//       setConnectionStartTime(null);\n//       stopUptimeCounter();\n//       stopPeriodicMonitoring();\n//       stopChallenge();\n//     }\n//   }, [isConnected, connectionStartTime]);\n\n//   // Uptime counter\n//   const startUptimeCounter = useCallback(() => {\n//     const interval = setInterval(() => {\n//       if (connectionStartTime) {\n//         const uptime = now() - connectionStartTime;\n//         dispatch(updateUptime(uptime));\n//       }\n//     }, 1000);\n//     setUptimeInterval(interval);\n//   }, [connectionStartTime, dispatch]);\n\n//   const stopUptimeCounter = useCallback(() => {\n//     if (uptimeInterval) {\n//       clearInterval(uptimeInterval);\n//       setUptimeInterval(null);\n//     }\n//   }, [uptimeInterval]);\n\n//   // Periodic monitoring\n//   const startPeriodicMonitoring = useCallback(() => {\n//     const interval = setInterval(async () => {\n//       if (!isConnected || motors.length === 0) return;\n\n//       try {\n//         // Monitor each connected motor\n//         for (const motor of motors) {\n//           if (motor.online) {\n//             // Get current position and temperature\n//             await updateMotorData(motor.id);\n//           }\n//         }\n        \n//         // Update performance metrics\n//         updatePerformanceMetrics();\n        \n//       } catch (error) {\n//         debugLog('Monitoring error:', error);\n//       }\n//     }, robotState.settings.updateRate || 1000);\n    \n//     setMonitoringInterval(interval);\n//   }, [isConnected, motors, robotState.settings.updateRate]);\n\n//   const stopPeriodicMonitoring = useCallback(() => {\n//     if (monitoringInterval) {\n//       clearInterval(monitoringInterval);\n//       setMonitoringInterval(null);\n//     }\n//   }, [monitoringInterval]);\n\n//   // Update motor data\n//   const updateMotorData = useCallback(async (motorId) => {\n//     try {\n//       // This would be implemented with actual sensor reading\n//       // For now, we'll simulate or use cached values\n      \n//       const motor = motors.find(m => m.id === motorId);\n//       if (!motor) return;\n\n//       // Simulate data updates (in real implementation, this would read from hardware)\n//       const currentTime = now();\n//       const timeDiff = currentTime - motor.lastUpdate;\n      \n//       if (timeDiff > 100) { // Update every 100ms\n//         const simulatedData = {\n//           position: motor.position + (Math.random() - 0.5) * 2, // Small random variation\n//           velocity: motor.velocity + (Math.random() - 0.5) * 5,\n//           temperature: 25 + Math.random() * 10,\n//           current: Math.random() * 0.5,\n//         };\n        \n//         dispatch(updateMotor({\n//           motorId,\n//           updates: {\n//             ...simulatedData,\n//             lastUpdate: currentTime,\n//           },\n//         }));\n        \n//         // Update chart data\n//         dispatch(updateChartData({\n//           time: currentTime,\n//           motorId,\n//           position: simulatedData.position,\n//           velocity: simulatedData.velocity,\n//           temperature: simulatedData.temperature,\n//           current: simulatedData.current,\n//         }));\n//       }\n      \n//     } catch (error) {\n//       errorLog(`Failed to update motor ${motorId} data`, error);\n//     }\n//   }, [motors, dispatch]);\n\n//   // Performance metrics update (throttled)\n//   const updatePerformanceMetrics = useCallback(\n//     throttle(() => {\n//       const now_time = now();\n//       const timeDiff = now_time - performanceRef.current.lastPerformanceUpdate;\n      \n//       if (timeDiff > 0) {\n//         const commandsPerSecond = (performanceRef.current.commandsSent / timeDiff) * 1000;\n//         const successRate = performanceRef.current.commandsSuccessful / performanceRef.current.commandsSent;\n        \n//         // Reset counters\n//         performanceRef.current.commandsSent = 0;\n//         performanceRef.current.commandsSuccessful = 0;\n//         performanceRef.current.lastPerformanceUpdate = now_time;\n        \n//         // Dispatch performance update if needed\n//         debugLog('Performance metrics:', { commandsPerSecond, successRate });\n//       }\n//     }, 5000), // Update every 5 seconds\n//     []\n//   );\n\n//   // Connect to robot\n//   const connect = useCallback(async () => {\n//     try {\n//       dispatch(addLogEntry({\n//         message: 'Attempting to connect to robot...',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       const success = await connectSerial();\n      \n//       if (success) {\n//         dispatch(addLogEntry({\n//           message: 'Successfully connected to robot',\n//           type: 'info',\n//           timestamp: now(),\n//         }));\n//         toast.success('Robot connected!');\n//       }\n      \n//       return success;\n//     } catch (error) {\n//       errorLog('Robot connection failed', error);\n//       dispatch(addLogEntry({\n//         message: `Connection failed: ${error.message}`,\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n//       toast.error('Connection failed');\n//       return false;\n//     }\n//   }, [connectSerial, dispatch]);\n\n//   // Disconnect from robot\n//   const disconnect = useCallback(async () => {\n//     try {\n//       // Stop any running challenge\n//       if (challengeStatus.running) {\n//         await stopChallenge();\n//       }\n      \n//       await disconnectSerial();\n      \n//       dispatch(addLogEntry({\n//         message: 'Disconnected from robot',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       toast.success('Robot disconnected');\n//     } catch (error) {\n//       errorLog('Disconnect error', error);\n//       toast.error('Disconnect error');\n//     }\n//   }, [disconnectSerial, challengeStatus.running, dispatch]);\n\n//   // Motor scanning\n//   const scanMotors = useCallback(async () => {\n//     if (!isConnected) {\n//       toast.error('Robot not connected');\n//       return;\n//     }\n\n//     dispatch(addLogEntry({\n//       message: 'Scanning for motors (ID 1-10)...',\n//       type: 'info',\n//       timestamp: now(),\n//     }));\n\n//     const detectedMotors = [];\n\n//     try {\n//       for (let id = 1; id <= 10; id++) {\n//         try {\n//           const isOnline = await serialPingMotor(id);\n          \n//           if (isOnline) {\n//             const motor = {\n//               id,\n//               model: ROBOT_SPECS.MODEL,\n//               status: 'online',\n//               online: true,\n//               torqueEnabled: false,\n//               position: ROBOT_SPECS.MAX_POSITION / 2,\n//               velocity: 0,\n//               goalPosition: ROBOT_SPECS.MAX_POSITION / 2,\n//               goalVelocity: 0,\n//               temperature: 25,\n//               voltage: 7.0,\n//               current: 0.0,\n//               load: 0,\n//               lastUpdate: now(),\n//               operatingMode: 3, // Position mode\n//             };\n            \n//             detectedMotors.push(motor);\n            \n//             dispatch(addLogEntry({\n//               message: `✅ Motor ${id} detected`,\n//               type: 'info',\n//               timestamp: now(),\n//             }));\n//           }\n          \n//           // Small delay between pings\n//           await new Promise(resolve => setTimeout(resolve, 200));\n          \n//         } catch (error) {\n//           debugLog(`Motor ${id} scan failed:`, error);\n//         }\n//       }\n\n//       dispatch(setMotors(detectedMotors));\n      \n//       const message = `Scan complete. Found ${detectedMotors.length} motors.`;\n//       dispatch(addLogEntry({\n//         message,\n//         type: detectedMotors.length > 0 ? 'info' : 'warning',\n//         timestamp: now(),\n//       }));\n      \n//       if (detectedMotors.length === 0) {\n//         toast.error('No motors detected. Check connections and power.');\n//       } else {\n//         toast.success(`Found ${detectedMotors.length} motors`);\n//       }\n      \n//     } catch (error) {\n//       errorLog('Motor scan failed', error);\n//       dispatch(addLogEntry({\n//         message: `Motor scan failed: ${error.message}`,\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n//       toast.error('Motor scan failed');\n//     }\n//   }, [isConnected, serialPingMotor, dispatch]);\n\n//   // Motor control functions\n//   const enableTorque = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.ENABLE_TORQUE}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { torqueEnabled: true }\n//       }));\n      \n//       dispatch(addLogEntry({\n//         message: `Torque enabled for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to enable torque for motor ${motorId}`, error);\n//       toast.error(`Failed to enable motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const disableTorque = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.DISABLE_TORQUE}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { torqueEnabled: false }\n//       }));\n      \n//       dispatch(addLogEntry({\n//         message: `Torque disabled for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to disable torque for motor ${motorId}`, error);\n//       toast.error(`Failed to disable motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const setMotorPosition = useCallback(async (motorId, degrees) => {\n//     try {\n//       const positionRaw = degreesToPositionRaw(degrees);\n//       const clampedPosition = clamp(positionRaw, 0, ROBOT_SPECS.MAX_POSITION);\n      \n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.SET_POSITION}:${motorId}:${clampedPosition}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { \n//           goalPosition: rawToDegrees(clampedPosition),\n//           position: rawToDegrees(clampedPosition) // Immediate update for UI responsiveness\n//         }\n//       }));\n      \n//       dispatch(addLogEntry({\n//         message: `Motor ${motorId} position set to ${degrees.toFixed(1)}° (raw: ${clampedPosition})`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to set position for motor ${motorId}`, error);\n//       toast.error(`Failed to move motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const setMotorVelocity = useCallback(async (motorId, degreesPerSec) => {\n//     try {\n//       const velocityRaw = degreesToVelocityRaw(degreesPerSec);\n//       const clampedVelocity = clamp(velocityRaw, ROBOT_SPECS.MIN_VELOCITY, ROBOT_SPECS.MAX_VELOCITY);\n      \n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.SET_VELOCITY}:${motorId}:${clampedVelocity}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(updateMotor({\n//         motorId,\n//         updates: { \n//           goalVelocity: degreesPerSec,\n//           velocity: degreesPerSec // Immediate update\n//         }\n//       }));\n      \n//       dispatch(addLogEntry({\n//         message: `Motor ${motorId} velocity set to ${degreesPerSec.toFixed(1)}°/s (raw: ${clampedVelocity})`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to set velocity for motor ${motorId}`, error);\n//       toast.error(`Failed to set velocity for motor ${motorId}`);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   const homeMotor = useCallback(async (motorId) => {\n//     const homePosition = 180; // Center position in degrees\n//     return await setMotorPosition(motorId, homePosition);\n//   }, [setMotorPosition]);\n\n//   const stopMotor = useCallback(async (motorId) => {\n//     return await setMotorVelocity(motorId, 0);\n//   }, [setMotorVelocity]);\n\n//   const getMotorPosition = useCallback(async (motorId) => {\n//     try {\n//       performanceRef.current.commandsSent++;\n//       await sendCommand(`${COMMANDS.GET_POSITION}:${motorId}`);\n//       performanceRef.current.commandsSuccessful++;\n      \n//       dispatch(addLogEntry({\n//         message: `Reading position for motor ${motorId}`,\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(incrementCommandCount());\n//       return true;\n//     } catch (error) {\n//       errorLog(`Failed to get position for motor ${motorId}`, error);\n//       return false;\n//     }\n//   }, [sendCommand, dispatch]);\n\n//   // Global control functions\n//   const enableAllTorque = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n//     let successCount = 0;\n    \n//     for (const motor of onlineMotors) {\n//       const success = await enableTorque(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n    \n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors enabled');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors enabled`);\n//     }\n//   }, [motors, enableTorque]);\n\n//   const disableAllTorque = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n//     let successCount = 0;\n    \n//     for (const motor of onlineMotors) {\n//       const success = await disableTorque(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n    \n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors disabled');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors disabled`);\n//     }\n//   }, [motors, disableTorque]);\n\n//   const homeAllMotors = useCallback(async () => {\n//     const onlineMotors = motors.filter(m => m.online);\n    \n//     dispatch(addLogEntry({\n//       message: 'Moving all motors to home position...',\n//       type: 'info',\n//       timestamp: now(),\n//     }));\n    \n//     let successCount = 0;\n    \n//     for (const motor of onlineMotors) {\n//       const success = await homeMotor(motor.id);\n//       if (success) successCount++;\n//       await new Promise(resolve => setTimeout(resolve, 100));\n//     }\n    \n//     if (successCount === onlineMotors.length) {\n//       toast.success('All motors homed');\n//     } else {\n//       toast.warning(`${successCount}/${onlineMotors.length} motors homed`);\n//     }\n//   }, [motors, homeMotor, dispatch]);\n\n//   const emergencyStop = useCallback(async () => {\n//     try {\n//       dispatch(addLogEntry({\n//         message: '🛑 EMERGENCY STOP ACTIVATED',\n//         type: 'error',\n//         timestamp: now(),\n//       }));\n      \n//       dispatch(setEmergencyStop(true));\n      \n//       // Stop serial communication emergency stop\n//       await serialEmergencyStop();\n      \n//       // Stop any running challenge\n//       if (challengeStatus.running) {\n//         stopChallenge();\n//       }\n      \n//       toast.error('Emergency stop activated!');\n      \n//     } catch (error) {\n//       errorLog('Emergency stop failed', error);\n//       toast.error('Emergency stop failed!');\n//     }\n//   }, [serialEmergencyStop, challengeStatus.running, dispatch]);\n\n//   // Challenge execution\n//   const startChallengeExecution = useCallback(async (challengeParams) => {\n//     if (!isConnected || challengeStatus.running) {\n//       toast.error('Cannot start challenge: Robot not ready');\n//       return false;\n//     }\n\n//     const requiredMotors = challengeParams.requiredMotors || [1, 2];\n//     const availableMotors = motors.filter(m => \n//       requiredMotors.includes(m.id) && m.online\n//     );\n\n//     if (availableMotors.length < requiredMotors.length) {\n//       toast.error(`Challenge requires motors ${requiredMotors.join(', ')} to be connected`);\n//       return false;\n//     }\n\n//     try {\n//       dispatch(startChallenge(challengeParams));\n      \n//       dispatch(addLogEntry({\n//         message: '🚀 Challenge started successfully',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       toast.success('Challenge started!');\n//       return true;\n      \n//     } catch (error) {\n//       errorLog('Challenge start failed', error);\n//       toast.error('Failed to start challenge');\n//       return false;\n//     }\n//   }, [isConnected, challengeStatus.running, motors, dispatch]);\n\n//   const stopChallenge = useCallback(async () => {\n//     if (!challengeStatus.running) return;\n\n//     try {\n//       // Stop challenge interval if running\n//       if (challengeInterval) {\n//         clearInterval(challengeInterval);\n//         setChallengeInterval(null);\n//       }\n\n//       // Stop all motors\n//       const onlineMotors = motors.filter(m => m.online);\n//       for (const motor of onlineMotors) {\n//         await stopMotor(motor.id);\n//       }\n      \n//       dispatch(stopChallengeAction());\n      \n//       dispatch(addLogEntry({\n//         message: '🏁 Challenge stopped',\n//         type: 'info',\n//         timestamp: now(),\n//       }));\n      \n//       toast.success('Challenge stopped');\n      \n//     } catch (error) {\n//       errorLog('Challenge stop failed', error);\n//       toast.error('Error stopping challenge');\n//     }\n//   }, [challengeStatus.running, challengeInterval, motors, stopMotor, dispatch]);\n\n//   // Cleanup on unmount\n//   useEffect(() => {\n//     return () => {\n//       stopUptimeCounter();\n//       stopPeriodicMonitoring();\n//       if (challengeInterval) {\n//         clearInterval(challengeInterval);\n//       }\n//     };\n//   }, [stopUptimeCounter, stopPeriodicMonitoring, challengeInterval]);\n\n//   return {\n//     // Connection state\n//     isSupported,\n//     isConnected,\n//     connectionStatus: robotState.connectionStatus,\n    \n//     // Motor state\n//     motors,\n//     connectedMotorCount: robotState.connectedMotorCount,\n    \n//     // Challenge state\n//     challengeRunning: challengeStatus.running,\n//     challengeProgress: challengeStatus.progress,\n    \n//     // Communication state\n//     logs: robotState.logs,\n//     commandCount: robotState.commandCount,\n//     uptime: robotState.uptime,\n    \n//     // Control functions\n//     connect,\n//     disconnect,\n//     scanMotors,\n    \n//     // Motor control\n//     enableTorque,\n//     disableTorque,\n//     setMotorPosition,\n//     setMotorVelocity,\n//     homeMotor,\n//     stopMotor,\n//     getMotorPosition,\n    \n//     // Global control\n//     enableAllTorque,\n//     disableAllTorque,\n//     homeAllMotors,\n//     emergencyStop,\n    \n//     // Challenge control\n//     startChallenge: startChallengeExecution,\n//     stopChallenge,\n//   };\n// };\\"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}