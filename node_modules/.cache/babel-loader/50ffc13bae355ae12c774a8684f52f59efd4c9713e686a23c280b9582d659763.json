{"ast":null,"code":"/**\r\n * Enhanced Robot Service - Backend API Integration\r\n * Handles HTTP API communication with backend and hardware bridge\r\n */\n\nimport axios from 'axios';\nclass RobotService {\n  constructor() {\n    this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api/v1';\n    this.hardwareBridgeURL = process.env.REACT_APP_HARDWARE_BRIDGE_URL || 'http://localhost:8001';\n    this.timeout = 30000; // 30 seconds\n\n    // Create axios instances\n    this.apiClient = axios.create({\n      baseURL: this.baseURL,\n      timeout: this.timeout,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    this.hardwareClient = axios.create({\n      baseURL: this.hardwareBridgeURL,\n      timeout: this.timeout,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n\n    // Request interceptors for authentication\n    this.apiClient.interceptors.request.use(config => {\n      const token = localStorage.getItem('auth_token');\n      if (token) {\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n      return config;\n    }, error => Promise.reject(error));\n\n    // Response interceptors for error handling\n    this.apiClient.interceptors.response.use(response => response, error => {\n      var _error$response;\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        // Handle authentication errors\n        localStorage.removeItem('auth_token');\n        window.location.href = '/login';\n      }\n      return Promise.reject(error);\n    });\n    this.hardwareClient.interceptors.response.use(response => response, error => {\n      console.error('Hardware bridge error:', error);\n      return Promise.reject(error);\n    });\n  }\n\n  /**\r\n   * Connect to robot hardware\r\n   * @returns {Promise<Object>} Connection result\r\n   */\n  async connect() {\n    try {\n      // First check if hardware bridge is available\n      const bridgeStatus = await this.getHardwareBridgeStatus();\n      if (!bridgeStatus.available) {\n        throw new Error('Hardware bridge not available');\n      }\n\n      // Request connection through backend API\n      const response = await this.apiClient.post('/robot/connect', {\n        hardwareBridgeUrl: this.hardwareBridgeURL,\n        timeout: this.timeout\n      });\n      if (response.data.success) {\n        // Verify connection with direct hardware bridge call\n        const hardwareResponse = await this.hardwareClient.post('/robot/connect');\n        return {\n          success: true,\n          robotId: response.data.robotId,\n          hardwareConnected: hardwareResponse.data.connected,\n          capabilities: response.data.capabilities,\n          timestamp: new Date().toISOString()\n        };\n      } else {\n        throw new Error(response.data.error || 'Connection failed');\n      }\n    } catch (error) {\n      console.error('Robot connection failed:', error);\n      return {\n        success: false,\n        error: error.message || 'Connection failed',\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\r\n   * Disconnect from robot hardware\r\n   * @returns {Promise<Object>} Disconnection result\r\n   */\n  async disconnect() {\n    try {\n      // Disconnect through both backend and hardware bridge\n      const [apiResponse, hardwareResponse] = await Promise.allSettled([this.apiClient.post('/robot/disconnect'), this.hardwareClient.post('/robot/disconnect')]);\n      return {\n        success: true,\n        apiDisconnected: apiResponse.status === 'fulfilled',\n        hardwareDisconnected: hardwareResponse.status === 'fulfilled',\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error('Robot disconnection error:', error);\n      return {\n        success: false,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\r\n   * Get current robot status\r\n   * @returns {Promise<Object>} Robot status\r\n   */\n  async getStatus() {\n    try {\n      const response = await this.apiClient.get('/robot/status');\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get robot status:', error);\n      throw new Error('Failed to get robot status');\n    }\n  }\n\n  /**\r\n   * Get hardware bridge status\r\n   * @returns {Promise<Object>} Hardware bridge status\r\n   */\n  async getHardwareBridgeStatus() {\n    try {\n      const response = await this.hardwareClient.get('/status');\n      return {\n        available: true,\n        ...response.data\n      };\n    } catch (error) {\n      return {\n        available: false,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\r\n   * Execute Python code on robot\r\n   * @param {string} code Python code to execute\r\n   * @param {Object} options Execution options\r\n   * @returns {Promise<Object>} Execution result\r\n   */\n  async executeCode(code, options = {}) {\n    try {\n      const requestData = {\n        code,\n        language: 'python',\n        options: {\n          challengeId: options.challengeId,\n          targetPosition: options.targetPosition,\n          safetyEnabled: options.safetyEnabled !== false,\n          maxExecutionTime: options.maxExecutionTime || 30000,\n          ...options\n        },\n        timestamp: new Date().toISOString()\n      };\n\n      // Send through backend API for logging and challenge tracking\n      const apiResponse = await this.apiClient.post('/robot/execute', requestData);\n\n      // If backend allows execution, send to hardware bridge for actual execution\n      if (apiResponse.data.approved) {\n        const hardwareResponse = await this.hardwareClient.post('/robot/execute', {\n          ...requestData,\n          executionId: apiResponse.data.executionId\n        });\n\n        // Calculate position error if target provided\n        let positionError = 0;\n        if (options.targetPosition && hardwareResponse.data.finalPosition) {\n          positionError = this.calculatePositionError(hardwareResponse.data.finalPosition, options.targetPosition);\n        }\n        return {\n          success: true,\n          executionId: apiResponse.data.executionId,\n          finalPosition: hardwareResponse.data.finalPosition,\n          positionError,\n          executionTime: hardwareResponse.data.executionTime,\n          logs: hardwareResponse.data.logs,\n          timestamp: new Date().toISOString()\n        };\n      } else {\n        throw new Error(apiResponse.data.reason || 'Code execution not approved');\n      }\n    } catch (error) {\n      console.error('Code execution failed:', error);\n      return {\n        success: false,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\r\n   * Get current robot position\r\n   * @returns {Promise<Array<number>]} Joint angles in degrees\r\n   */\n  async getCurrentPosition() {\n    try {\n      const response = await this.hardwareClient.get('/robot/position');\n      return response.data.joint_angles || [0, 0, 0];\n    } catch (error) {\n      console.error('Failed to get current position:', error);\n      throw new Error('Failed to get current position');\n    }\n  }\n\n  /**\r\n   * Get real-time telemetry data\r\n   * @returns {Promise<Object>} Telemetry data\r\n   */\n  async getTelemetry() {\n    try {\n      const response = await this.hardwareClient.get('/robot/telemetry');\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get telemetry:', error);\n      throw new Error('Failed to get telemetry');\n    }\n  }\n\n  /**\r\n   * Move individual joint\r\n   * @param {number} jointId Joint ID (1-3)\r\n   * @param {number} angle Target angle in degrees\r\n   * @param {Object} options Movement options\r\n   * @returns {Promise<Object>} Movement result\r\n   */\n  async moveJoint(jointId, angle, options = {}) {\n    try {\n      // Validate joint parameters\n      this.validateJointParameters(jointId, angle);\n      const requestData = {\n        jointId,\n        angle,\n        speed: options.speed || 50,\n        acceleration: options.acceleration || 50,\n        safetyEnabled: options.safetyEnabled !== false\n      };\n\n      // Send through backend for safety validation\n      const apiResponse = await this.apiClient.post('/robot/move-joint', requestData);\n      if (apiResponse.data.approved) {\n        // Execute movement through hardware bridge\n        const hardwareResponse = await this.hardwareClient.post('/robot/move-joint', {\n          ...requestData,\n          movementId: apiResponse.data.movementId\n        });\n        return {\n          success: true,\n          movementId: apiResponse.data.movementId,\n          ...hardwareResponse.data\n        };\n      } else {\n        throw new Error(apiResponse.data.reason || 'Movement not approved');\n      }\n    } catch (error) {\n      console.error('Joint movement failed:', error);\n      throw new Error(`Joint movement failed: ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Move to target position\r\n   * @param {Array<number>} targetAngles Target joint angles\r\n   * @param {Object} options Movement options\r\n   * @returns {Promise<Object>} Movement result\r\n   */\n  async moveToPosition(targetAngles, options = {}) {\n    try {\n      // Validate target angles\n      if (!Array.isArray(targetAngles) || targetAngles.length !== 3) {\n        throw new Error('Target angles must be an array of 3 values');\n      }\n      targetAngles.forEach((angle, index) => {\n        this.validateJointParameters(index + 1, angle);\n      });\n      const requestData = {\n        targetAngles,\n        speed: options.speed || 50,\n        acceleration: options.acceleration || 50,\n        trajectory: options.trajectory || 'linear',\n        safetyEnabled: options.safetyEnabled !== false\n      };\n\n      // Send through backend for safety validation\n      const apiResponse = await this.apiClient.post('/robot/move-to-position', requestData);\n      if (apiResponse.data.approved) {\n        // Execute movement through hardware bridge\n        const hardwareResponse = await this.hardwareClient.post('/robot/move-to-position', {\n          ...requestData,\n          movementId: apiResponse.data.movementId\n        });\n        return {\n          success: true,\n          movementId: apiResponse.data.movementId,\n          ...hardwareResponse.data\n        };\n      } else {\n        throw new Error(apiResponse.data.reason || 'Movement not approved');\n      }\n    } catch (error) {\n      console.error('Position movement failed:', error);\n      throw new Error(`Position movement failed: ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Emergency stop\r\n   * @returns {Promise<Object>} Emergency stop result\r\n   */\n  async emergencyStop() {\n    try {\n      // Send emergency stop to both backend and hardware bridge simultaneously\n      const [apiResponse, hardwareResponse] = await Promise.allSettled([this.apiClient.post('/robot/emergency-stop'), this.hardwareClient.post('/robot/emergency-stop')]);\n      return {\n        success: true,\n        apiStopped: apiResponse.status === 'fulfilled',\n        hardwareStopped: hardwareResponse.status === 'fulfilled',\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error('Emergency stop failed:', error);\n      // Emergency stop should always succeed at hardware level\n      try {\n        await this.hardwareClient.post('/robot/emergency-stop');\n        return {\n          success: true,\n          hardwareStopped: true,\n          apiStopped: false,\n          timestamp: new Date().toISOString()\n        };\n      } catch (hardwareError) {\n        throw new Error('Critical: Emergency stop failed at hardware level');\n      }\n    }\n  }\n\n  /**\r\n   * Calibrate robot\r\n   * @param {Object} options Calibration options\r\n   * @returns {Promise<Object>} Calibration result\r\n   */\n  async calibrate(options = {}) {\n    try {\n      const requestData = {\n        calibrationType: options.type || 'home',\n        joints: options.joints || [1, 2, 3],\n        speed: options.speed || 25,\n        // Slow for safety\n        ...options\n      };\n\n      // Send through backend for approval\n      const apiResponse = await this.apiClient.post('/robot/calibrate', requestData);\n      if (apiResponse.data.approved) {\n        // Execute calibration through hardware bridge\n        const hardwareResponse = await this.hardwareClient.post('/robot/calibrate', {\n          ...requestData,\n          calibrationId: apiResponse.data.calibrationId\n        });\n        return {\n          success: true,\n          calibrationId: apiResponse.data.calibrationId,\n          ...hardwareResponse.data\n        };\n      } else {\n        throw new Error(apiResponse.data.reason || 'Calibration not approved');\n      }\n    } catch (error) {\n      console.error('Calibration failed:', error);\n      throw new Error(`Calibration failed: ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Reset robot to home position\r\n   * @returns {Promise<Object>} Reset result\r\n   */\n  async resetToHome() {\n    try {\n      return await this.moveToPosition([0, 0, 0], {\n        speed: 25,\n        trajectory: 'linear',\n        safetyEnabled: true\n      });\n    } catch (error) {\n      console.error('Reset to home failed:', error);\n      throw new Error(`Reset to home failed: ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Get robot workspace boundaries\r\n   * @returns {Promise<Object>} Workspace boundaries\r\n   */\n  async getWorkspaceBoundaries() {\n    try {\n      const response = await this.apiClient.get('/robot/workspace');\n      return response.data;\n    } catch (error) {\n      // Return default values if API not available\n      return {\n        maxReach: 360,\n        // mm\n        minReach: 0,\n        jointLimits: [{\n          min: -150,\n          max: 150\n        },\n        // Joint 1\n        {\n          min: -120,\n          max: 120\n        },\n        // Joint 2\n        {\n          min: -90,\n          max: 90\n        } // Joint 3\n        ]\n      };\n    }\n  }\n\n  /**\r\n   * Get robot configuration\r\n   * @returns {Promise<Object>} Robot configuration\r\n   */\n  async getRobotConfig() {\n    try {\n      const response = await this.apiClient.get('/robot/config');\n      return response.data;\n    } catch (error) {\n      // Return default configuration\n      return {\n        dof: 3,\n        linkLengths: [140, 120, 100],\n        // mm\n        jointTypes: ['revolute', 'revolute', 'revolute'],\n        baseHeight: 50,\n        // mm\n        endEffectorLength: 20 // mm\n      };\n    }\n  }\n\n  /**\r\n   * Save robot configuration\r\n   * @param {Object} config Configuration to save\r\n   * @returns {Promise<Object>} Save result\r\n   */\n  async saveRobotConfig(config) {\n    try {\n      const response = await this.apiClient.post('/robot/config', config);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to save robot config:', error);\n      throw new Error('Failed to save robot configuration');\n    }\n  }\n\n  /**\r\n   * Get challenge-specific robot data\r\n   * @param {string} challengeId Challenge ID\r\n   * @returns {Promise<Object>} Challenge robot data\r\n   */\n  async getChallengeRobotData(challengeId) {\n    try {\n      const response = await this.apiClient.get(`/challenges/${challengeId}/robot-data`);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get challenge robot data:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Submit challenge robot results\r\n   * @param {string} challengeId Challenge ID\r\n   * @param {Object} results Challenge results\r\n   * @returns {Promise<Object>} Submission result\r\n   */\n  async submitChallengeResults(challengeId, results) {\n    try {\n      const response = await this.apiClient.post(`/challenges/${challengeId}/submit-robot-results`, results);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to submit challenge results:', error);\n      throw new Error('Failed to submit challenge results');\n    }\n  }\n\n  // Utility methods\n\n  /**\r\n   * Validate joint parameters\r\n   * @param {number} jointId Joint ID\r\n   * @param {number} angle Angle in degrees\r\n   */\n  validateJointParameters(jointId, angle) {\n    const jointLimits = {\n      1: {\n        min: -150,\n        max: 150\n      },\n      2: {\n        min: -120,\n        max: 120\n      },\n      3: {\n        min: -90,\n        max: 90\n      }\n    };\n    if (!jointLimits[jointId]) {\n      throw new Error(`Invalid joint ID: ${jointId}`);\n    }\n    const limits = jointLimits[jointId];\n    if (angle < limits.min || angle > limits.max) {\n      throw new Error(`Joint ${jointId} angle ${angle}° outside safe range [${limits.min}°, ${limits.max}°]`);\n    }\n  }\n\n  /**\r\n   * Calculate position error between current and target\r\n   * @param {Array<number>} currentAngles Current joint angles\r\n   * @param {Array<number>} targetAngles Target joint angles\r\n   * @returns {number} Maximum angular error in degrees\r\n   */\n  calculatePositionError(currentAngles, targetAngles) {\n    if (!currentAngles || !targetAngles || currentAngles.length !== targetAngles.length) {\n      return 0;\n    }\n    const errors = currentAngles.map((current, index) => Math.abs(current - targetAngles[index]));\n    return Math.max(...errors);\n  }\n\n  /**\r\n   * Calculate forward kinematics\r\n   * @param {Array<number>} jointAngles Joint angles in degrees\r\n   * @returns {Object} End effector position\r\n   */\n  calculateForwardKinematics(jointAngles) {\n    const [θ1, θ2, θ3] = jointAngles.map(angle => angle * Math.PI / 180);\n    const [L1, L2, L3] = [140, 120, 100]; // Link lengths in mm\n\n    const x = L1 * Math.cos(θ1) + L2 * Math.cos(θ1 + θ2) + L3 * Math.cos(θ1 + θ2 + θ3);\n    const y = L1 * Math.sin(θ1) + L2 * Math.sin(θ1 + θ2) + L3 * Math.sin(θ1 + θ2 + θ3);\n    const z = 0; // Planar robot\n\n    return {\n      x,\n      y,\n      z\n    };\n  }\n\n  /**\r\n   * Check if position is within workspace\r\n   * @param {Object} position Position to check\r\n   * @param {Object} workspace Workspace boundaries\r\n   * @returns {boolean} True if position is reachable\r\n   */\n  isPositionReachable(position, workspace) {\n    const distance = Math.sqrt(position.x ** 2 + position.y ** 2);\n    return distance >= workspace.minReach && distance <= workspace.maxReach;\n  }\n\n  /**\r\n   * Get service health status\r\n   * @returns {Promise<Object>} Service health\r\n   */\n  async getHealthStatus() {\n    try {\n      const [apiHealth, hardwareHealth] = await Promise.allSettled([this.apiClient.get('/health'), this.hardwareClient.get('/health')]);\n      return {\n        api: {\n          available: apiHealth.status === 'fulfilled',\n          status: apiHealth.status === 'fulfilled' ? apiHealth.value.data : null,\n          error: apiHealth.status === 'rejected' ? apiHealth.reason.message : null\n        },\n        hardware: {\n          available: hardwareHealth.status === 'fulfilled',\n          status: hardwareHealth.status === 'fulfilled' ? hardwareHealth.value.data : null,\n          error: hardwareHealth.status === 'rejected' ? hardwareHealth.reason.message : null\n        },\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      return {\n        api: {\n          available: false,\n          error: error.message\n        },\n        hardware: {\n          available: false,\n          error: error.message\n        },\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n}\n\n// Create and export singleton instance\nexport const robotService = new RobotService();\nexport default robotService;","map":{"version":3,"names":["axios","RobotService","constructor","baseURL","process","env","REACT_APP_API_URL","hardwareBridgeURL","REACT_APP_HARDWARE_BRIDGE_URL","timeout","apiClient","create","headers","hardwareClient","interceptors","request","use","config","token","localStorage","getItem","Authorization","error","Promise","reject","response","_error$response","status","removeItem","window","location","href","console","connect","bridgeStatus","getHardwareBridgeStatus","available","Error","post","hardwareBridgeUrl","data","success","hardwareResponse","robotId","hardwareConnected","connected","capabilities","timestamp","Date","toISOString","message","disconnect","apiResponse","allSettled","apiDisconnected","hardwareDisconnected","getStatus","get","executeCode","code","options","requestData","language","challengeId","targetPosition","safetyEnabled","maxExecutionTime","approved","executionId","positionError","finalPosition","calculatePositionError","executionTime","logs","reason","getCurrentPosition","joint_angles","getTelemetry","moveJoint","jointId","angle","validateJointParameters","speed","acceleration","movementId","moveToPosition","targetAngles","Array","isArray","length","forEach","index","trajectory","emergencyStop","apiStopped","hardwareStopped","hardwareError","calibrate","calibrationType","type","joints","calibrationId","resetToHome","getWorkspaceBoundaries","maxReach","minReach","jointLimits","min","max","getRobotConfig","dof","linkLengths","jointTypes","baseHeight","endEffectorLength","saveRobotConfig","getChallengeRobotData","submitChallengeResults","results","limits","currentAngles","errors","map","current","Math","abs","calculateForwardKinematics","jointAngles","θ1","θ2","θ3","PI","L1","L2","L3","x","cos","y","sin","z","isPositionReachable","position","workspace","distance","sqrt","getHealthStatus","apiHealth","hardwareHealth","api","value","hardware","robotService"],"sources":["C:/Users/misch/Downloads/absix-workstation-web-main/absix-workstation-web-main/frontend/src/services/robotService.js"],"sourcesContent":["/**\r\n * Enhanced Robot Service - Backend API Integration\r\n * Handles HTTP API communication with backend and hardware bridge\r\n */\r\n\r\nimport axios from 'axios';\r\n\r\nclass RobotService {\r\n  constructor() {\r\n    this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api/v1';\r\n    this.hardwareBridgeURL = process.env.REACT_APP_HARDWARE_BRIDGE_URL || 'http://localhost:8001';\r\n    this.timeout = 30000; // 30 seconds\r\n    \r\n    // Create axios instances\r\n    this.apiClient = axios.create({\r\n      baseURL: this.baseURL,\r\n      timeout: this.timeout,\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      }\r\n    });\r\n    \r\n    this.hardwareClient = axios.create({\r\n      baseURL: this.hardwareBridgeURL,\r\n      timeout: this.timeout,\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      }\r\n    });\r\n    \r\n    // Request interceptors for authentication\r\n    this.apiClient.interceptors.request.use(\r\n      (config) => {\r\n        const token = localStorage.getItem('auth_token');\r\n        if (token) {\r\n          config.headers.Authorization = `Bearer ${token}`;\r\n        }\r\n        return config;\r\n      },\r\n      (error) => Promise.reject(error)\r\n    );\r\n    \r\n    // Response interceptors for error handling\r\n    this.apiClient.interceptors.response.use(\r\n      (response) => response,\r\n      (error) => {\r\n        if (error.response?.status === 401) {\r\n          // Handle authentication errors\r\n          localStorage.removeItem('auth_token');\r\n          window.location.href = '/login';\r\n        }\r\n        return Promise.reject(error);\r\n      }\r\n    );\r\n    \r\n    this.hardwareClient.interceptors.response.use(\r\n      (response) => response,\r\n      (error) => {\r\n        console.error('Hardware bridge error:', error);\r\n        return Promise.reject(error);\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Connect to robot hardware\r\n   * @returns {Promise<Object>} Connection result\r\n   */\r\n  async connect() {\r\n    try {\r\n      // First check if hardware bridge is available\r\n      const bridgeStatus = await this.getHardwareBridgeStatus();\r\n      \r\n      if (!bridgeStatus.available) {\r\n        throw new Error('Hardware bridge not available');\r\n      }\r\n      \r\n      // Request connection through backend API\r\n      const response = await this.apiClient.post('/robot/connect', {\r\n        hardwareBridgeUrl: this.hardwareBridgeURL,\r\n        timeout: this.timeout\r\n      });\r\n      \r\n      if (response.data.success) {\r\n        // Verify connection with direct hardware bridge call\r\n        const hardwareResponse = await this.hardwareClient.post('/robot/connect');\r\n        \r\n        return {\r\n          success: true,\r\n          robotId: response.data.robotId,\r\n          hardwareConnected: hardwareResponse.data.connected,\r\n          capabilities: response.data.capabilities,\r\n          timestamp: new Date().toISOString()\r\n        };\r\n      } else {\r\n        throw new Error(response.data.error || 'Connection failed');\r\n      }\r\n    } catch (error) {\r\n      console.error('Robot connection failed:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message || 'Connection failed',\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect from robot hardware\r\n   * @returns {Promise<Object>} Disconnection result\r\n   */\r\n  async disconnect() {\r\n    try {\r\n      // Disconnect through both backend and hardware bridge\r\n      const [apiResponse, hardwareResponse] = await Promise.allSettled([\r\n        this.apiClient.post('/robot/disconnect'),\r\n        this.hardwareClient.post('/robot/disconnect')\r\n      ]);\r\n      \r\n      return {\r\n        success: true,\r\n        apiDisconnected: apiResponse.status === 'fulfilled',\r\n        hardwareDisconnected: hardwareResponse.status === 'fulfilled',\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    } catch (error) {\r\n      console.error('Robot disconnection error:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current robot status\r\n   * @returns {Promise<Object>} Robot status\r\n   */\r\n  async getStatus() {\r\n    try {\r\n      const response = await this.apiClient.get('/robot/status');\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Failed to get robot status:', error);\r\n      throw new Error('Failed to get robot status');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get hardware bridge status\r\n   * @returns {Promise<Object>} Hardware bridge status\r\n   */\r\n  async getHardwareBridgeStatus() {\r\n    try {\r\n      const response = await this.hardwareClient.get('/status');\r\n      return {\r\n        available: true,\r\n        ...response.data\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        available: false,\r\n        error: error.message,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute Python code on robot\r\n   * @param {string} code Python code to execute\r\n   * @param {Object} options Execution options\r\n   * @returns {Promise<Object>} Execution result\r\n   */\r\n  async executeCode(code, options = {}) {\r\n    try {\r\n      const requestData = {\r\n        code,\r\n        language: 'python',\r\n        options: {\r\n          challengeId: options.challengeId,\r\n          targetPosition: options.targetPosition,\r\n          safetyEnabled: options.safetyEnabled !== false,\r\n          maxExecutionTime: options.maxExecutionTime || 30000,\r\n          ...options\r\n        },\r\n        timestamp: new Date().toISOString()\r\n      };\r\n\r\n      // Send through backend API for logging and challenge tracking\r\n      const apiResponse = await this.apiClient.post('/robot/execute', requestData);\r\n      \r\n      // If backend allows execution, send to hardware bridge for actual execution\r\n      if (apiResponse.data.approved) {\r\n        const hardwareResponse = await this.hardwareClient.post('/robot/execute', {\r\n          ...requestData,\r\n          executionId: apiResponse.data.executionId\r\n        });\r\n        \r\n        // Calculate position error if target provided\r\n        let positionError = 0;\r\n        if (options.targetPosition && hardwareResponse.data.finalPosition) {\r\n          positionError = this.calculatePositionError(\r\n            hardwareResponse.data.finalPosition,\r\n            options.targetPosition\r\n          );\r\n        }\r\n        \r\n        return {\r\n          success: true,\r\n          executionId: apiResponse.data.executionId,\r\n          finalPosition: hardwareResponse.data.finalPosition,\r\n          positionError,\r\n          executionTime: hardwareResponse.data.executionTime,\r\n          logs: hardwareResponse.data.logs,\r\n          timestamp: new Date().toISOString()\r\n        };\r\n      } else {\r\n        throw new Error(apiResponse.data.reason || 'Code execution not approved');\r\n      }\r\n    } catch (error) {\r\n      console.error('Code execution failed:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current robot position\r\n   * @returns {Promise<Array<number>]} Joint angles in degrees\r\n   */\r\n  async getCurrentPosition() {\r\n    try {\r\n      const response = await this.hardwareClient.get('/robot/position');\r\n      return response.data.joint_angles || [0, 0, 0];\r\n    } catch (error) {\r\n      console.error('Failed to get current position:', error);\r\n      throw new Error('Failed to get current position');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get real-time telemetry data\r\n   * @returns {Promise<Object>} Telemetry data\r\n   */\r\n  async getTelemetry() {\r\n    try {\r\n      const response = await this.hardwareClient.get('/robot/telemetry');\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Failed to get telemetry:', error);\r\n      throw new Error('Failed to get telemetry');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move individual joint\r\n   * @param {number} jointId Joint ID (1-3)\r\n   * @param {number} angle Target angle in degrees\r\n   * @param {Object} options Movement options\r\n   * @returns {Promise<Object>} Movement result\r\n   */\r\n  async moveJoint(jointId, angle, options = {}) {\r\n    try {\r\n      // Validate joint parameters\r\n      this.validateJointParameters(jointId, angle);\r\n      \r\n      const requestData = {\r\n        jointId,\r\n        angle,\r\n        speed: options.speed || 50,\r\n        acceleration: options.acceleration || 50,\r\n        safetyEnabled: options.safetyEnabled !== false\r\n      };\r\n\r\n      // Send through backend for safety validation\r\n      const apiResponse = await this.apiClient.post('/robot/move-joint', requestData);\r\n      \r\n      if (apiResponse.data.approved) {\r\n        // Execute movement through hardware bridge\r\n        const hardwareResponse = await this.hardwareClient.post('/robot/move-joint', {\r\n          ...requestData,\r\n          movementId: apiResponse.data.movementId\r\n        });\r\n        \r\n        return {\r\n          success: true,\r\n          movementId: apiResponse.data.movementId,\r\n          ...hardwareResponse.data\r\n        };\r\n      } else {\r\n        throw new Error(apiResponse.data.reason || 'Movement not approved');\r\n      }\r\n    } catch (error) {\r\n      console.error('Joint movement failed:', error);\r\n      throw new Error(`Joint movement failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move to target position\r\n   * @param {Array<number>} targetAngles Target joint angles\r\n   * @param {Object} options Movement options\r\n   * @returns {Promise<Object>} Movement result\r\n   */\r\n  async moveToPosition(targetAngles, options = {}) {\r\n    try {\r\n      // Validate target angles\r\n      if (!Array.isArray(targetAngles) || targetAngles.length !== 3) {\r\n        throw new Error('Target angles must be an array of 3 values');\r\n      }\r\n      \r\n      targetAngles.forEach((angle, index) => {\r\n        this.validateJointParameters(index + 1, angle);\r\n      });\r\n      \r\n      const requestData = {\r\n        targetAngles,\r\n        speed: options.speed || 50,\r\n        acceleration: options.acceleration || 50,\r\n        trajectory: options.trajectory || 'linear',\r\n        safetyEnabled: options.safetyEnabled !== false\r\n      };\r\n\r\n      // Send through backend for safety validation\r\n      const apiResponse = await this.apiClient.post('/robot/move-to-position', requestData);\r\n      \r\n      if (apiResponse.data.approved) {\r\n        // Execute movement through hardware bridge\r\n        const hardwareResponse = await this.hardwareClient.post('/robot/move-to-position', {\r\n          ...requestData,\r\n          movementId: apiResponse.data.movementId\r\n        });\r\n        \r\n        return {\r\n          success: true,\r\n          movementId: apiResponse.data.movementId,\r\n          ...hardwareResponse.data\r\n        };\r\n      } else {\r\n        throw new Error(apiResponse.data.reason || 'Movement not approved');\r\n      }\r\n    } catch (error) {\r\n      console.error('Position movement failed:', error);\r\n      throw new Error(`Position movement failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Emergency stop\r\n   * @returns {Promise<Object>} Emergency stop result\r\n   */\r\n  async emergencyStop() {\r\n    try {\r\n      // Send emergency stop to both backend and hardware bridge simultaneously\r\n      const [apiResponse, hardwareResponse] = await Promise.allSettled([\r\n        this.apiClient.post('/robot/emergency-stop'),\r\n        this.hardwareClient.post('/robot/emergency-stop')\r\n      ]);\r\n      \r\n      return {\r\n        success: true,\r\n        apiStopped: apiResponse.status === 'fulfilled',\r\n        hardwareStopped: hardwareResponse.status === 'fulfilled',\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    } catch (error) {\r\n      console.error('Emergency stop failed:', error);\r\n      // Emergency stop should always succeed at hardware level\r\n      try {\r\n        await this.hardwareClient.post('/robot/emergency-stop');\r\n        return {\r\n          success: true,\r\n          hardwareStopped: true,\r\n          apiStopped: false,\r\n          timestamp: new Date().toISOString()\r\n        };\r\n      } catch (hardwareError) {\r\n        throw new Error('Critical: Emergency stop failed at hardware level');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calibrate robot\r\n   * @param {Object} options Calibration options\r\n   * @returns {Promise<Object>} Calibration result\r\n   */\r\n  async calibrate(options = {}) {\r\n    try {\r\n      const requestData = {\r\n        calibrationType: options.type || 'home',\r\n        joints: options.joints || [1, 2, 3],\r\n        speed: options.speed || 25, // Slow for safety\r\n        ...options\r\n      };\r\n\r\n      // Send through backend for approval\r\n      const apiResponse = await this.apiClient.post('/robot/calibrate', requestData);\r\n      \r\n      if (apiResponse.data.approved) {\r\n        // Execute calibration through hardware bridge\r\n        const hardwareResponse = await this.hardwareClient.post('/robot/calibrate', {\r\n          ...requestData,\r\n          calibrationId: apiResponse.data.calibrationId\r\n        });\r\n        \r\n        return {\r\n          success: true,\r\n          calibrationId: apiResponse.data.calibrationId,\r\n          ...hardwareResponse.data\r\n        };\r\n      } else {\r\n        throw new Error(apiResponse.data.reason || 'Calibration not approved');\r\n      }\r\n    } catch (error) {\r\n      console.error('Calibration failed:', error);\r\n      throw new Error(`Calibration failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset robot to home position\r\n   * @returns {Promise<Object>} Reset result\r\n   */\r\n  async resetToHome() {\r\n    try {\r\n      return await this.moveToPosition([0, 0, 0], {\r\n        speed: 25,\r\n        trajectory: 'linear',\r\n        safetyEnabled: true\r\n      });\r\n    } catch (error) {\r\n      console.error('Reset to home failed:', error);\r\n      throw new Error(`Reset to home failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get robot workspace boundaries\r\n   * @returns {Promise<Object>} Workspace boundaries\r\n   */\r\n  async getWorkspaceBoundaries() {\r\n    try {\r\n      const response = await this.apiClient.get('/robot/workspace');\r\n      return response.data;\r\n    } catch (error) {\r\n      // Return default values if API not available\r\n      return {\r\n        maxReach: 360, // mm\r\n        minReach: 0,\r\n        jointLimits: [\r\n          { min: -150, max: 150 }, // Joint 1\r\n          { min: -120, max: 120 }, // Joint 2\r\n          { min: -90, max: 90 }    // Joint 3\r\n        ]\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get robot configuration\r\n   * @returns {Promise<Object>} Robot configuration\r\n   */\r\n  async getRobotConfig() {\r\n    try {\r\n      const response = await this.apiClient.get('/robot/config');\r\n      return response.data;\r\n    } catch (error) {\r\n      // Return default configuration\r\n      return {\r\n        dof: 3,\r\n        linkLengths: [140, 120, 100], // mm\r\n        jointTypes: ['revolute', 'revolute', 'revolute'],\r\n        baseHeight: 50, // mm\r\n        endEffectorLength: 20 // mm\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save robot configuration\r\n   * @param {Object} config Configuration to save\r\n   * @returns {Promise<Object>} Save result\r\n   */\r\n  async saveRobotConfig(config) {\r\n    try {\r\n      const response = await this.apiClient.post('/robot/config', config);\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Failed to save robot config:', error);\r\n      throw new Error('Failed to save robot configuration');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get challenge-specific robot data\r\n   * @param {string} challengeId Challenge ID\r\n   * @returns {Promise<Object>} Challenge robot data\r\n   */\r\n  async getChallengeRobotData(challengeId) {\r\n    try {\r\n      const response = await this.apiClient.get(`/challenges/${challengeId}/robot-data`);\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Failed to get challenge robot data:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Submit challenge robot results\r\n   * @param {string} challengeId Challenge ID\r\n   * @param {Object} results Challenge results\r\n   * @returns {Promise<Object>} Submission result\r\n   */\r\n  async submitChallengeResults(challengeId, results) {\r\n    try {\r\n      const response = await this.apiClient.post(`/challenges/${challengeId}/submit-robot-results`, results);\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Failed to submit challenge results:', error);\r\n      throw new Error('Failed to submit challenge results');\r\n    }\r\n  }\r\n\r\n  // Utility methods\r\n\r\n  /**\r\n   * Validate joint parameters\r\n   * @param {number} jointId Joint ID\r\n   * @param {number} angle Angle in degrees\r\n   */\r\n  validateJointParameters(jointId, angle) {\r\n    const jointLimits = {\r\n      1: { min: -150, max: 150 },\r\n      2: { min: -120, max: 120 },\r\n      3: { min: -90, max: 90 }\r\n    };\r\n    \r\n    if (!jointLimits[jointId]) {\r\n      throw new Error(`Invalid joint ID: ${jointId}`);\r\n    }\r\n    \r\n    const limits = jointLimits[jointId];\r\n    if (angle < limits.min || angle > limits.max) {\r\n      throw new Error(`Joint ${jointId} angle ${angle}° outside safe range [${limits.min}°, ${limits.max}°]`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate position error between current and target\r\n   * @param {Array<number>} currentAngles Current joint angles\r\n   * @param {Array<number>} targetAngles Target joint angles\r\n   * @returns {number} Maximum angular error in degrees\r\n   */\r\n  calculatePositionError(currentAngles, targetAngles) {\r\n    if (!currentAngles || !targetAngles || currentAngles.length !== targetAngles.length) {\r\n      return 0;\r\n    }\r\n    \r\n    const errors = currentAngles.map((current, index) => \r\n      Math.abs(current - targetAngles[index])\r\n    );\r\n    \r\n    return Math.max(...errors);\r\n  }\r\n\r\n  /**\r\n   * Calculate forward kinematics\r\n   * @param {Array<number>} jointAngles Joint angles in degrees\r\n   * @returns {Object} End effector position\r\n   */\r\n  calculateForwardKinematics(jointAngles) {\r\n    const [θ1, θ2, θ3] = jointAngles.map(angle => angle * Math.PI / 180);\r\n    const [L1, L2, L3] = [140, 120, 100]; // Link lengths in mm\r\n    \r\n    const x = L1 * Math.cos(θ1) + L2 * Math.cos(θ1 + θ2) + L3 * Math.cos(θ1 + θ2 + θ3);\r\n    const y = L1 * Math.sin(θ1) + L2 * Math.sin(θ1 + θ2) + L3 * Math.sin(θ1 + θ2 + θ3);\r\n    const z = 0; // Planar robot\r\n    \r\n    return { x, y, z };\r\n  }\r\n\r\n  /**\r\n   * Check if position is within workspace\r\n   * @param {Object} position Position to check\r\n   * @param {Object} workspace Workspace boundaries\r\n   * @returns {boolean} True if position is reachable\r\n   */\r\n  isPositionReachable(position, workspace) {\r\n    const distance = Math.sqrt(position.x ** 2 + position.y ** 2);\r\n    return distance >= workspace.minReach && distance <= workspace.maxReach;\r\n  }\r\n\r\n  /**\r\n   * Get service health status\r\n   * @returns {Promise<Object>} Service health\r\n   */\r\n  async getHealthStatus() {\r\n    try {\r\n      const [apiHealth, hardwareHealth] = await Promise.allSettled([\r\n        this.apiClient.get('/health'),\r\n        this.hardwareClient.get('/health')\r\n      ]);\r\n      \r\n      return {\r\n        api: {\r\n          available: apiHealth.status === 'fulfilled',\r\n          status: apiHealth.status === 'fulfilled' ? apiHealth.value.data : null,\r\n          error: apiHealth.status === 'rejected' ? apiHealth.reason.message : null\r\n        },\r\n        hardware: {\r\n          available: hardwareHealth.status === 'fulfilled',\r\n          status: hardwareHealth.status === 'fulfilled' ? hardwareHealth.value.data : null,\r\n          error: hardwareHealth.status === 'rejected' ? hardwareHealth.reason.message : null\r\n        },\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        api: { available: false, error: error.message },\r\n        hardware: { available: false, error: error.message },\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Create and export singleton instance\r\nexport const robotService = new RobotService();\r\nexport default robotService;"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,YAAY,CAAC;EACjBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,OAAO,GAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,IAAI,8BAA8B;IAC9E,IAAI,CAACC,iBAAiB,GAAGH,OAAO,CAACC,GAAG,CAACG,6BAA6B,IAAI,uBAAuB;IAC7F,IAAI,CAACC,OAAO,GAAG,KAAK,CAAC,CAAC;;IAEtB;IACA,IAAI,CAACC,SAAS,GAAGV,KAAK,CAACW,MAAM,CAAC;MAC5BR,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBM,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBG,OAAO,EAAE;QACP,cAAc,EAAE;MAClB;IACF,CAAC,CAAC;IAEF,IAAI,CAACC,cAAc,GAAGb,KAAK,CAACW,MAAM,CAAC;MACjCR,OAAO,EAAE,IAAI,CAACI,iBAAiB;MAC/BE,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBG,OAAO,EAAE;QACP,cAAc,EAAE;MAClB;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAACF,SAAS,CAACI,YAAY,CAACC,OAAO,CAACC,GAAG,CACpCC,MAAM,IAAK;MACV,MAAMC,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,YAAY,CAAC;MAChD,IAAIF,KAAK,EAAE;QACTD,MAAM,CAACL,OAAO,CAACS,aAAa,GAAG,UAAUH,KAAK,EAAE;MAClD;MACA,OAAOD,MAAM;IACf,CAAC,EACAK,KAAK,IAAKC,OAAO,CAACC,MAAM,CAACF,KAAK,CACjC,CAAC;;IAED;IACA,IAAI,CAACZ,SAAS,CAACI,YAAY,CAACW,QAAQ,CAACT,GAAG,CACrCS,QAAQ,IAAKA,QAAQ,EACrBH,KAAK,IAAK;MAAA,IAAAI,eAAA;MACT,IAAI,EAAAA,eAAA,GAAAJ,KAAK,CAACG,QAAQ,cAAAC,eAAA,uBAAdA,eAAA,CAAgBC,MAAM,MAAK,GAAG,EAAE;QAClC;QACAR,YAAY,CAACS,UAAU,CAAC,YAAY,CAAC;QACrCC,MAAM,CAACC,QAAQ,CAACC,IAAI,GAAG,QAAQ;MACjC;MACA,OAAOR,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;IAC9B,CACF,CAAC;IAED,IAAI,CAACT,cAAc,CAACC,YAAY,CAACW,QAAQ,CAACT,GAAG,CAC1CS,QAAQ,IAAKA,QAAQ,EACrBH,KAAK,IAAK;MACTU,OAAO,CAACV,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,OAAOC,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;IAC9B,CACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;EACE,MAAMW,OAAOA,CAAA,EAAG;IACd,IAAI;MACF;MACA,MAAMC,YAAY,GAAG,MAAM,IAAI,CAACC,uBAAuB,CAAC,CAAC;MAEzD,IAAI,CAACD,YAAY,CAACE,SAAS,EAAE;QAC3B,MAAM,IAAIC,KAAK,CAAC,+BAA+B,CAAC;MAClD;;MAEA;MACA,MAAMZ,QAAQ,GAAG,MAAM,IAAI,CAACf,SAAS,CAAC4B,IAAI,CAAC,gBAAgB,EAAE;QAC3DC,iBAAiB,EAAE,IAAI,CAAChC,iBAAiB;QACzCE,OAAO,EAAE,IAAI,CAACA;MAChB,CAAC,CAAC;MAEF,IAAIgB,QAAQ,CAACe,IAAI,CAACC,OAAO,EAAE;QACzB;QACA,MAAMC,gBAAgB,GAAG,MAAM,IAAI,CAAC7B,cAAc,CAACyB,IAAI,CAAC,gBAAgB,CAAC;QAEzE,OAAO;UACLG,OAAO,EAAE,IAAI;UACbE,OAAO,EAAElB,QAAQ,CAACe,IAAI,CAACG,OAAO;UAC9BC,iBAAiB,EAAEF,gBAAgB,CAACF,IAAI,CAACK,SAAS;UAClDC,YAAY,EAAErB,QAAQ,CAACe,IAAI,CAACM,YAAY;UACxCC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;QACpC,CAAC;MACH,CAAC,MAAM;QACL,MAAM,IAAIZ,KAAK,CAACZ,QAAQ,CAACe,IAAI,CAAClB,KAAK,IAAI,mBAAmB,CAAC;MAC7D;IACF,CAAC,CAAC,OAAOA,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,OAAO;QACLmB,OAAO,EAAE,KAAK;QACdnB,KAAK,EAAEA,KAAK,CAAC4B,OAAO,IAAI,mBAAmB;QAC3CH,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAME,UAAUA,CAAA,EAAG;IACjB,IAAI;MACF;MACA,MAAM,CAACC,WAAW,EAAEV,gBAAgB,CAAC,GAAG,MAAMnB,OAAO,CAAC8B,UAAU,CAAC,CAC/D,IAAI,CAAC3C,SAAS,CAAC4B,IAAI,CAAC,mBAAmB,CAAC,EACxC,IAAI,CAACzB,cAAc,CAACyB,IAAI,CAAC,mBAAmB,CAAC,CAC9C,CAAC;MAEF,OAAO;QACLG,OAAO,EAAE,IAAI;QACba,eAAe,EAAEF,WAAW,CAACzB,MAAM,KAAK,WAAW;QACnD4B,oBAAoB,EAAEb,gBAAgB,CAACf,MAAM,KAAK,WAAW;QAC7DoB,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;IACH,CAAC,CAAC,OAAO3B,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MAClD,OAAO;QACLmB,OAAO,EAAE,KAAK;QACdnB,KAAK,EAAEA,KAAK,CAAC4B,OAAO;QACpBH,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMO,SAASA,CAAA,EAAG;IAChB,IAAI;MACF,MAAM/B,QAAQ,GAAG,MAAM,IAAI,CAACf,SAAS,CAAC+C,GAAG,CAAC,eAAe,CAAC;MAC1D,OAAOhC,QAAQ,CAACe,IAAI;IACtB,CAAC,CAAC,OAAOlB,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnD,MAAM,IAAIe,KAAK,CAAC,4BAA4B,CAAC;IAC/C;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMF,uBAAuBA,CAAA,EAAG;IAC9B,IAAI;MACF,MAAMV,QAAQ,GAAG,MAAM,IAAI,CAACZ,cAAc,CAAC4C,GAAG,CAAC,SAAS,CAAC;MACzD,OAAO;QACLrB,SAAS,EAAE,IAAI;QACf,GAAGX,QAAQ,CAACe;MACd,CAAC;IACH,CAAC,CAAC,OAAOlB,KAAK,EAAE;MACd,OAAO;QACLc,SAAS,EAAE,KAAK;QAChBd,KAAK,EAAEA,KAAK,CAAC4B,OAAO;QACpBH,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMS,WAAWA,CAACC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACpC,IAAI;MACF,MAAMC,WAAW,GAAG;QAClBF,IAAI;QACJG,QAAQ,EAAE,QAAQ;QAClBF,OAAO,EAAE;UACPG,WAAW,EAAEH,OAAO,CAACG,WAAW;UAChCC,cAAc,EAAEJ,OAAO,CAACI,cAAc;UACtCC,aAAa,EAAEL,OAAO,CAACK,aAAa,KAAK,KAAK;UAC9CC,gBAAgB,EAAEN,OAAO,CAACM,gBAAgB,IAAI,KAAK;UACnD,GAAGN;QACL,CAAC;QACDb,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;;MAED;MACA,MAAMG,WAAW,GAAG,MAAM,IAAI,CAAC1C,SAAS,CAAC4B,IAAI,CAAC,gBAAgB,EAAEuB,WAAW,CAAC;;MAE5E;MACA,IAAIT,WAAW,CAACZ,IAAI,CAAC2B,QAAQ,EAAE;QAC7B,MAAMzB,gBAAgB,GAAG,MAAM,IAAI,CAAC7B,cAAc,CAACyB,IAAI,CAAC,gBAAgB,EAAE;UACxE,GAAGuB,WAAW;UACdO,WAAW,EAAEhB,WAAW,CAACZ,IAAI,CAAC4B;QAChC,CAAC,CAAC;;QAEF;QACA,IAAIC,aAAa,GAAG,CAAC;QACrB,IAAIT,OAAO,CAACI,cAAc,IAAItB,gBAAgB,CAACF,IAAI,CAAC8B,aAAa,EAAE;UACjED,aAAa,GAAG,IAAI,CAACE,sBAAsB,CACzC7B,gBAAgB,CAACF,IAAI,CAAC8B,aAAa,EACnCV,OAAO,CAACI,cACV,CAAC;QACH;QAEA,OAAO;UACLvB,OAAO,EAAE,IAAI;UACb2B,WAAW,EAAEhB,WAAW,CAACZ,IAAI,CAAC4B,WAAW;UACzCE,aAAa,EAAE5B,gBAAgB,CAACF,IAAI,CAAC8B,aAAa;UAClDD,aAAa;UACbG,aAAa,EAAE9B,gBAAgB,CAACF,IAAI,CAACgC,aAAa;UAClDC,IAAI,EAAE/B,gBAAgB,CAACF,IAAI,CAACiC,IAAI;UAChC1B,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;QACpC,CAAC;MACH,CAAC,MAAM;QACL,MAAM,IAAIZ,KAAK,CAACe,WAAW,CAACZ,IAAI,CAACkC,MAAM,IAAI,6BAA6B,CAAC;MAC3E;IACF,CAAC,CAAC,OAAOpD,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,OAAO;QACLmB,OAAO,EAAE,KAAK;QACdnB,KAAK,EAAEA,KAAK,CAAC4B,OAAO;QACpBH,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAM0B,kBAAkBA,CAAA,EAAG;IACzB,IAAI;MACF,MAAMlD,QAAQ,GAAG,MAAM,IAAI,CAACZ,cAAc,CAAC4C,GAAG,CAAC,iBAAiB,CAAC;MACjE,OAAOhC,QAAQ,CAACe,IAAI,CAACoC,YAAY,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAChD,CAAC,CAAC,OAAOtD,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvD,MAAM,IAAIe,KAAK,CAAC,gCAAgC,CAAC;IACnD;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMwC,YAAYA,CAAA,EAAG;IACnB,IAAI;MACF,MAAMpD,QAAQ,GAAG,MAAM,IAAI,CAACZ,cAAc,CAAC4C,GAAG,CAAC,kBAAkB,CAAC;MAClE,OAAOhC,QAAQ,CAACe,IAAI;IACtB,CAAC,CAAC,OAAOlB,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,MAAM,IAAIe,KAAK,CAAC,yBAAyB,CAAC;IAC5C;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMyC,SAASA,CAACC,OAAO,EAAEC,KAAK,EAAEpB,OAAO,GAAG,CAAC,CAAC,EAAE;IAC5C,IAAI;MACF;MACA,IAAI,CAACqB,uBAAuB,CAACF,OAAO,EAAEC,KAAK,CAAC;MAE5C,MAAMnB,WAAW,GAAG;QAClBkB,OAAO;QACPC,KAAK;QACLE,KAAK,EAAEtB,OAAO,CAACsB,KAAK,IAAI,EAAE;QAC1BC,YAAY,EAAEvB,OAAO,CAACuB,YAAY,IAAI,EAAE;QACxClB,aAAa,EAAEL,OAAO,CAACK,aAAa,KAAK;MAC3C,CAAC;;MAED;MACA,MAAMb,WAAW,GAAG,MAAM,IAAI,CAAC1C,SAAS,CAAC4B,IAAI,CAAC,mBAAmB,EAAEuB,WAAW,CAAC;MAE/E,IAAIT,WAAW,CAACZ,IAAI,CAAC2B,QAAQ,EAAE;QAC7B;QACA,MAAMzB,gBAAgB,GAAG,MAAM,IAAI,CAAC7B,cAAc,CAACyB,IAAI,CAAC,mBAAmB,EAAE;UAC3E,GAAGuB,WAAW;UACduB,UAAU,EAAEhC,WAAW,CAACZ,IAAI,CAAC4C;QAC/B,CAAC,CAAC;QAEF,OAAO;UACL3C,OAAO,EAAE,IAAI;UACb2C,UAAU,EAAEhC,WAAW,CAACZ,IAAI,CAAC4C,UAAU;UACvC,GAAG1C,gBAAgB,CAACF;QACtB,CAAC;MACH,CAAC,MAAM;QACL,MAAM,IAAIH,KAAK,CAACe,WAAW,CAACZ,IAAI,CAACkC,MAAM,IAAI,uBAAuB,CAAC;MACrE;IACF,CAAC,CAAC,OAAOpD,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,MAAM,IAAIe,KAAK,CAAC,0BAA0Bf,KAAK,CAAC4B,OAAO,EAAE,CAAC;IAC5D;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMmC,cAAcA,CAACC,YAAY,EAAE1B,OAAO,GAAG,CAAC,CAAC,EAAE;IAC/C,IAAI;MACF;MACA,IAAI,CAAC2B,KAAK,CAACC,OAAO,CAACF,YAAY,CAAC,IAAIA,YAAY,CAACG,MAAM,KAAK,CAAC,EAAE;QAC7D,MAAM,IAAIpD,KAAK,CAAC,4CAA4C,CAAC;MAC/D;MAEAiD,YAAY,CAACI,OAAO,CAAC,CAACV,KAAK,EAAEW,KAAK,KAAK;QACrC,IAAI,CAACV,uBAAuB,CAACU,KAAK,GAAG,CAAC,EAAEX,KAAK,CAAC;MAChD,CAAC,CAAC;MAEF,MAAMnB,WAAW,GAAG;QAClByB,YAAY;QACZJ,KAAK,EAAEtB,OAAO,CAACsB,KAAK,IAAI,EAAE;QAC1BC,YAAY,EAAEvB,OAAO,CAACuB,YAAY,IAAI,EAAE;QACxCS,UAAU,EAAEhC,OAAO,CAACgC,UAAU,IAAI,QAAQ;QAC1C3B,aAAa,EAAEL,OAAO,CAACK,aAAa,KAAK;MAC3C,CAAC;;MAED;MACA,MAAMb,WAAW,GAAG,MAAM,IAAI,CAAC1C,SAAS,CAAC4B,IAAI,CAAC,yBAAyB,EAAEuB,WAAW,CAAC;MAErF,IAAIT,WAAW,CAACZ,IAAI,CAAC2B,QAAQ,EAAE;QAC7B;QACA,MAAMzB,gBAAgB,GAAG,MAAM,IAAI,CAAC7B,cAAc,CAACyB,IAAI,CAAC,yBAAyB,EAAE;UACjF,GAAGuB,WAAW;UACduB,UAAU,EAAEhC,WAAW,CAACZ,IAAI,CAAC4C;QAC/B,CAAC,CAAC;QAEF,OAAO;UACL3C,OAAO,EAAE,IAAI;UACb2C,UAAU,EAAEhC,WAAW,CAACZ,IAAI,CAAC4C,UAAU;UACvC,GAAG1C,gBAAgB,CAACF;QACtB,CAAC;MACH,CAAC,MAAM;QACL,MAAM,IAAIH,KAAK,CAACe,WAAW,CAACZ,IAAI,CAACkC,MAAM,IAAI,uBAAuB,CAAC;MACrE;IACF,CAAC,CAAC,OAAOpD,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,MAAM,IAAIe,KAAK,CAAC,6BAA6Bf,KAAK,CAAC4B,OAAO,EAAE,CAAC;IAC/D;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAM2C,aAAaA,CAAA,EAAG;IACpB,IAAI;MACF;MACA,MAAM,CAACzC,WAAW,EAAEV,gBAAgB,CAAC,GAAG,MAAMnB,OAAO,CAAC8B,UAAU,CAAC,CAC/D,IAAI,CAAC3C,SAAS,CAAC4B,IAAI,CAAC,uBAAuB,CAAC,EAC5C,IAAI,CAACzB,cAAc,CAACyB,IAAI,CAAC,uBAAuB,CAAC,CAClD,CAAC;MAEF,OAAO;QACLG,OAAO,EAAE,IAAI;QACbqD,UAAU,EAAE1C,WAAW,CAACzB,MAAM,KAAK,WAAW;QAC9CoE,eAAe,EAAErD,gBAAgB,CAACf,MAAM,KAAK,WAAW;QACxDoB,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;IACH,CAAC,CAAC,OAAO3B,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C;MACA,IAAI;QACF,MAAM,IAAI,CAACT,cAAc,CAACyB,IAAI,CAAC,uBAAuB,CAAC;QACvD,OAAO;UACLG,OAAO,EAAE,IAAI;UACbsD,eAAe,EAAE,IAAI;UACrBD,UAAU,EAAE,KAAK;UACjB/C,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;QACpC,CAAC;MACH,CAAC,CAAC,OAAO+C,aAAa,EAAE;QACtB,MAAM,IAAI3D,KAAK,CAAC,mDAAmD,CAAC;MACtE;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAM4D,SAASA,CAACrC,OAAO,GAAG,CAAC,CAAC,EAAE;IAC5B,IAAI;MACF,MAAMC,WAAW,GAAG;QAClBqC,eAAe,EAAEtC,OAAO,CAACuC,IAAI,IAAI,MAAM;QACvCC,MAAM,EAAExC,OAAO,CAACwC,MAAM,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACnClB,KAAK,EAAEtB,OAAO,CAACsB,KAAK,IAAI,EAAE;QAAE;QAC5B,GAAGtB;MACL,CAAC;;MAED;MACA,MAAMR,WAAW,GAAG,MAAM,IAAI,CAAC1C,SAAS,CAAC4B,IAAI,CAAC,kBAAkB,EAAEuB,WAAW,CAAC;MAE9E,IAAIT,WAAW,CAACZ,IAAI,CAAC2B,QAAQ,EAAE;QAC7B;QACA,MAAMzB,gBAAgB,GAAG,MAAM,IAAI,CAAC7B,cAAc,CAACyB,IAAI,CAAC,kBAAkB,EAAE;UAC1E,GAAGuB,WAAW;UACdwC,aAAa,EAAEjD,WAAW,CAACZ,IAAI,CAAC6D;QAClC,CAAC,CAAC;QAEF,OAAO;UACL5D,OAAO,EAAE,IAAI;UACb4D,aAAa,EAAEjD,WAAW,CAACZ,IAAI,CAAC6D,aAAa;UAC7C,GAAG3D,gBAAgB,CAACF;QACtB,CAAC;MACH,CAAC,MAAM;QACL,MAAM,IAAIH,KAAK,CAACe,WAAW,CAACZ,IAAI,CAACkC,MAAM,IAAI,0BAA0B,CAAC;MACxE;IACF,CAAC,CAAC,OAAOpD,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,qBAAqB,EAAEA,KAAK,CAAC;MAC3C,MAAM,IAAIe,KAAK,CAAC,uBAAuBf,KAAK,CAAC4B,OAAO,EAAE,CAAC;IACzD;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMoD,WAAWA,CAAA,EAAG;IAClB,IAAI;MACF,OAAO,MAAM,IAAI,CAACjB,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;QAC1CH,KAAK,EAAE,EAAE;QACTU,UAAU,EAAE,QAAQ;QACpB3B,aAAa,EAAE;MACjB,CAAC,CAAC;IACJ,CAAC,CAAC,OAAO3C,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,MAAM,IAAIe,KAAK,CAAC,yBAAyBf,KAAK,CAAC4B,OAAO,EAAE,CAAC;IAC3D;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMqD,sBAAsBA,CAAA,EAAG;IAC7B,IAAI;MACF,MAAM9E,QAAQ,GAAG,MAAM,IAAI,CAACf,SAAS,CAAC+C,GAAG,CAAC,kBAAkB,CAAC;MAC7D,OAAOhC,QAAQ,CAACe,IAAI;IACtB,CAAC,CAAC,OAAOlB,KAAK,EAAE;MACd;MACA,OAAO;QACLkF,QAAQ,EAAE,GAAG;QAAE;QACfC,QAAQ,EAAE,CAAC;QACXC,WAAW,EAAE,CACX;UAAEC,GAAG,EAAE,CAAC,GAAG;UAAEC,GAAG,EAAE;QAAI,CAAC;QAAE;QACzB;UAAED,GAAG,EAAE,CAAC,GAAG;UAAEC,GAAG,EAAE;QAAI,CAAC;QAAE;QACzB;UAAED,GAAG,EAAE,CAAC,EAAE;UAAEC,GAAG,EAAE;QAAG,CAAC,CAAI;QAAA;MAE7B,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMC,cAAcA,CAAA,EAAG;IACrB,IAAI;MACF,MAAMpF,QAAQ,GAAG,MAAM,IAAI,CAACf,SAAS,CAAC+C,GAAG,CAAC,eAAe,CAAC;MAC1D,OAAOhC,QAAQ,CAACe,IAAI;IACtB,CAAC,CAAC,OAAOlB,KAAK,EAAE;MACd;MACA,OAAO;QACLwF,GAAG,EAAE,CAAC;QACNC,WAAW,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;QAAE;QAC9BC,UAAU,EAAE,CAAC,UAAU,EAAE,UAAU,EAAE,UAAU,CAAC;QAChDC,UAAU,EAAE,EAAE;QAAE;QAChBC,iBAAiB,EAAE,EAAE,CAAC;MACxB,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMC,eAAeA,CAAClG,MAAM,EAAE;IAC5B,IAAI;MACF,MAAMQ,QAAQ,GAAG,MAAM,IAAI,CAACf,SAAS,CAAC4B,IAAI,CAAC,eAAe,EAAErB,MAAM,CAAC;MACnE,OAAOQ,QAAQ,CAACe,IAAI;IACtB,CAAC,CAAC,OAAOlB,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,MAAM,IAAIe,KAAK,CAAC,oCAAoC,CAAC;IACvD;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAM+E,qBAAqBA,CAACrD,WAAW,EAAE;IACvC,IAAI;MACF,MAAMtC,QAAQ,GAAG,MAAM,IAAI,CAACf,SAAS,CAAC+C,GAAG,CAAC,eAAeM,WAAW,aAAa,CAAC;MAClF,OAAOtC,QAAQ,CAACe,IAAI;IACtB,CAAC,CAAC,OAAOlB,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC3D,OAAO,IAAI;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAM+F,sBAAsBA,CAACtD,WAAW,EAAEuD,OAAO,EAAE;IACjD,IAAI;MACF,MAAM7F,QAAQ,GAAG,MAAM,IAAI,CAACf,SAAS,CAAC4B,IAAI,CAAC,eAAeyB,WAAW,uBAAuB,EAAEuD,OAAO,CAAC;MACtG,OAAO7F,QAAQ,CAACe,IAAI;IACtB,CAAC,CAAC,OAAOlB,KAAK,EAAE;MACdU,OAAO,CAACV,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC3D,MAAM,IAAIe,KAAK,CAAC,oCAAoC,CAAC;IACvD;EACF;;EAEA;;EAEA;AACF;AACA;AACA;AACA;EACE4C,uBAAuBA,CAACF,OAAO,EAAEC,KAAK,EAAE;IACtC,MAAM0B,WAAW,GAAG;MAClB,CAAC,EAAE;QAAEC,GAAG,EAAE,CAAC,GAAG;QAAEC,GAAG,EAAE;MAAI,CAAC;MAC1B,CAAC,EAAE;QAAED,GAAG,EAAE,CAAC,GAAG;QAAEC,GAAG,EAAE;MAAI,CAAC;MAC1B,CAAC,EAAE;QAAED,GAAG,EAAE,CAAC,EAAE;QAAEC,GAAG,EAAE;MAAG;IACzB,CAAC;IAED,IAAI,CAACF,WAAW,CAAC3B,OAAO,CAAC,EAAE;MACzB,MAAM,IAAI1C,KAAK,CAAC,qBAAqB0C,OAAO,EAAE,CAAC;IACjD;IAEA,MAAMwC,MAAM,GAAGb,WAAW,CAAC3B,OAAO,CAAC;IACnC,IAAIC,KAAK,GAAGuC,MAAM,CAACZ,GAAG,IAAI3B,KAAK,GAAGuC,MAAM,CAACX,GAAG,EAAE;MAC5C,MAAM,IAAIvE,KAAK,CAAC,SAAS0C,OAAO,UAAUC,KAAK,yBAAyBuC,MAAM,CAACZ,GAAG,MAAMY,MAAM,CAACX,GAAG,IAAI,CAAC;IACzG;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACErC,sBAAsBA,CAACiD,aAAa,EAAElC,YAAY,EAAE;IAClD,IAAI,CAACkC,aAAa,IAAI,CAAClC,YAAY,IAAIkC,aAAa,CAAC/B,MAAM,KAAKH,YAAY,CAACG,MAAM,EAAE;MACnF,OAAO,CAAC;IACV;IAEA,MAAMgC,MAAM,GAAGD,aAAa,CAACE,GAAG,CAAC,CAACC,OAAO,EAAEhC,KAAK,KAC9CiC,IAAI,CAACC,GAAG,CAACF,OAAO,GAAGrC,YAAY,CAACK,KAAK,CAAC,CACxC,CAAC;IAED,OAAOiC,IAAI,CAAChB,GAAG,CAAC,GAAGa,MAAM,CAAC;EAC5B;;EAEA;AACF;AACA;AACA;AACA;EACEK,0BAA0BA,CAACC,WAAW,EAAE;IACtC,MAAM,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGH,WAAW,CAACL,GAAG,CAAC1C,KAAK,IAAIA,KAAK,GAAG4C,IAAI,CAACO,EAAE,GAAG,GAAG,CAAC;IACpE,MAAM,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;;IAEtC,MAAMC,CAAC,GAAGH,EAAE,GAAGR,IAAI,CAACY,GAAG,CAACR,EAAE,CAAC,GAAGK,EAAE,GAAGT,IAAI,CAACY,GAAG,CAACR,EAAE,GAAGC,EAAE,CAAC,GAAGK,EAAE,GAAGV,IAAI,CAACY,GAAG,CAACR,EAAE,GAAGC,EAAE,GAAGC,EAAE,CAAC;IAClF,MAAMO,CAAC,GAAGL,EAAE,GAAGR,IAAI,CAACc,GAAG,CAACV,EAAE,CAAC,GAAGK,EAAE,GAAGT,IAAI,CAACc,GAAG,CAACV,EAAE,GAAGC,EAAE,CAAC,GAAGK,EAAE,GAAGV,IAAI,CAACc,GAAG,CAACV,EAAE,GAAGC,EAAE,GAAGC,EAAE,CAAC;IAClF,MAAMS,CAAC,GAAG,CAAC,CAAC,CAAC;;IAEb,OAAO;MAAEJ,CAAC;MAAEE,CAAC;MAAEE;IAAE,CAAC;EACpB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,mBAAmBA,CAACC,QAAQ,EAAEC,SAAS,EAAE;IACvC,MAAMC,QAAQ,GAAGnB,IAAI,CAACoB,IAAI,CAACH,QAAQ,CAACN,CAAC,IAAI,CAAC,GAAGM,QAAQ,CAACJ,CAAC,IAAI,CAAC,CAAC;IAC7D,OAAOM,QAAQ,IAAID,SAAS,CAACrC,QAAQ,IAAIsC,QAAQ,IAAID,SAAS,CAACtC,QAAQ;EACzE;;EAEA;AACF;AACA;AACA;EACE,MAAMyC,eAAeA,CAAA,EAAG;IACtB,IAAI;MACF,MAAM,CAACC,SAAS,EAAEC,cAAc,CAAC,GAAG,MAAM5H,OAAO,CAAC8B,UAAU,CAAC,CAC3D,IAAI,CAAC3C,SAAS,CAAC+C,GAAG,CAAC,SAAS,CAAC,EAC7B,IAAI,CAAC5C,cAAc,CAAC4C,GAAG,CAAC,SAAS,CAAC,CACnC,CAAC;MAEF,OAAO;QACL2F,GAAG,EAAE;UACHhH,SAAS,EAAE8G,SAAS,CAACvH,MAAM,KAAK,WAAW;UAC3CA,MAAM,EAAEuH,SAAS,CAACvH,MAAM,KAAK,WAAW,GAAGuH,SAAS,CAACG,KAAK,CAAC7G,IAAI,GAAG,IAAI;UACtElB,KAAK,EAAE4H,SAAS,CAACvH,MAAM,KAAK,UAAU,GAAGuH,SAAS,CAACxE,MAAM,CAACxB,OAAO,GAAG;QACtE,CAAC;QACDoG,QAAQ,EAAE;UACRlH,SAAS,EAAE+G,cAAc,CAACxH,MAAM,KAAK,WAAW;UAChDA,MAAM,EAAEwH,cAAc,CAACxH,MAAM,KAAK,WAAW,GAAGwH,cAAc,CAACE,KAAK,CAAC7G,IAAI,GAAG,IAAI;UAChFlB,KAAK,EAAE6H,cAAc,CAACxH,MAAM,KAAK,UAAU,GAAGwH,cAAc,CAACzE,MAAM,CAACxB,OAAO,GAAG;QAChF,CAAC;QACDH,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;IACH,CAAC,CAAC,OAAO3B,KAAK,EAAE;MACd,OAAO;QACL8H,GAAG,EAAE;UAAEhH,SAAS,EAAE,KAAK;UAAEd,KAAK,EAAEA,KAAK,CAAC4B;QAAQ,CAAC;QAC/CoG,QAAQ,EAAE;UAAElH,SAAS,EAAE,KAAK;UAAEd,KAAK,EAAEA,KAAK,CAAC4B;QAAQ,CAAC;QACpDH,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;IACH;EACF;AACF;;AAEA;AACA,OAAO,MAAMsG,YAAY,GAAG,IAAItJ,YAAY,CAAC,CAAC;AAC9C,eAAesJ,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}