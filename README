# ESP32 Dynamixel Controller - React Frontend

A professional React-based web interface for controlling Dynamixel motors via ESP32 using WebSerial API. This application provides real-time motor control, Challenge 10 execution, data visualization, and comprehensive system monitoring.

## ğŸš€ Features

- **Real-time Motor Control**: Individual motor position and velocity control
- **WebSerial Integration**: Direct communication with ESP32 via browser
- **Challenge 10**: Mixed mode control demonstration
- **Live Data Visualization**: Real-time charts using Chart.js
- **Modern UI**: Material-UI components with dark theme
- **State Management**: Redux Toolkit for predictable state updates
- **Progressive Web App**: PWA support for desktop and mobile
- **Responsive Design**: Works on desktop, tablet, and mobile devices

## ğŸ—ï¸ Project Structure

```
src/
â”œâ”€â”€ components/           # React components
â”‚   â”œâ”€â”€ charts/          # Chart components
â”‚   â”‚   â””â”€â”€ RealTimeChart.jsx
â”‚   â”œâ”€â”€ challenges/      # Challenge-specific components
â”‚   â”‚   â””â”€â”€ Challenge10.jsx
â”‚   â”œâ”€â”€ common/          # Reusable UI components
â”‚   â”‚   â”œâ”€â”€ LoadingOverlay.jsx
â”‚   â”‚   â””â”€â”€ NotificationSystem.jsx
â”‚   â”œâ”€â”€ dashboard/       # Dashboard components
â”‚   â”‚   â”œâ”€â”€ Dashboard.jsx
â”‚   â”‚   â”œâ”€â”€ ConnectionCard.jsx
â”‚   â”‚   â”œâ”€â”€ QuickActions.jsx
â”‚   â”‚   â”œâ”€â”€ StatsCard.jsx
â”‚   â”‚   â”œâ”€â”€ SystemOverview.jsx
â”‚   â”‚   â””â”€â”€ RecentLogs.jsx
â”‚   â”œâ”€â”€ layout/          # Layout components
â”‚   â”‚   â”œâ”€â”€ Layout.jsx
â”‚   â”‚   â”œâ”€â”€ Header.jsx
â”‚   â”‚   â””â”€â”€ Sidebar.jsx
â”‚   â””â”€â”€ robot/           # Motor control components
â”‚       â”œâ”€â”€ MotorControl.jsx
â”‚       â”œâ”€â”€ MotorCard.jsx
â”‚       â””â”€â”€ AdvancedControls.jsx
â”œâ”€â”€ hooks/               # Custom React hooks
â”‚   â”œâ”€â”€ useRobot.js      # Robot control hook
â”‚   â””â”€â”€ useWebSerial.js  # WebSerial communication hook
â”œâ”€â”€ services/            # API and external services
â”‚   â”œâ”€â”€ api.js           # HTTP API service
â”‚   â””â”€â”€ websocketService.js
â”œâ”€â”€ store/               # Redux store
â”‚   â”œâ”€â”€ store.js         # Store configuration
â”‚   â”œâ”€â”€ robotSlice.js    # Robot state management
â”‚   â”œâ”€â”€ challengeSlice.js # Challenge state management
â”‚   â””â”€â”€ uiSlice.js       # UI state management
â”œâ”€â”€ utils/               # Utility functions
â”‚   â”œâ”€â”€ constants.js     # Application constants
â”‚   â””â”€â”€ helpers.js       # Helper functions
â”œâ”€â”€ App.js               # Main App component
â”œâ”€â”€ App.css              # Global styles
â”œâ”€â”€ index.js             # Entry point
â””â”€â”€ index.css            # Base styles
```

## ğŸ› ï¸ Technology Stack

- **React 18**: Modern React with hooks and concurrent features
- **Material-UI (MUI)**: Professional UI component library
- **Redux Toolkit**: Predictable state management
- **Chart.js**: Real-time data visualization
- **WebSerial API**: Direct browser-to-ESP32 communication
- **React Router**: Client-side routing
- **Axios**: HTTP client for API calls

## ğŸ“‹ Prerequisites

- Node.js 16+ and npm
- Modern browser with WebSerial support (Chrome 89+, Edge 89+)
- ESP32 with Dynamixel motors (for hardware functionality)

## ğŸš€ Quick Start

### 1. Installation

```bash
# Clone the repository
git clone <repository-url>
cd esp32-dynamixel-controller

# Install dependencies
npm install
```

### 2. Environment Configuration

Create a `.env` file in the root directory:

```env
REACT_APP_API_URL=http://localhost:8000/api/v1
REACT_APP_WS_URL=ws://localhost:8000/ws
REACT_APP_VERSION=1.0.0
```

### 3. Development

```bash
# Start development server
npm start

# Open browser to http://localhost:3000
```

### 4. Production Build

```bash
# Create production build
npm run build

# Serve static files
npm install -g serve
serve -s build
```

## ğŸ”§ Configuration

### WebSerial Settings

The application uses the following WebSerial configuration:

```javascript
const WEBSERIAL_CONFIG = {
  baudRate: 115200,
  dataBits: 8,
  stopBits: 1,
  parity: 'none',
  flowControl: 'none',
};
```

### Motor Constants

Configured for Dynamixel XL330-M288 motors:

```javascript
const MOTOR_CONSTANTS = {
  resolution: 4095,        // 12-bit resolution
  maxPosition: 4095,
  centerPosition: 2048,
  maxVelocity: 50,         // degrees per second
  degreesPerUnit: 360 / 4095,
  protocol: 2.0,
};
```

## ğŸ® Usage Guide

### Connecting to ESP32

1. **Check Browser Compatibility**: Ensure you're using Chrome 89+ or Edge 89+
2. **Connect Hardware**: Connect ESP32 to your computer via USB
3. **Click Connect**: Use the "Connect to ESP32" button in the dashboard
4. **Select Port**: Choose the correct COM port in the browser dialog
5. **Scan Motors**: Click "Scan Motors" to detect connected Dynamixel motors

### Motor Control

1. **Enable Torque**: Toggle torque on individual motors or globally
2. **Position Control**: Use sliders or input fields to set target positions (0-360Â°)
3. **Velocity Control**: Set motor velocities (-50 to +50 degrees/second)
4. **Quick Actions**: Use Home, Stop, and Emergency Stop buttons

### Challenge 10 - Mixed Mode Control

1. **Navigate**: Go to Challenge 10 page
2. **Configure**: Set duration, speed, and frequency parameters
3. **Prerequisites**: Ensure motors 1 and 2 are connected and online
4. **Start**: Click "Start Challenge" to begin mixed mode control
5. **Monitor**: Watch real-time charts showing position and velocity data
6. **Stop**: Use "Stop Challenge" or wait for automatic completion

### Data Export

1. **Chart Data**: Export motor position/velocity data to CSV
2. **Communication Logs**: Export all ESP32 communication logs
3. **Screenshots**: Capture interface screenshots
4. **Advanced**: Use bulk commands and manual testing features

## ğŸ” Advanced Features

### Custom Commands

Send raw commands to ESP32:
```
PING:1              # Ping motor 1
ENABLE_TORQUE:1     # Enable torque on motor 1
SET_POS:1:2048      # Set motor 1 to center position
SET_VEL:1:100       # Set motor 1 velocity
GET_POS:1           # Read motor 1 position
```

### Bulk Operations

Execute multiple commands sequentially:
```
PING:1
ENABLE_TORQUE:1
SET_POS:1:2048
DISABLE_TORQUE:1
```

### System Settings

- **Debug Mode**: Enable verbose logging
- **Auto Connect**: Automatically connect on page load
- **Chart Update Rate**: Adjust real-time chart refresh rate
- **Log Level**: Filter communication logs by severity

## ğŸ› Troubleshooting

### WebSerial Issues

- **Not Supported**: Use Chrome 89+ or Edge 89+
- **Permission Denied**: Check browser security settings
- **Port Not Found**: Ensure ESP32 drivers are installed

### Connection Problems

- **ESP32 Not Responding**: Check USB cable and power
- **Invalid Baud Rate**: Verify ESP32 is configured for 115200
- **Timeout Errors**: Check for interference or cable issues

### Motor Detection

- **No Motors Found**: Verify motor power and connections
- **Wrong IDs**: Use Dynamixel Wizard to set motor IDs (1, 2, 3...)
- **Communication Errors**: Check TTL level conversion

## ğŸ“± Mobile Support

The interface is responsive and works on mobile devices:

- **Touch Controls**: All sliders and buttons work with touch
- **Responsive Layout**: Adapts to different screen sizes
- **PWA Support**: Can be installed as a mobile app

## ğŸ”’ Security

- **Local Communication**: WebSerial provides secure direct communication
- **No External Dependencies**: Runs entirely in the browser
- **HTTPS Required**: WebSerial requires secure context (HTTPS/localhost)

## ğŸš€ Performance

### Optimization Features

- **Component Memoization**: React.memo prevents unnecessary re-renders
- **Virtual Scrolling**: Efficient handling of large log lists
- **Throttled Updates**: Rate-limited chart updates for smooth performance
- **Lazy Loading**: Components loaded on demand

### Real-time Performance

- **10ms Update Rate**: Challenge 10 runs at 100Hz for precise control
- **Chart Optimization**: Limited to 300 data points for smooth rendering
- **WebSerial Optimization**: Efficient binary communication protocol

## ğŸ“Š Monitoring & Analytics

### Real-time Charts

- **Position Tracking**: Live motor position visualization
- **Velocity Monitoring**: Real-time velocity data
- **Multi-motor Support**: Up to 3 motors simultaneously
- **Data Export**: CSV export for analysis

### System Metrics

- **Connection Uptime**: Track connection duration
- **Command Count**: Monitor communication volume
- **Error Rate**: Track communication failures
- **Performance**: Monitor update rates and latency

## ğŸ”§ Development

### Adding New Components

1. Create component in appropriate directory
2. Follow existing patterns for state management
3. Use Material-UI components for consistency
4. Add proper TypeScript types if converting

### Custom Hooks

The application uses custom hooks for:

- **useWebSerial**: Low-level ESP32 communication
- **useRobot**: High-level motor control operations
- **Redux hooks**: State management integration

### State Management

- **Robot State**: Connection, motors, real-time data
- **Challenge State**: Challenge 10 progress and parameters
- **UI State**: Notifications, preferences, layout

## ğŸ“ API Integration

The frontend is designed to work with both:

1. **Direct WebSerial**: Direct ESP32 communication (current implementation)
2. **Backend API**: RESTful API for advanced features (future enhancement)

### WebSerial Protocol

Commands follow this format:
```
COMMAND:MOTOR_ID:PARAMETER;
```

Responses:
```
OK                    # Command successful
PING_OK              # Motor responded to ping
POS:2048             # Position reading
ERROR:message        # Error occurred
```

## ğŸ”„ Future Enhancements

- **3D Robot Visualization**: Three.js robot arm model
- **Advanced Kinematics**: Forward/inverse kinematics calculations
- **More Challenges**: Additional educational challenges
- **Cloud Sync**: Save configurations and data to cloud
- **Multi-User**: Collaborative control sessions
- **VR Support**: Virtual reality motor control interface

## ğŸ“„ License

This project is licensed under the MIT License - see the LICENSE file for details.

## ğŸ¤ Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests if applicable
5. Submit a pull request

## ğŸ“ Support

For support and questions:
- Check the troubleshooting section
- Review browser compatibility requirements
- Ensure hardware connections are correct
- Verify ESP32 firmware is compatible

---

**Note**: This is a browser-based application that requires WebSerial API support. It will not work in browsers that don't support this feature (Safari, Firefox, etc.). Use Chrome 89+ or Edge 89+ for full functionality.